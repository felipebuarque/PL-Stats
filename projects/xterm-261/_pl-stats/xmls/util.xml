<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" dir="" filename="util.c"><comment type="block">/* $XTermId: util.c,v 1.538 2010/06/15 08:17:36 tom Exp $ */</comment>

<comment type="block">/*
 * Copyright 1999-2009,2010 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */</comment>

<comment type="block">/* util.c */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;data.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;error.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;menu.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fontutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xstrings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCHAR_H</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCWIDTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wcwidth.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>static</name> <name>int</name></type> <name>handle_translated_exposure</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
				      <param><decl><type><name>int</name></type> <name>rect_x</name></decl></param>,
				      <param><decl><type><name>int</name></type> <name>rect_y</name></decl></param>,
				      <param><decl><type><name>int</name></type> <name>rect_width</name></decl></param>,
				      <param><decl><type><name>int</name></type> <name>rect_height</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>ClearLeft</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>CopyWait</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>horizontal_copy_area</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
				 <param><decl><type><name>int</name></type> <name>firstchar</name></decl></param>,
				 <param><decl><type><name>int</name></type> <name>nchars</name></decl></param>,
				 <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>vertical_copy_area</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
			       <param><decl><type><name>int</name></type> <name>firstline</name></decl></param>,
			       <param><decl><type><name>int</name></type> <name>nlines</name></decl></param>,
			       <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name></type> <name>first_widechar</name></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> (*<name>my_wcwidth</name>) <parameter_list>(<param><decl><type><name>wchar_t</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
 * We will modify the 'n' cells beginning at the current position.
 * Some of those cells may be part of multi-column characters, including
 * carryover from the left.  Find the limits of the multi-column characters
 * that we should fill with blanks, return true if filling is needed.
 */</comment>
<function><type><name>int</name></type>
<name>DamagedCells</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>klp</name></decl></param>, <param><decl><type><name>int</name> *</type><name>krp</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>col</name> &lt; (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nn</name> =<init> <expr>(<name>int</name>) <name>n</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>kl</name> =<init> <expr><name>col</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>kr</name> =<init> <expr><name>col</name> + <name>nn</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>kr</name> &gt;= <name>ld</name>-&gt;<name>lineSize</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>nn</name> = (<name>ld</name>-&gt;<name>lineSize</name> - <name>col</name> - 1)</expr>;</expr_stmt>
	    <expr_stmt><expr><name>kr</name> = <name>col</name> + <name>nn</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>nn</name> &gt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>kl</name> &lt; <name>ld</name>-&gt;<name>lineSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>kl</name></expr>]</index></name> == <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr><name>kl</name> &gt; 0</expr>)</condition> <block>{
		    <if>if <condition>(<expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr>--<name>kl</name></expr>]</index></name> != <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
			<break>break;</break>
		    }</block></then></if>
		}</block></while>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>kl</name> = <name>col</name> + 1</expr>;</expr_stmt>
	    }</block></else></if>

	    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>kr</name> &lt; (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>kr</name></expr>]</index></name> == <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr><name>kr</name> &lt; <name>screen</name>-&gt;<name>max_col</name></expr>)</condition> <block>{
		    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>kr</name> + 1) &lt; (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr>++<name>kr</name></expr>]</index></name> != <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
			<expr_stmt><expr>--<name>kr</name></expr>;</expr_stmt>
			<break>break;</break>
		    }</block></then></if>
		}</block></while>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>kr</name> = <name>col</name> - 1</expr>;</expr_stmt>
	    }</block></else></if>

	    <if>if <condition>(<expr><name>klp</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>klp</name> = <name>kl</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>krp</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>krp</name> = <name>kr</name></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>result</name> = (<name>kr</name> &gt;= <name>kl</name>)</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>DamagedCurCells</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name> *</type><name>klp</name></decl></param>, <param><decl><type><name>int</name> *</type><name>krp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>DamagedCells</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>klp</name></expr></argument>, <argument><expr><name>krp</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_WIDE_CHARS */</comment>

<comment type="block">/*
 * These routines are used for the jump scroll feature
 */</comment>
<function><type><name>void</name></type>
<name>FlushScroll</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shift</name> =<init> <expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bot</name> =<init> <expr><name>screen</name>-&gt;<name>max_row</name> - <name>shift</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshtop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshheight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrolltop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrollheight</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>refreshheight</name> = <name>screen</name>-&gt;<name>refresh_amt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrollheight</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>top_marg</name> -
	    <name>refreshheight</name> + 1</expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>refreshtop</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>refreshheight</name> + 1 + <name>shift</name>) &gt;
	    (<name>i</name> = <name>screen</name>-&gt;<name>max_row</name> - <name>screen</name>-&gt;<name>scroll_amt</name> + 1)</expr>)</condition><then>
	    <expr_stmt><expr><name>refreshtop</name> = <name>i</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scrollWidget</name>
	    &amp;&amp; !<name>screen</name>-&gt;<name>whichBuf</name>
	    &amp;&amp; <name>screen</name>-&gt;<name>top_marg</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>scrolltop</name> = 0</expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>scrollheight</name> += <name>shift</name>) &gt; <name>i</name></expr>)</condition><then>
		<expr_stmt><expr><name>scrollheight</name> = <name>i</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>bot</name>) &gt; 0 &amp;&amp;
		(<name>refreshheight</name> -= <name>i</name>) &lt; <name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		<expr_stmt><expr><name>refreshheight</name> = <name>screen</name>-&gt;<name>scroll_amt</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>savedlines</name>) &lt; <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>i</name> += <name>screen</name>-&gt;<name>scroll_amt</name>) &gt;
		    <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then>
		    <expr_stmt><expr><name>i</name> = <name>screen</name>-&gt;<name>savelines</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScrollBarDrawThumb</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>scrolltop</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>shift</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>i</name> = <name>bot</name> - (<name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>refresh_amt</name> +
			    <name>screen</name>-&gt;<name>scroll_amt</name>)) &gt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>bot</name> &lt; <name>screen</name>-&gt;<name>bot_marg</name></expr>)</condition><then>
		    <expr_stmt><expr><name>refreshheight</name> = <name>screen</name>-&gt;<name>scroll_amt</name> + <name>i</name></expr>;</expr_stmt></then></if>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>scrollheight</name> += <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>refreshheight</name> = <name>screen</name>-&gt;<name>scroll_amt</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>screen</name>-&gt;<name>scroll_amt</name> -
		     1 - <name>bot</name>) &gt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>refreshtop</name> += <name>i</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>refreshheight</name> -= <name>i</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></else></if>
	}</block></else></if>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>refreshheight</name> = -<name>screen</name>-&gt;<name>refresh_amt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrollheight</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>top_marg</name> -
	    <name>refreshheight</name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>refreshtop</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>shift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrolltop</name> = <name>refreshtop</name> + <name>refreshheight</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>bot</name>) &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>scrollheight</name> -= <name>i</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>refreshheight</name> - 1 - <name>bot</name>) &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>refreshheight</name> -= <name>i</name></expr>;</expr_stmt></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>scrolling_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>scrolltop</name> + <name>screen</name>-&gt;<name>scroll_amt</name></expr></argument>,
			<argument><expr><name>scrollheight</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>scroll_amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScrollSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>-(<name>screen</name>-&gt;<name>scroll_amt</name>)</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>refreshheight</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr>(<name>int</name>) <name>refreshtop</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
			   <argument><expr>(<name>int</name>) <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>refreshheight</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>refreshtop</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>refreshheight</name></expr></argument>,
		    <argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
}</block></function>

<comment type="block">/*
 * Returns true if there are lines off-screen due to scrolling which should
 * include the current line.  If false, the line is visible and we should
 * paint it now rather than waiting for the line to become visible.
 */</comment>
<function><type><name>int</name></type>
<name>AddToRefresh</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>amount</name> =<init> <expr><name>screen</name>-&gt;<name>refresh_amt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr><name>screen</name>-&gt;<name>cur_row</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>amount</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>amount</name> &gt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>bottom</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>row</name> == (<name>bottom</name> = <name>screen</name>-&gt;<name>bot_marg</name>) - <name>amount</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name>++</expr>;</expr_stmt>
	    <expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>result</name> = (<name>row</name> &gt;= <name>bottom</name> - <name>amount</name> + 1 &amp;&amp; <name>row</name> &lt;= <name>bottom</name>)</expr>;</expr_stmt>
	}</block></else></if>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>amount</name> = -<name>amount</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>row</name> == (<name>top</name> = <name>screen</name>-&gt;<name>top_marg</name>) + <name>amount</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name>--</expr>;</expr_stmt>
	    <expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>result</name> = (<name>row</name> &lt;= <name>top</name> + <name>amount</name> - 1 &amp;&amp; <name>row</name> &gt;= <name>top</name>)</expr>;</expr_stmt>
	}</block></else></if>
    }</block></else></if></else></if>

    <comment type="block">/*
     * If this line is visible, and there are scrolled-off lines, flush out
     * those which are now visible.
     */</comment>
    <if>if <condition>(<expr>!<name>result</name> &amp;&amp; <name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Returns true if the current row is in the visible area (it should be for
 * screen operations) and incidentally flush the scrolled-in lines which
 * have newly become visible.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>AddToVisible</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call> &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>!<call><name>AddToRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * If we're scrolling, leave the selection intact if possible.
 * If it will bump into one of the extremes of the saved-lines, truncate that.
 * If the selection is not contained within the scrolled region, clear it.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>adjustHiliteOnFwdScroll</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>amount</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>all_lines</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lo_row</name> =<init> <expr>(<name>all_lines</name>
		  ? (<name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>savelines</name>)
		  : <name>screen</name>-&gt;<name>top_marg</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hi_row</name> =<init> <expr><name>screen</name>-&gt;<name>bot_marg</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("adjustSelection FWD %s by %d (%s)\n",
	    <name>screen</name>-&gt;<name>whichBuf</name> ? "alternate" : "normal",
	    <name>amount</name>,
	    <name>all_lines</name> ? "all" : "visible")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("  before highlite %d.%d .. %d.%d\n",
	    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("  margins %d..%d\n", <name>screen</name>-&gt;<name>top_marg</name>, <name>screen</name>-&gt;<name>bot_marg</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("  limits  %d..%d\n", <name>lo_row</name>, <name>hi_row</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>startH</name>.<name>row</name> &gt;= <name>lo_row</name>
	&amp;&amp; <name>screen</name>-&gt;<name>startH</name>.<name>row</name> - <name>amount</name> &lt; <name>lo_row</name></expr>)</condition><then> <block>{
	<comment type="block">/* truncate the selection because its start would move out of region */</comment>
	<if>if <condition>(<expr><name>lo_row</name> + <name>amount</name> &lt;= <name>screen</name>-&gt;<name>endH</name>.<name>row</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("truncate selection by changing start %d.%d to %d.%d\n",
		    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
		    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
		    <name>lo_row</name> + <name>amount</name>,
		    0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>startH</name>.<name>row</name> = <name>lo_row</name> + <name>amount</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>startH</name>.<name>col</name> = 0</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("deselect because %d.%d .. %d.%d shifted %d is outside margins %d..%d\n",
		    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
		    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
		    <name>screen</name>-&gt;<name>endH</name>.<name>row</name>,
		    <name>screen</name>-&gt;<name>endH</name>.<name>col</name>,
		    -<name>amount</name>,
		    <name>lo_row</name>,
		    <name>hi_row</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>startH</name>.<name>row</name> &lt;= <name>hi_row</name> &amp;&amp; <name>screen</name>-&gt;<name>endH</name>.<name>row</name> &gt; <name>hi_row</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>startH</name>.<name>row</name> &lt; <name>lo_row</name> &amp;&amp; <name>screen</name>-&gt;<name>endH</name>.<name>row</name> &gt; <name>lo_row</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>

    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("  after highlite %d.%d .. %d.%d\n",
	    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * This is the same as adjustHiliteOnFwdScroll(), but reversed.  In this case,
 * only the visible lines are affected.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>adjustHiliteOnBakScroll</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lo_row</name> =<init> <expr><name>screen</name>-&gt;<name>top_marg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hi_row</name> =<init> <expr><name>screen</name>-&gt;<name>bot_marg</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("adjustSelection BAK %s by %d (%s)\n",
	    <name>screen</name>-&gt;<name>whichBuf</name> ? "alternate" : "normal",
	    <name>amount</name>,
	    "visible")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("  before highlite %d.%d .. %d.%d\n",
	    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("  margins %d..%d\n", <name>screen</name>-&gt;<name>top_marg</name>, <name>screen</name>-&gt;<name>bot_marg</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>endH</name>.<name>row</name> &gt;= <name>hi_row</name>
	&amp;&amp; <name>screen</name>-&gt;<name>endH</name>.<name>row</name> + <name>amount</name> &gt; <name>hi_row</name></expr>)</condition><then> <block>{
	<comment type="block">/* truncate the selection because its start would move out of region */</comment>
	<if>if <condition>(<expr><name>hi_row</name> - <name>amount</name> &gt;= <name>screen</name>-&gt;<name>startH</name>.<name>row</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("truncate selection by changing start %d.%d to %d.%d\n",
		    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
		    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
		    <name>hi_row</name> - <name>amount</name>,
		    0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>endH</name>.<name>row</name> = <name>hi_row</name> - <name>amount</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>endH</name>.<name>col</name> = 0</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("deselect because %d.%d .. %d.%d shifted %d is outside margins %d..%d\n",
		    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
		    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
		    <name>screen</name>-&gt;<name>endH</name>.<name>row</name>,
		    <name>screen</name>-&gt;<name>endH</name>.<name>col</name>,
		    <name>amount</name>,
		    <name>lo_row</name>,
		    <name>hi_row</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>endH</name>.<name>row</name> &gt;= <name>lo_row</name> &amp;&amp; <name>screen</name>-&gt;<name>startH</name>.<name>row</name> &lt; <name>lo_row</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>endH</name>.<name>row</name> &gt; <name>hi_row</name> &amp;&amp; <name>screen</name>-&gt;<name>startH</name>.<name>row</name> &gt; <name>hi_row</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>

    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("  after highlite %d.%d .. %d.%d\n",
	    <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>row</name>,
	    <name>screen</name>-&gt;<name>endH</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * scrolls the screen by amount lines, erases bottom, doesn't alter
 * cursor position (i.e. cursor moves down amount relative to text).
 * All done within the scrolling region, of course.
 * requires: amount &gt; 0
 */</comment>
<function><type><name>void</name></type>
<name>xtermScroll</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>top_marg</name> + 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshtop</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshheight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrolltop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrollheight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>scroll_all_lines</name> =<init> <expr><call>(<name>Boolean</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name>
					  &amp;&amp; !<name>screen</name>-&gt;<name>whichBuf</name>
					  &amp;&amp; <name>screen</name>-&gt;<name>top_marg</name> == 0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermScroll count=%d\n", <name>amount</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_busy</name> += 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_moved</name> = <name>True</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>amount</name> &gt; <name>i</name></expr>)</condition><then>
	<expr_stmt><expr><name>amount</name> = <name>i</name></expr>;</expr_stmt></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>allowScrollLock</name> &amp;&amp; <name>screen</name>-&gt;<name>scroll_lock</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>refreshheight</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr>--(<name>screen</name>-&gt;<name>topline</name>) &lt; -<name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>topline</name> = -<name>screen</name>-&gt;<name>savelines</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scroll_dirty</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>++(<name>screen</name>-&gt;<name>savedlines</name>) &gt; <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = <name>screen</name>-&gt;<name>savelines</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
	<if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>adjustHiliteOnFwdScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>scroll_all_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>jumpscroll</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &gt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>fastscroll</name></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>refresh_amt</name> + <name>amount</name> &gt; <name>i</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> += <name>amount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> += <name>amount</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>fastscroll</name></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> = <name>amount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> = <name>amount</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><name>refreshheight</name> = 0</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>ScrollSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>-(<name>amount</name>)</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>amount</name> == <name>i</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ClearScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>cursor_busy</name> -= 1</expr>;</expr_stmt>
		<return>return;</return>
	    }</block></then></if>

	    <expr_stmt><expr><name>shift</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>bot</name> = <name>screen</name>-&gt;<name>max_row</name> - <name>shift</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>scrollheight</name> = <name>i</name> - <name>amount</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>refreshheight</name> = <name>amount</name></expr>;</expr_stmt>

	    <if>if <condition>(<expr>(<name>refreshtop</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>refreshheight</name> + 1 + <name>shift</name>) &gt;
		(<name>i</name> = <name>screen</name>-&gt;<name>max_row</name> - <name>refreshheight</name> + 1)</expr>)</condition><then>
		<expr_stmt><expr><name>refreshtop</name> = <name>i</name></expr>;</expr_stmt></then></if>

	    <if>if <condition>(<expr><name>scroll_all_lines</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>scrolltop</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>scrollheight</name> += <name>shift</name>) &gt; <name>i</name></expr>)</condition><then>
		    <expr_stmt><expr><name>scrollheight</name> = <name>i</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>savedlines</name>) &lt; <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr>(<name>i</name> += <name>amount</name>) &gt; <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then>
			<expr_stmt><expr><name>i</name> = <name>screen</name>-&gt;<name>savelines</name></expr>;</expr_stmt></then></if>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = <name>i</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>ScrollBarDrawThumb</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>scrolltop</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>shift</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>bot</name>) &gt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>scrollheight</name> -= <name>i</name></expr>;</expr_stmt>
		    <if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>amount</name> - 1 - <name>bot</name>) &gt;= 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>refreshtop</name> += <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>refreshheight</name> -= <name>i</name></expr>;</expr_stmt>
		    }</block></then></if>
		}</block></then></if>
	    }</block></else></if>

	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>multiscroll</name> &amp;&amp; <name>amount</name> == 1 &amp;&amp;
		<name>screen</name>-&gt;<name>topline</name> == 0 &amp;&amp; <name>screen</name>-&gt;<name>top_marg</name> == 0 &amp;&amp;
		<name>screen</name>-&gt;<name>bot_marg</name> == <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>incopy</name> &lt; 0 &amp;&amp; <name>screen</name>-&gt;<name>scrolls</name> == 0</expr>)</condition><then>
		    <expr_stmt><expr><call><name>CopyWait</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>scrolls</name>++</expr>;</expr_stmt>
	    }</block></then></if>

	    <expr_stmt><expr><call><name>scrolling_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>scrolltop</name> + <name>amount</name></expr></argument>, <argument><expr><name>scrollheight</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name>refreshheight</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				   <argument><expr>(<name>int</name>) <name>refreshtop</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
				   <argument><expr>(<name>int</name>) <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>refreshheight</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>refreshheight</name> &gt; <name>shift</name></expr>)</condition><then>
		    <expr_stmt><expr><name>refreshheight</name> = <name>shift</name></expr>;</expr_stmt></then></if>
	    }</block></then></if>
	}</block></else></if>
    }</block></else></if>

    <if>if <condition>(<expr><name>amount</name> &gt; 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>scroll_all_lines</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ScrnDeleteLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>bot_marg</name> + <name>screen</name>-&gt;<name>savelines</name></expr></argument>,
			   <argument><expr>0</expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>ScrnDeleteLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>visbuf</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>bot_marg</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>top_marg</name></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>refreshheight</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>refreshtop</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>refreshheight</name></expr></argument>,
		    <argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_busy</name> -= 1</expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<comment type="block">/*
 * Reverse scrolls the screen by amount lines, erases top, doesn't alter
 * cursor position (i.e. cursor moves up amount relative to text).
 * All done within the scrolling region, of course.
 * Requires: amount &gt; 0
 */</comment>
<function><type><name>void</name></type>
<name>RevScroll</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>top_marg</name> + 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshtop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshheight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrolltop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrollheight</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("RevScroll count=%d\n", <name>amount</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_busy</name> += 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_moved</name> = <name>True</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>amount</name> &gt; <name>i</name></expr>)</condition><then>
	<expr_stmt><expr><name>amount</name> = <name>i</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>adjustHiliteOnBakScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>jumpscroll</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &lt; 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>-<name>screen</name>-&gt;<name>refresh_amt</name> + <name>amount</name> &gt; <name>i</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> -= <name>amount</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> -= <name>amount</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> = -<name>amount</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> = -<name>amount</name></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>shift</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bot</name> = <name>screen</name>-&gt;<name>max_row</name> - <name>shift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>refreshheight</name> = <name>amount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrollheight</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>top_marg</name> -
	    <name>refreshheight</name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>refreshtop</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>shift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrolltop</name> = <name>refreshtop</name> + <name>refreshheight</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>bot</name>) &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>scrollheight</name> -= <name>i</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>top_marg</name> + <name>refreshheight</name> - 1 - <name>bot</name>) &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>refreshheight</name> -= <name>i</name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>multiscroll</name> &amp;&amp; <name>amount</name> == 1 &amp;&amp;
	    <name>screen</name>-&gt;<name>topline</name> == 0 &amp;&amp; <name>screen</name>-&gt;<name>top_marg</name> == 0 &amp;&amp;
	    <name>screen</name>-&gt;<name>bot_marg</name> == <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>incopy</name> &lt; 0 &amp;&amp; <name>screen</name>-&gt;<name>scrolls</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>CopyWait</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scrolls</name>++</expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>scrolling_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>scrolltop</name> - <name>amount</name></expr></argument>, <argument><expr><name>scrollheight</name></expr></argument>, <argument><expr>-<name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>refreshheight</name> &gt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			       <argument><expr>(<name>int</name>) <name>refreshtop</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
			       <argument><expr>(<name>int</name>) <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>refreshheight</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
    <if>if <condition>(<expr><name>amount</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnInsertLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>visbuf</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>bot_marg</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>top_marg</name></expr></argument>,
		       <argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_busy</name> -= 1</expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<comment type="block">/*
 * write a string str of length len onto the screen at
 * the current cursor position.  update cursor position.
 */</comment>
<function><type><name>void</name></type>
<name>WriteText</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>IChar</name> *</type> <name>str</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>test</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> =<init> <expr><name>xw</name>-&gt;<name>flags</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CellColor</name></type> <name>fg_bg</name> =<init> <expr><call><name>makeColorPair</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>cur_foreground</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>cur_background</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>cells</name> =<init> <expr><call><name>visual_width</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GC</name></type> <name>currentGC</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("WriteText %d (%2d,%2d) %3d:%s\n",
	   <name>screen</name>-&gt;<name>topline</name>,
	   <name>screen</name>-&gt;<name>cur_row</name>,
	   <name>screen</name>-&gt;<name>cur_col</name>,
	   <name>len</name>, <call><name>visibleIChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>cells</name> + (<name>unsigned</name>) <name>screen</name>-&gt;<name>cur_col</name> &gt; (<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>cells</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>ScrnIsLineInSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* if we are in insert-mode, reserve space for the new cells */</comment>
    <if>if <condition>(<expr><name>flags</name> &amp; <name>INSERT</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>InsertChar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>cells</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>AddToVisible</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
	&amp;&amp; ((<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call>)) != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/*
	 * If we overwrite part of a multi-column character, fill the rest
	 * of it with blanks.
	 */</comment>
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, cells, &amp;kl, &amp;kr))
		ClearInLine(xw, screen-&gt;cur_row, kl, (unsigned) (kr - kl + 1));
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<if>if <condition>(<expr><name>flags</name> &amp; <name>INVISIBLE</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>
	    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>cells</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>n</name></expr>]</index></name> = ' '</expr>;</expr_stmt></for>
	}</block></then></if>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("WriteText calling drawXtermText (%d) (%d,%d)\n",
	       <call><name>LineCharSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call>,
	       <name>screen</name>-&gt;<name>cur_col</name>,
	       <name>screen</name>-&gt;<name>cur_row</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>test</name> = <name>flags</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>colorAttrMode</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>fg</name> = <call><name>MapToColorMode</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>cur_foreground</name></expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>fg</name> = <name>xw</name>-&gt;<name>cur_foreground</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>checkVeryBoldColors</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* make sure that the correct GC is current */</comment>
	<expr_stmt><expr><name>currentGC</name> = <call><name>updatedXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>test</name> &amp; <name>DRAWX_MASK</name></expr></argument>, <argument><expr><name>currentGC</name></expr></argument>,
		      <argument><expr><call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>LineCharSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ScrnWriteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CursorForward</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>int</name>) <name>cells</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ZICONBEEP</name></expr></cpp:if>
    <comment type="block">/* Flag icon name with "***"  on window output when iconified.
     */</comment>
    <if>if <condition>(<expr><name>resource</name>.<name>zIconBeep</name> &amp;&amp; <name>mapstate</name> == <name>IsUnmapped</name> &amp;&amp; !<name>screen</name>-&gt;<name>zIconBeep_flagged</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>icon_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static</name> <name>Arg</name></type> <name><name>args</name><index>[]</index></name> =<init>
	<expr><block>{
	    <expr><block>{<expr><name>XtNiconName</name></expr>, <expr>(<name>XtArgVal</name>) &amp; <name>icon_name</name></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>icon_name</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XtGetValues</name><argument_list>(<argument><expr><name>toplevel</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>XtNumber</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>icon_name</name> != <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>zIconBeep_flagged</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ChangeIconName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>icon_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>xtermBell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>mapstate</name> = -1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_ZICONBEEP */</comment>
    <return>return;</return>
}</block></function>

<comment type="block">/*
 * If cursor not in scrolling region, returns.  Else,
 * inserts n blank lines at the cursor's position.  Lines above the
 * bottom margin are lost.
 */</comment>
<function><type><name>void</name></type>
<name>InsertLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshtop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshheight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrolltop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrollheight</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>ScrnIsLineInMargins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("InsertLine count=%d\n", <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>ScrnAreLinesInSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
				   <argument><expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>top_marg</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>ScrnAreLinesInSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
				   <argument><expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>bot_marg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>n</name> &gt; (<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>cur_row</name> + 1)</expr>)</condition><then>
	<expr_stmt><expr><name>n</name> = <name>i</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>jumpscroll</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &lt;= 0 &amp;&amp;
	    <name>screen</name>-&gt;<name>cur_row</name> &lt;= -<name>screen</name>-&gt;<name>refresh_amt</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>-<name>screen</name>-&gt;<name>refresh_amt</name> + <name>n</name> &gt; <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> -= <name>n</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> -= <name>n</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>shift</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bot</name> = <name>screen</name>-&gt;<name>max_row</name> - <name>shift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>refreshheight</name> = <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrollheight</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>cur_row</name> - <name>refreshheight</name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>refreshtop</name> = <name>screen</name>-&gt;<name>cur_row</name> + <name>shift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrolltop</name> = <name>refreshtop</name> + <name>refreshheight</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>bot</name>) &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>scrollheight</name> -= <name>i</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>cur_row</name> + <name>refreshheight</name> - 1 - <name>bot</name>) &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>refreshheight</name> -= <name>i</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>vertical_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>scrolltop</name> - <name>n</name></expr></argument>, <argument><expr><name>scrollheight</name></expr></argument>, <argument><expr>-<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>refreshheight</name> &gt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			       <argument><expr>(<name>int</name>) <name>refreshtop</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
			       <argument><expr>(<name>int</name>) <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>refreshheight</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnInsertLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>visbuf</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>bot_marg</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>,
		       <argument><expr>(<name>unsigned</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * If cursor not in scrolling region, returns.  Else, deletes n lines
 * at the cursor's position, lines added at bottom margin are blank.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshtop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refreshheight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrolltop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrollheight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>scroll_all_lines</name> =<init> <expr><call>(<name>Boolean</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name>
					  &amp;&amp; !<name>screen</name>-&gt;<name>whichBuf</name>
					  &amp;&amp; <name>screen</name>-&gt;<name>cur_row</name> == 0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>ScrnIsLineInMargins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DeleteLine count=%d\n", <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>n</name> &gt; (<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>screen</name>-&gt;<name>cur_row</name> + 1)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>n</name> = <name>i</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>ScrnAreLinesInSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
				   <argument><expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name> + <name>n</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>jumpscroll</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &gt;= 0 &amp;&amp; <name>screen</name>-&gt;<name>cur_row</name> == <name>screen</name>-&gt;<name>top_marg</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>refresh_amt</name> + <name>n</name> &gt; <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scroll_amt</name> += <name>n</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>refresh_amt</name> += <name>n</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if>
    }</block></then></if>

    <comment type="block">/* adjust screen-&gt;buf */</comment>
    <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>scroll_all_lines</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>ScrnDeleteLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>bot_marg</name> + <name>screen</name>-&gt;<name>savelines</name></expr></argument>,
			   <argument><expr>0</expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><call><name>ScrnDeleteLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>visbuf</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>bot_marg</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

    <comment type="block">/* repaint the screen, as needed */</comment>
    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>shift</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bot</name> = <name>screen</name>-&gt;<name>max_row</name> - <name>shift</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scrollheight</name> = <name>i</name> - <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>refreshheight</name> = <name>n</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>refreshtop</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>refreshheight</name> + 1 + <name>shift</name>) &gt;
	    (<name>i</name> = <name>screen</name>-&gt;<name>max_row</name> - <name>refreshheight</name> + 1)</expr>)</condition><then>
	    <expr_stmt><expr><name>refreshtop</name> = <name>i</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>scroll_all_lines</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>scrolltop</name> = 0</expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>scrollheight</name> += <name>shift</name>) &gt; <name>i</name></expr>)</condition><then>
		<expr_stmt><expr><name>scrollheight</name> = <name>i</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>savedlines</name>) &lt; <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>i</name> += <name>n</name>) &gt; <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then>
		    <expr_stmt><expr><name>i</name> = <name>screen</name>-&gt;<name>savelines</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScrollBarDrawThumb</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>scrolltop</name> = <name>screen</name>-&gt;<name>cur_row</name> + <name>shift</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>bot_marg</name> - <name>bot</name>) &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>scrollheight</name> -= <name>i</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>cur_row</name> + <name>n</name> - 1 - <name>bot</name>) &gt;= 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>refreshheight</name> -= <name>i</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>vertical_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>scrolltop</name> + <name>n</name></expr></argument>, <argument><expr><name>scrollheight</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>shift</name> &gt; 0 &amp;&amp; <name>refreshheight</name> &gt; 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>rows</name> =<init> <expr><name>refreshheight</name></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>rows</name> &gt; <name>shift</name></expr>)</condition><then>
		<expr_stmt><expr><name>rows</name> = <name>shift</name></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>ScrnUpdate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>refreshtop</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>refreshtop</name> += <name>shift</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>refreshheight</name> -= <name>shift</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>refreshheight</name> &gt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			       <argument><expr>(<name>int</name>) <name>refreshtop</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
			       <argument><expr>(<name>int</name>) <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>refreshheight</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Insert n blanks at the cursor's position, no wraparound
 */</comment>
<function><type><name>void</name></type>
<name>InsertChar</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("InsertChar count=%d\n", <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>ScrnIsLineInSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_col</name> &lt;= <name>screen</name>-&gt;<name>max_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>n</name> &gt; <name>limit</name></expr>)</condition><then>
	<expr_stmt><expr><name>n</name> = <name>limit</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>AddToVisible</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
	&amp;&amp; (<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - (<name>int</name>) <name>n</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we shift part of a multi-column character, fill the rest
	 * of it with blanks.  Do similar repair for the text which will
	 * be shifted into the right-margin.
	 */</comment>
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    int kl;
	    int kr = screen-&gt;cur_col;
	    if (DamagedCurCells(screen, n, &amp;kl, (int *) 0) &amp;&amp; kr &gt; kl) {
		ClearInLine(xw, screen-&gt;cur_row, kl, (unsigned) (kr - kl + 1));
	    }
	    kr = screen-&gt;max_col - (int) n + 1;
	    if (DamagedCells(screen, n, &amp;kl, (int *) 0,
			     screen-&gt;cur_row,
			     kr) &amp;&amp; kr &gt; kl) {
		ClearInLine(xw, screen-&gt;cur_row, kl, (unsigned) (kr - kl + 1));
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>col</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> / 2 - (<name>int</name>) <name>n</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/*
	 * prevent InsertChar from shifting the end of a line over
	 * if it is being appended to
	 */</comment>
	<if>if <condition>(<expr><call><name>non_blank_line</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>, <argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>horizontal_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>,
				 <argument><expr><name>col</name> - <name>screen</name>-&gt;<name>cur_col</name></expr></argument>,
				 <argument><expr>(<name>int</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>n</name> * (<name>unsigned</name>) <call><name>LineFontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* adjust screen-&gt;buf */</comment>
    <expr_stmt><expr><call><name>ScrnInsertChar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Deletes n chars at the cursor's position, no wraparound.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteChar</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DeleteChar count=%d\n", <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>ScrnIsLineInSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_col</name> &lt;= <name>screen</name>-&gt;<name>max_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>n</name> &gt; <name>limit</name></expr>)</condition><then>
	<expr_stmt><expr><name>n</name> = <name>limit</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>AddToVisible</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
	&amp;&amp; (<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - (<name>int</name>) <name>n</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we delete part of a multi-column character, fill the rest
	 * of it with blanks.
	 */</comment>
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, n, &amp;kl, &amp;kr))
		ClearInLine(xw, screen-&gt;cur_row, kl, (unsigned) (kr - kl + 1));
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>col</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> / 2 - (<name>int</name>) <name>n</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>horizontal_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			     <argument><expr>(<name>screen</name>-&gt;<name>cur_col</name> + (<name>int</name>) <name>n</name>)</expr></argument>,
			     <argument><expr><name>col</name> - <name>screen</name>-&gt;<name>cur_col</name></expr></argument>,
			     <argument><expr>-((<name>int</name>) <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>n</name> * (<name>unsigned</name>) <call><name>LineFontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>n</name> != 0</expr>)</condition><then> <block>{
	<comment type="block">/* adjust screen-&gt;buf */</comment>
	<expr_stmt><expr><call><name>ScrnDeleteChar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Clear from cursor position to beginning of display, inclusive.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ClearAbove</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>protected_mode</name> != <name>OFF_PROTECT</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>max_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>row</name> = 0</expr>;</init> <condition><expr><name>row</name> &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>;</condition> <incr><expr><name>row</name>++</expr></incr>)
	    <expr_stmt><expr><call><name>ClearInLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>top</name>, <name>height</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>top</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>(<name>height</name> = <name>screen</name>-&gt;<name>cur_row</name> + <name>top</name>) &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
		<expr_stmt><expr><name>height</name> = <name>screen</name>-&gt;<name>max_row</name> + 1</expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>(<name>height</name> -= <name>top</name>) &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				   <argument><expr><name>top</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
				   <argument><expr><call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>height</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>ClearBufRows</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>ClearLeft</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Clear from cursor position to end of display, inclusive.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ClearBelow</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ClearRight</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>protected_mode</name> != <name>OFF_PROTECT</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>max_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>row</name> = <name>screen</name>-&gt;<name>cur_row</name> + 1</expr>;</init> <condition><expr><name>row</name> &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>;</condition> <incr><expr><name>row</name>++</expr></incr>)
	    <expr_stmt><expr><call><name>ClearInLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>top</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call>) &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>++<name>top</name> &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				   <argument><expr><name>top</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
				   <argument><expr><call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>screen</name>-&gt;<name>max_row</name> - <name>top</name> + 1)
					       * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>ClearBufRows</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name> + 1</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * Clear the given row, for the given range of columns, returning 1 if no
 * protected characters were found, 0 otherwise.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>ClearInLine2</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ClearInLine(row=%d, col=%d, len=%d) vs %d..%d\n",
	   <name>row</name>, <name>col</name>, <name>len</name>,
	   <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
	   <name>screen</name>-&gt;<name>startH</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>ScrnIsLineInSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>col</name> + (<name>int</name>) <name>len</name> &gt;= <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>len</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If we've marked protected text on the screen, we'll have to
     * check each time we do an erase.
     */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>protected_mode</name> != <name>OFF_PROTECT</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name> *</type><name>attrs</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call>-&gt;<name>attribs</name> + <name>col</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>saved_mode</name> =<init> <expr><name>screen</name>-&gt;<name>protected_mode</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bool</name></type> <name>done</name></decl>;</decl_stmt>

	<comment type="block">/* disable this branch during recursion */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>OFF_PROTECT</name></expr>;</expr_stmt>

	<do>do <block>{
	    <expr_stmt><expr><name>done</name> = <name>True</name></expr>;</expr_stmt>
	    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>attrs</name><index>[<expr><name>n</name></expr>]</index></name> &amp; <name>PROTECTED</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>	<comment type="block">/* found a protected segment */</comment>
		    <if>if <condition>(<expr><name>n</name> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>ClearInLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
		    <while>while <condition>(<expr>(<name>n</name> &lt; <name>len</name>)
			   &amp;&amp; (<name><name>attrs</name><index>[<expr><name>n</name></expr>]</index></name> &amp; <name>PROTECTED</name>)</expr>)</condition> <block>{
			<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
		    }</block></while>
		    <expr_stmt><expr><name>done</name> = <name>False</name></expr>;</expr_stmt>
		    <break>break;</break>
		}</block></then></if>
	    }</block></for>
	    <comment type="block">/* setup for another segment, past the protected text */</comment>
	    <if>if <condition>(<expr>!<name>done</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>attrs</name> += <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>col</name> += (<name>int</name>) <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> -= <name>n</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block> while <condition>(<expr>!<name>done</name></expr>)</condition>;</do>

	<expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>saved_mode</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &lt;= 0</expr>)</condition><then> <block>{
	    <return>return <expr>0</expr>;</return>
	}</block></then></if>
    }</block></then></if>
    <comment type="block">/* fall through to the final non-protected segment */</comment>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>AddToVisible</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
	&amp;&amp; (<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{

	<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>len</name> * (<name>unsigned</name>) <call><name>LineFontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>len</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ClearCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>ClearInLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we're clearing to the end of the line, we won't count this as
     * "drawn" characters.  We'll only do cut/paste on "drawn" characters,
     * so this has the effect of suppressing trailing blanks from a
     * selection.
     */</comment>
    <if>if <condition>(<expr><name>col</name> + (<name>int</name>) <name>len</name> &lt; <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>flags</name> |= <name>CHARDRAWN</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><call><name>ClearInLine2</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Clear the next n characters on the cursor's line, including the cursor's
 * position.
 */</comment>
<function><type><name>void</name></type>
<name>ClearRight</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>max_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>max_col</name> &gt;= <name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>			<comment type="block">/* the remainder of the line */</comment>
	<expr_stmt><expr><name>n</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>			<comment type="block">/* default for 'ECH' */</comment>
	<expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>len</name> &gt; (<name>unsigned</name>) <name>n</name></expr>)</condition><then>
	<expr_stmt><expr><name>len</name> = (<name>unsigned</name>) <name>n</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>AddToVisible</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    int col = screen-&gt;cur_col;
	    int row = screen-&gt;cur_row;
	    int kl;
	    int kr;
	    int xx;
	    if (DamagedCurCells(screen, len, &amp;kl, &amp;kr) &amp;&amp; kr &gt;= kl) {
		xx = col;
		if (kl &lt; xx) {
		    ClearInLine2(xw, 0, row, kl, (unsigned) (xx - kl));
		}
		xx = col + (int) len - 1;
		if (kr &gt; xx) {
		    ClearInLine2(xw, 0, row, xx + 1, (unsigned) (kr - xx));
		}
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr>(<name>void</name>) <call><name>ClearInLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>ScrnClearCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* with the right part cleared, we can't be wrapping */</comment>
    <expr_stmt><expr><call><name>LineClrWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Clear first part of cursor's line, inclusive.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ClearLeft</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr>(<name>unsigned</name>) <name>screen</name>-&gt;<name>cur_col</name> + 1</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>AddToVisible</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    int row = screen-&gt;cur_row;
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, 1, &amp;kl, &amp;kr) &amp;&amp; kr &gt;= kl) {
		ClearInLine2(xw, 0, row, kl, (unsigned) (kr - kl + 1));
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr>(<name>void</name>) <call><name>ClearInLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>ScrnClearCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * Erase the cursor's line.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ClearLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>max_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <call><name>ClearInLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>ClearScreen</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>top</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>ClearCurBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name>top</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
			   <argument><expr><call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>screen</name>-&gt;<name>max_row</name> - <name>top</name> + 1)
				       * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ClearBufRows</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * If we've written protected text DEC-style, and are issuing a non-DEC
 * erase, temporarily reset the protected_mode flag so that the erase will
 * ignore the protected flags.
 */</comment>
<function><type><name>void</name></type>
<name>do_erase_line</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>param</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>saved_mode</name> =<init> <expr><name>screen</name>-&gt;<name>protected_mode</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>saved_mode</name> == <name>DEC_PROTECT</name>
	&amp;&amp; <name>saved_mode</name> != <name>mode</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>OFF_PROTECT</name></expr>;</expr_stmt>
    }</block></then></if>

    <switch>switch <condition>(<expr><name>param</name></expr>)</condition> <block>{
    <case>case <expr>-1</expr>:			<comment type="block">/* DEFAULT */</comment>
    </case><case>case <expr>0</expr>:
	<expr_stmt><expr><call><name>ClearRight</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>1</expr>:
	<expr_stmt><expr><call><name>ClearLeft</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>2</expr>:
	<expr_stmt><expr><call><name>ClearLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>
    <expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>saved_mode</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Just like 'do_erase_line()', except that this intercepts ED controls.  If we
 * clear the whole screen, we'll get the return-value from ClearInLine, and
 * find if there were any protected characters left.  If not, reset the
 * protected mode flag in the screen data (it's slower).
 */</comment>
<function><type><name>void</name></type>
<name>do_erase_display</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>param</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>saved_mode</name> =<init> <expr><name>screen</name>-&gt;<name>protected_mode</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>saved_mode</name> == <name>DEC_PROTECT</name>
	&amp;&amp; <name>saved_mode</name> != <name>mode</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>OFF_PROTECT</name></expr>;</expr_stmt></then></if>

    <switch>switch <condition>(<expr><name>param</name></expr>)</condition> <block>{
    <case>case <expr>-1</expr>:			<comment type="block">/* DEFAULT */</comment>
    </case><case>case <expr>0</expr>:
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cur_row</name> == 0
	    &amp;&amp; <name>screen</name>-&gt;<name>cur_col</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>saved_mode</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>do_erase_display</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>saved_mode</name> = <name>screen</name>-&gt;<name>protected_mode</name></expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><call><name>ClearBelow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<break>break;</break>

    </case><case>case <expr>1</expr>:
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cur_row</name> == <name>screen</name>-&gt;<name>max_row</name>
	    &amp;&amp; <name>screen</name>-&gt;<name>cur_col</name> == <name>screen</name>-&gt;<name>max_col</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>saved_mode</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>do_erase_display</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>saved_mode</name> = <name>screen</name>-&gt;<name>protected_mode</name></expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><call><name>ClearAbove</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<break>break;</break>

    </case><case>case <expr>2</expr>:
	<comment type="block">/*
	 * We use 'ClearScreen()' throughout the remainder of the
	 * program for places where we don't care if the characters are
	 * protected or not.  So we modify the logic around this call
	 * on 'ClearScreen()' to handle protected characters.
	 */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>protected_mode</name> != <name>OFF_PROTECT</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>max_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>row</name> = 0</expr>;</init> <condition><expr><name>row</name> &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>;</condition> <incr><expr><name>row</name>++</expr></incr>)
		<expr_stmt><expr><name>rc</name> &amp;= <call><name>ClearInLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	    <if>if <condition>(<expr><name>rc</name> != 0</expr>)</condition><then>
		<expr_stmt><expr><name>saved_mode</name> = <name>OFF_PROTECT</name></expr>;</expr_stmt></then></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>ClearScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<break>break;</break>

    </case><case>case <expr>3</expr>:
	<comment type="block">/* xterm addition - erase saved lines. */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScrollBarDrawThumb</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>
    <expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>saved_mode</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>CopyWait</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XEvent</name></type> <name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XEvent</name> *</type><name>rep</name> =<init> <expr>&amp;<name>reply</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>1</expr>)</condition> <block>{
	<expr_stmt><expr><call><name>XWindowEvent</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><name>ExposureMask</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>reply</name>.<name>type</name></expr>)</condition> <block>{
	<case>case <expr><name>Expose</name></expr>:
	    <expr_stmt><expr><call><name>HandleExposure</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>NoExpose</name></expr>:
	</case><case>case <expr><name>GraphicsExpose</name></expr>:
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>incopy</name> &lt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>incopy</name> = 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>scrolls</name> &gt; 0</expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>scrolls</name>--</expr>;</expr_stmt></then></if>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>reply</name>.<name>type</name> == <name>GraphicsExpose</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>HandleExposure</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	    <if>if <condition>(<expr>(<name>reply</name>.<name>type</name> == <name>NoExpose</name>) ||
		((<name>XExposeEvent</name> *) <name>rep</name>)-&gt;<name>count</name> == 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>incopy</name> &lt;= 0 &amp;&amp; <name>screen</name>-&gt;<name>scrolls</name> &gt; 0</expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>scrolls</name>--</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>scrolls</name> == 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>screen</name>-&gt;<name>incopy</name> = 0</expr>;</expr_stmt>
		    <return>return;</return>
		}</block></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>incopy</name> = -1</expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
	</case>}</block></switch>
    }</block></while>
}</block></function>

<comment type="block">/*
 * used by vertical_copy_area and and horizontal_copy_area
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>copy_area</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>src_x</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>src_y</name></decl></param>,
	  <param><decl><type><name>unsigned</name></type> <name>width</name></decl></param>,
	  <param><decl><type><name>unsigned</name></type> <name>height</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>dest_x</name></decl></param>,
	  <param><decl><type><name>int</name></type> <name>dest_y</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>width</name> != 0 &amp;&amp; <name>height</name> != 0</expr>)</condition><then> <block>{
	<comment type="block">/* wait for previous CopyArea to complete unless
	   multiscroll is enabled and active */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>incopy</name> &amp;&amp; <name>screen</name>-&gt;<name>scrolls</name> == 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>CopyWait</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>incopy</name> = -1</expr>;</expr_stmt>

	<comment type="block">/* save for translating Expose events */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>copy_src_x</name> = <name>src_x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>copy_src_y</name> = <name>src_y</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>copy_width</name> = <name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>copy_height</name> = <name>height</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>copy_dest_x</name> = <name>dest_x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>copy_dest_y</name> = <name>dest_y</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XCopyArea</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
		  <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr><call><name>NormalGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>dest_x</name></expr></argument>, <argument><expr><name>dest_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * use when inserting or deleting characters on the current line
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>horizontal_copy_area</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		     <param><decl><type><name>int</name></type> <name>firstchar</name></decl></param>,	<comment type="block">/* char pos on screen to start copying at */</comment>
		     <param><decl><type><name>int</name></type> <name>nchars</name></decl></param>,
		     <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>	<comment type="block">/* number of characters to move right */</comment>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>src_x</name> =<init> <expr><call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>src_y</name> =<init> <expr><call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name></expr></argument>,
		  <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>nchars</name> * <call><name>LineFontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr>(<name>unsigned</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr><name>src_x</name> + <name>amount</name> * <call><name>LineFontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>src_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * use when inserting or deleting lines from the screen
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>vertical_copy_area</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>firstline</name></decl></param>,	<comment type="block">/* line on screen to start copying at */</comment>
		   <param><decl><type><name>int</name></type> <name>nlines</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>	<comment type="block">/* number of lines to move up (neg=down) */</comment>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nlines</name> &gt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>src_x</name> =<init> <expr><call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>src_y</name> =<init> <expr><name>firstline</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name></expr></argument>,
		  <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>nlines</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name> - <name>amount</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * use when scrolling the entire screen
 */</comment>
<function><type><name>void</name></type>
<name>scrolling_copy_area</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		    <param><decl><type><name>int</name></type> <name>firstline</name></decl></param>,	<comment type="block">/* line on screen to start copying at */</comment>
		    <param><decl><type><name>int</name></type> <name>nlines</name></decl></param>,
		    <param><decl><type><name>int</name></type> <name>amount</name></decl></param>)</parameter_list>	<comment type="block">/* number of lines to move up (neg=down) */</comment>
<block>{

    <if>if <condition>(<expr><name>nlines</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>vertical_copy_area</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>firstline</name></expr></argument>, <argument><expr><name>nlines</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Handler for Expose events on the VT widget.
 * Returns 1 iff the area where the cursor was got refreshed.
 */</comment>
<function><type><name>int</name></type>
<name>HandleExposure</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XExposeEvent</name> *</type><name>reply</name> =<init> <expr>(<name>XExposeEvent</name> *) <name>event</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <if>if <condition>(<expr><name>reply</name>-&gt;<name>window</name> == <name>screen</name>-&gt;<name>iconVwin</name>.<name>window</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> = &amp;<name>screen</name>-&gt;<name>iconVwin</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleExposure - icon")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> = &amp;<name>screen</name>-&gt;<name>fullVwin</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleExposure - normal")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>(" event %d,%d %dx%d\n",
	   <name>reply</name>-&gt;<name>y</name>,
	   <name>reply</name>-&gt;<name>x</name>,
	   <name>reply</name>-&gt;<name>height</name>,
	   <name>reply</name>-&gt;<name>width</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>

    <comment type="block">/* if not doing CopyArea or if this is a GraphicsExpose, don't translate */</comment>
    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>incopy</name> || <name>event</name>-&gt;<name>type</name> != <name>Expose</name></expr>)</condition><then>
	<return>return <expr><call><name>handle_translated_exposure</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>x</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>y</name></expr></argument>,
					  <argument><expr><name>reply</name>-&gt;<name>width</name></expr></argument>,
					  <argument><expr><name>reply</name>-&gt;<name>height</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else <block>{
	<comment type="block">/* compute intersection of area being copied with
	   area being exposed. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>both_x1</name> =<init> <expr><call><name>Max</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>copy_src_x</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>both_y1</name> =<init> <expr><call><name>Max</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>copy_src_y</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>both_x2</name> =<init> <expr><call><name>Min</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>copy_src_x</name> + (<name>int</name>) <name>screen</name>-&gt;<name>copy_width</name></expr></argument>,
			  <argument><expr>(<name>reply</name>-&gt;<name>x</name> + (<name>int</name>) <name>reply</name>-&gt;<name>width</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>both_y2</name> =<init> <expr><call><name>Min</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>copy_src_y</name> + (<name>int</name>) <name>screen</name>-&gt;<name>copy_height</name></expr></argument>,
			  <argument><expr>(<name>reply</name>-&gt;<name>y</name> + (<name>int</name>) <name>reply</name>-&gt;<name>height</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>value</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/* was anything copied affected? */</comment>
	<if>if <condition>(<expr><name>both_x2</name> &gt; <name>both_x1</name> &amp;&amp; <name>both_y2</name> &gt; <name>both_y1</name></expr>)</condition><then> <block>{
	    <comment type="block">/* do the copied area */</comment>
	    <expr_stmt><expr><name>value</name> = <call><name>handle_translated_exposure</name>
		<argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>x</name> + <name>screen</name>-&gt;<name>copy_dest_x</name> - <name>screen</name>-&gt;<name>copy_src_x</name></expr></argument>,
		 <argument><expr><name>reply</name>-&gt;<name>y</name> + <name>screen</name>-&gt;<name>copy_dest_y</name> - <name>screen</name>-&gt;<name>copy_src_y</name></expr></argument>,
		 <argument><expr><name>reply</name>-&gt;<name>width</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/* was anything not copied affected? */</comment>
	<if>if <condition>(<expr><name>reply</name>-&gt;<name>x</name> &lt; <name>both_x1</name> || <name>reply</name>-&gt;<name>y</name> &lt; <name>both_y1</name>
	    || <name>reply</name>-&gt;<name>x</name> + <name>reply</name>-&gt;<name>width</name> &gt; <name>both_x2</name>
	    || <name>reply</name>-&gt;<name>y</name> + <name>reply</name>-&gt;<name>height</name> &gt; <name>both_y2</name></expr>)</condition><then>
	    <expr_stmt><expr><name>value</name> = <call><name>handle_translated_exposure</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>x</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>y</name></expr></argument>,
					       <argument><expr><name>reply</name>-&gt;<name>width</name></expr></argument>, <argument><expr><name>reply</name>-&gt;<name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<return>return <expr><name>value</name></expr>;</return>
    }</block></else></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>set_background</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name> <name>color</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>c</name> =<init> <expr><call><name>getXtermBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_background(%d) %#lx\n", <name>color</name>, <name>c</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XSetWindowBackground</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XSetWindowBackground</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Called by the ExposeHandler to do the actual repaint after the coordinates
 * have been translated to allow for any CopyArea in progress.
 * The rectangle passed in is pixel coordinates.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>handle_translated_exposure</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
			   <param><decl><type><name>int</name></type> <name>rect_x</name></decl></param>,
			   <param><decl><type><name>int</name></type> <name>rect_y</name></decl></param>,
			   <param><decl><type><name>int</name></type> <name>rect_width</name></decl></param>,
			   <param><decl><type><name>int</name></type> <name>rect_height</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>toprow</name>, <name>leftcol</name>, <name>nrows</name>, <name>ncols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>x0</name>, <name>x1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>y0</name>, <name>y1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("handle_translated_exposure at %d,%d size %dx%d\n",
	   <name>rect_y</name>, <name>rect_x</name>, <name>rect_height</name>, <name>rect_width</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>x0</name> = (<name>rect_x</name> - <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>x1</name> = (<name>x0</name> + <name>rect_width</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name>y0</name> = (<name>rect_y</name> - <call><name>OriginY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>y1</name> = (<name>y0</name> + <name>rect_height</name>)</expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>x0</name> &lt; 0 ||
	 <name>y0</name> &lt; 0 ||
	 <name>x1</name> &gt; <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> ||
	 <name>y1</name> &gt; <call><name>Height</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>set_background</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XClearArea</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>rect_x</name></expr></argument>,
		   <argument><expr><name>rect_y</name></expr></argument>,
		   <argument><expr>(<name>unsigned</name>) <name>rect_width</name></expr></argument>,
		   <argument><expr>(<name>unsigned</name>) <name>rect_height</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>toprow</name> = <name>y0</name> / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>toprow</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>toprow</name> = 0</expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>leftcol</name> = <name>x0</name> / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>leftcol</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>leftcol</name> = 0</expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>nrows</name> = (<name>y1</name> - 1) / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>toprow</name> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>ncols</name> = (<name>x1</name> - 1) / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>leftcol</name> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>toprow</name> -= <name>screen</name>-&gt;<name>scrolls</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>toprow</name> &lt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>nrows</name> += <name>toprow</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toprow</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>toprow</name> + <name>nrows</name> &gt; <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>nrows</name> = <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>toprow</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>leftcol</name> + <name>ncols</name> &gt; <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>ncols</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>leftcol</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>nrows</name> &gt; 0 &amp;&amp; <name>ncols</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>toprow</name></expr></argument>, <argument><expr><name>leftcol</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>first_map_occurred</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cur_row</name> &gt;= <name>toprow</name> &amp;&amp;
	    <name>screen</name>-&gt;<name>cur_row</name> &lt; <name>toprow</name> + <name>nrows</name> &amp;&amp;
	    <name>screen</name>-&gt;<name>cur_col</name> &gt;= <name>leftcol</name> &amp;&amp;
	    <name>screen</name>-&gt;<name>cur_col</name> &lt; <name>leftcol</name> + <name>ncols</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
	}</block></then></if>

    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...handle_translated_exposure %d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>result</name>)</expr>;</return>
}</block></function>

<comment type="block">/***====================================================================***/</comment>

<function><type><name>void</name></type>
<name>GetColors</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ScrnColors</name> *</type> <name>pColors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pColors</name>-&gt;<name>which</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>NCOLORS</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<expr_stmt><expr><call><name>SET_COLOR_VALUE</name><argument_list>(<argument><expr><name>pColors</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><name>void</name></type>
<name>ChangeColors</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ScrnColors</name> *</type> <name>pNew</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>repaint</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTwin</name> *</type><name>win</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ChangeColors\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> = <call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... TEXT_CURSOR: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* no repaint needed */</comment>
    }</block></then> <else>else <if>if <condition>(<expr>(<call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> == <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call>) &amp;&amp;
	       (<call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> = <call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... TEXT_CURSOR: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>repaint</name> = <name>screen</name>-&gt;<name>Vshow</name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Pixel</name></type> <name>fg</name> =<init> <expr><call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call> = <name>fg</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... TEXT_FG: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>Vshow</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcBold</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcBoldReverse</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>repaint</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Pixel</name></type> <name>bg</name> =<init> <expr><call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call> = <name>bg</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... TEXT_BG: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>Vshow</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcBold</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcBoldReverse</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_background</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>repaint</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call> = <call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... HIGHLIGHT_BG: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>repaint</name> = <name>screen</name>-&gt;<name>Vshow</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call> = <call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... HIGHLIGHT_FG: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>repaint</name> = <name>screen</name>-&gt;<name>Vshow</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call> || (<call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call> = <call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... MOUSE_FG: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call> = <call><name>COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... MOUSE_BG: %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>Vshow</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>recolor_cursor</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>pointer_cursor</name></expr></argument>,
			   <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XDefineCursor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name>screen</name>-&gt;<name>pointer_cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>TekScreen</name> *</type><name>tekscr</name> =<init> <expr><call><name>TekScreenOf</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Window</name></type> <name>tekwin</name> =<init> <expr><call><name>TWindow</name><argument_list>(<argument><expr><name>tekscr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>tekwin</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>recolor_cursor</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
			       <argument><expr><name>tekscr</name>-&gt;<name>arrow</name></expr></argument>,
			       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XDefineCursor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>tekwin</name></expr></argument>, <argument><expr><name>tekscr</name>-&gt;<name>arrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* no repaint needed */</comment>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call> ||
	<call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call> ||
	<call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>set_cursor_gcs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEK_FG</name></expr></argument>)</argument_list></call> ||
	<call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEK_BG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ChangeTekColors</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TekRepaint</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TEK_CURSOR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ChangeTekColors</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>repaint</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>xtermRepaint</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>xtermClear</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermClear\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XClearWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>xtermRepaint</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermRepaint\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>xtermClear</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/***====================================================================***/</comment>

<function><type><name>Boolean</name></type>
<name>isDefaultForeground</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<name>Boolean</name>) ! <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>Boolean</name></type>
<name>isDefaultBackground</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<name>Boolean</name>) ! <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>XtDefaultBackground</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
 * Check for Unicode BIDI control characters, which may be miscategorized via
 * wcwidth() and iswprint() as zero-width printable characters.
 */</comment>
<function><type><name>Boolean</name></type>
<name>isWideControl</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>ch</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Boolean</name></type> <name>result</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{
    <case>case <expr>0x200E</expr>:
    </case><case>case <expr>0x200F</expr>:
    </case><case>case <expr>0x202A</expr>:
    </case><case>case <expr>0x202B</expr>:
    </case><case>case <expr>0x202C</expr>:
    </case><case>case <expr>0x202D</expr>:
    </case><case>case <expr>0x202E</expr>:
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><default>default:
	<expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
	<break>break;</break>
    </default>}</block></switch>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/***====================================================================***/</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg</name></decl>;</decl_stmt>
}</block></struct></type> <name>ToSwap</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>hc_param</name> ,Bool hilite_color</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>hc_value</name> ,screen-&gt;hilite_color</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>hc_param</name></cpp:define>		<comment type="block">/* nothing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>hc_value</name></cpp:define>		<comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Use this to swap the foreground/background color values in the resource
 * data, and to build up a list of the pairs which must be swapped in the
 * GC cache.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>swapLocally</name><parameter_list>(<param><decl><type><name>ToSwap</name> *</type> <name>list</name></decl></param>, <param><decl><type><name>int</name> *</type><name>count</name></decl></param>, <param><decl><type><name>ColorRes</name> *</type> <name>fg</name></decl></param>, <param><decl><type><name>ColorRes</name> * <name>bg</name></type> <name>hc_param</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ColorRes</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>found</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg_color</name> =<init> <expr><name>fg</name>-&gt;<name>value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg_color</name> =<init> <expr><name>bg</name>-&gt;<name>value</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg_color</name> =<init> <expr>*<name>fg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg_color</name> =<init> <expr>*<name>bg</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <if>if <condition>(<expr>(<name>fg_color</name> != <name>bg_color</name>) || !<name>hilite_color</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr>*<name>fg</name></expr></argument>, <argument><expr>*<name>bg</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; *<name>count</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	    <if>if <condition>(<expr>(<name><name>list</name><index>[<expr><name>n</name></expr>]</index></name>.<name>fg</name> == <name>fg_color</name> &amp;&amp; <name><name>list</name><index>[<expr><name>n</name></expr>]</index></name>.<name>bg</name> == <name>bg_color</name>)
		|| (<name><name>list</name><index>[<expr><name>n</name></expr>]</index></name>.<name>fg</name> == <name>bg_color</name> &amp;&amp; <name><name>list</name><index>[<expr><name>n</name></expr>]</index></name>.<name>bg</name> == <name>fg_color</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>found</name> = <name>True</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block></for>
	<if>if <condition>(<expr>!<name>found</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name><name>list</name><index>[<expr>*<name>count</name></expr>]</index></name>.<name>fg</name> = <name>fg_color</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>list</name><index>[<expr>*<name>count</name></expr>]</index></name>.<name>bg</name> = <name>bg_color</name></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>count</name> = *<name>count</name> + 1</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("swapLocally fg %#lx, bg %#lx -&gt;%d\n",
		   <name>fg_color</name>, <name>bg_color</name>, *<name>count</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>reallySwapColors</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ToSwap</name> *</type> <name>list</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("reallySwapColors\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
	<macro><name>for_each_text_gc</name><argument_list>(<argument>k</argument>)</argument_list></macro> <block>{
	    <expr_stmt><expr><call><name>redoCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>list</name><index>[<expr><name>j</name></expr>]</index></name>.<name>fg</name></expr></argument>, <argument><expr><name><name>list</name><index>[<expr><name>j</name></expr>]</index></name>.<name>bg</name></expr></argument>, <argument><expr>(<name>CgsEnum</name>) <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>
    }</block></for>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>swapVTwinGCs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>VTwin</name> *</type> <name>win</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>swapCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>swapCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcBold</name></expr></argument>, <argument><expr><name>gcBoldReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>ReverseVideo</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ToSwap</name></type> <name><name>listToSwap</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numToSwap</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ReverseVideo\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Swap SGR foreground and background colors.  By convention, these are
     * the colors assigned to "black" (SGR #0) and "white" (SGR #7).  Also,
     * SGR #8 and SGR #15 are the bold (or bright) versions of SGR #0 and
     * #7, respectively.
     *
     * We don't swap colors that happen to match the screen's foreground
     * and background because that tends to produce bizarre effects.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>swapAnyColor</name>(name,a,b) swapLocally(listToSwap, &amp;numToSwap, &amp;(screen-&gt;name[a]), &amp;(screen-&gt;name[b]) hc_value)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>swapAColor</name>(a,b) swapAnyColor(Acolors, a, b)</cpp:define>
    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	swapAColor(0, 7);
	swapAColor(8, 15);
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> == <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> = <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>swapTColor</name>(a,b) swapAnyColor(Tcolors, a, b)</cpp:define>
    <expr_stmt><expr><call><name>swapTColor</name><argument_list>(<argument><expr><name>TEXT_FG</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>swapTColor</name><argument_list>(<argument><expr><name>MOUSE_FG</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>reallySwapColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>listToSwap</name></expr></argument>, <argument><expr><name>numToSwap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>swapVTwinGCs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>fullVwin</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <expr_stmt><expr><call><name>swapVTwinGCs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>iconVwin</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>

    <expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>re_verse</name> = (<name>Boolean</name>) ! <name>xw</name>-&gt;<name>misc</name>.<name>re_verse</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>XtIsRealized</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>xtermDisplayCursor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TekScreen</name> *</type><name>tekscr</name> =<init> <expr><call><name>TekScreenOf</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Window</name></type> <name>tekwin</name> =<init> <expr><call><name>TWindow</name><argument_list>(<argument><expr><name>tekscr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>recolor_cursor</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
		       <argument><expr><name>tekscr</name>-&gt;<name>arrow</name></expr></argument>,
		       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XDefineCursor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>tekwin</name></expr></argument>, <argument><expr><name>tekscr</name>-&gt;<name>arrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scrollWidget</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>ScrollBarReverseVideo</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name>XtIsRealized</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>set_background</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TekReverseVideo</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><call><name>XtIsRealized</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>xtermRepaint</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TekRepaint</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ReverseOldColors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_cursor_gcs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_reversevideo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...ReverseVideo\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>recolor_cursor</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
	       <param><decl><type><name>Cursor</name></type> <name>cursor</name></decl></param>,	<comment type="block">/* X cursor ID to set */</comment>
	       <param><decl><type><name>unsigned</name> <name>long</name></type> <name>fg</name></decl></param>,	<comment type="block">/* pixel indexes to look up */</comment>
	       <param><decl><type><name>unsigned</name> <name>long</name></type> <name>bg</name></decl></param>)</parameter_list>	<comment type="block">/* pixel indexes to look up */</comment>
<block>{
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><name>screen</name>-&gt;<name>display</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XColor</name></type> <name><name>colordefs</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* 0 is foreground, 1 is background */</comment>

    <expr_stmt><expr><name><name>colordefs</name><index>[<expr>0</expr>]</index></name>.<name>pixel</name> = <name>fg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>colordefs</name><index>[<expr>1</expr>]</index></name>.<name>pixel</name> = <name>bg</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XQueryColors</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><call><name>DefaultColormap</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><call><name>DefaultScreen</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><name>colordefs</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XRecolorCursor</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>colordefs</name></expr></argument>, <argument><expr><name>colordefs</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
<function><type><name>static</name> <name>XftColor</name> *</type>
<name>getXftColor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>Pixel</name></type> <name>pixel</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CACHE_SIZE</name>  4</cpp:define>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	<decl_stmt><decl><type><name>XftColor</name></type> <name>color</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>use</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>cache</name><index>[<expr><name>CACHE_SIZE</name></expr>]</index></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>use</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>oldest</name>, <name>oldestuse</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XColor</name></type> <name>color</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldestuse</name> = 0x7fffffff</expr>;</expr_stmt>
    <expr_stmt><expr><name>oldest</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>CACHE_SIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>use</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name>.<name>pixel</name> == <name>pixel</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>use</name> = ++<name>use</name></expr>;</expr_stmt>
		<return>return <expr>&amp;<name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name></expr>;</return>
	    }</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>use</name> &lt; <name>oldestuse</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>oldestuse</name> = <name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>use</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>oldest</name> = <name>i</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>i</name> = <name>oldest</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>color</name>.<name>pixel</name> = <name>pixel</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XQueryColor</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>core</name>.<name>colormap</name></expr></argument>, <argument><expr>&amp;<name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name>.<name>color</name>.<name>red</name> = <name>color</name>.<name>red</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name>.<name>color</name>.<name>green</name> = <name>color</name>.<name>green</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name>.<name>color</name>.<name>blue</name> = <name>color</name>.<name>blue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name>.<name>color</name>.<name>alpha</name> = 0xffff</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name>.<name>pixel</name> = <name>pixel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>use</name> = ++<name>use</name></expr>;</expr_stmt>
    <return>return <expr>&amp;<name><name>cache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>color</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * The cell-width is related to, but not the same as the wide-character width.
 * We will only get useful values from wcwidth() for codes above 255.
 * Otherwise, interpret according to internal data.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERWIDE</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_C1_PRINT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>XtermCellWidth</name>(xw, ch) \
	(((ch) == 0 || (ch) == 127) \
	  ? 0 \
	  : (((ch) &lt; 256) \
	      ? (((ch) &gt;= 128 &amp;&amp; (ch) &lt; 160) \
	          ? (TScreenOf(xw)-&gt;c1_printable ? 1 : 0) \
	          : 1) \
	      : my_wcwidth(ch)))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>XtermCellWidth</name>(xw, ch) \
	(((ch) == 0 || (ch) == 127) \
	  ? 0 \
	  : (((ch) &lt; 256) \
	      ? 1 \
	      : my_wcwidth(ch)))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_RENDERWIDE */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>XFT_FONT</name>(name) screen-&gt;name.font</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>UseBoldFont</name>(screen) (!(screen)-&gt;colorBDMode || ((screen)-&gt;veryBoldColors &amp; BOLD))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>UseBoldFont</name>(screen) 1</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * fontconfig/Xft combination prior to 2.2 has a problem with
 * CJK truetype 'double-width' (bi-width/monospace) fonts leading
 * to the 's p a c e d o u t' rendering. Consequently, we can't
 * rely on XftDrawString8/16  when one of  those fonts is used.
 * Instead, we need to roll out our own using XftDrawCharSpec.
 * A patch in the same spirit (but in a rather different form)
 * was applied to gnome vte and gtk2 port of vim.
 * See http://bugzilla.mozilla.org/show_bug.cgi?id=196312
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>xtermXftDrawString</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		   <param><decl><type><name>unsigned</name> <name>flags</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>XftColor</name> *</type> <name>color</name></decl></param>,
		   <param><decl><type><name>XftFont</name> *</type> <name>font</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>x</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>y</name></decl></param>,
		   <param><decl><type><name>IChar</name> *</type> <name>text</name></decl></param>,
		   <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>,
		   <param><decl><type><name>Bool</name></type> <name>really</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ncells</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERWIDE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>XftCharSpec</name> *</type><name>sbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XftFont</name> *</type><name>wfont</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cardinal</name></type> <name>src</name>, <name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XftFont</name> *</type><name>lastFont</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XftFont</name> *</type><name>currFont</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cardinal</name></type> <name>start</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>charWidth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fontnum</name> =<init> <expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fwidth</name> =<init> <expr><call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>UNDERLINE</name>)
	    &amp;&amp; !<name>screen</name>-&gt;<name>colorULMode</name>
	    &amp;&amp; <name>screen</name>-&gt;<name>italicULMode</name>
	    &amp;&amp; <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderWideItal</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>wfont</name> = <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderWideItal</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr>(<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)
		&amp;&amp; <call><name>UseBoldFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderWideBold</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>wfont</name> = <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderWideBold</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>wfont</name> = <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderWideNorm</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>

	<expr_stmt><expr><call><name>BumpTypedBuffer</name><argument_list>(<argument><expr><name>XftCharSpec</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sbuf</name> = <call><name>BfBuf</name><argument_list>(<argument><expr><name>XftCharSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>src</name> = <name>dst</name> = 0</expr>;</init> <condition><expr><name>src</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>src</name>++</expr></incr>) <block>{
	    <decl_stmt><decl><type><name>FcChar32</name></type> <name>wc</name> =<init> <expr>*<name>text</name>++</expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><name>charWidth</name> = <call><name>XtermCellWidth</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>wchar_t</name>) <name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>charWidth</name> &lt; 0</expr>)</condition><then>
		<continue>continue;</continue></then></if>

	    <expr_stmt><expr><name><name>sbuf</name><index>[<expr><name>dst</name></expr>]</index></name>.<name>ucs4</name> = <name>wc</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>sbuf</name><index>[<expr><name>dst</name></expr>]</index></name>.<name>x</name> = <call>(<name>short</name>) <argument_list>(<argument><expr><name>x</name> + <name>fwidth</name> * <name>ncells</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>sbuf</name><index>[<expr><name>dst</name></expr>]</index></name>.<name>y</name> = <call>(<name>short</name>) <argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><name>currFont</name> = (<name>charWidth</name> == 2 &amp;&amp; <name>wfont</name> != 0) ? <name>wfont</name> : <name>font</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>ncells</name> += <name>charWidth</name></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name>lastFont</name> != <name>currFont</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>lastFont</name> != 0) &amp;&amp; <name>really</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>XftDrawCharSpec</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>renderDraw</name></expr></argument>,
				    <argument><expr><name>color</name></expr></argument>,
				    <argument><expr><name>lastFont</name></expr></argument>,
				    <argument><expr><name>sbuf</name> + <name>start</name></expr></argument>,
				    <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>dst</name> - <name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>start</name> = <name>dst</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastFont</name> = <name>currFont</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr>++<name>dst</name></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr>(<name>dst</name> != <name>start</name>) &amp;&amp; <name>really</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XftDrawCharSpec</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>renderDraw</name></expr></argument>,
			    <argument><expr><name>color</name></expr></argument>,
			    <argument><expr><name>lastFont</name></expr></argument>,
			    <argument><expr><name>sbuf</name> + <name>start</name></expr></argument>,
			    <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>dst</name> - <name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !OPT_RENDERWIDE */</comment>
	<if>if <condition>(<expr><name>really</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>XftChar8</name> *</type><name>buffer</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>dst</name></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>BumpTypedBuffer</name><argument_list>(<argument><expr><name>XftChar8</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>buffer</name> = <call><name>BfBuf</name><argument_list>(<argument><expr><name>XftChar8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <for>for (<init><expr><name>dst</name> = 0</expr>;</init> <condition><expr><name>dst</name> &lt; (<name>int</name>) <name>len</name></expr>;</condition> <incr><expr>++<name>dst</name></expr></incr>)
		<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>dst</name></expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>dst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

	    <expr_stmt><expr><call><name>XftDrawString8</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>renderDraw</name></expr></argument>,
			   <argument><expr><name>color</name></expr></argument>,
			   <argument><expr><name>font</name></expr></argument>,
			   <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>(<name>int</name>) <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>ncells</name> = (<name>int</name>) <name>len</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return <expr><name>ncells</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>xtermXftWidth</name>(xw, flags, color, font, x, y, chars, len) \
   xtermXftDrawString(xw, flags, color, font, x, y, chars, len, False)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_RENDERFONT */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
 * Map characters commonly "fixed" by groff back to their ASCII equivalents.
 * Also map other useful equivalents.
 */</comment>
<function><type><name>unsigned</name></type>
<name>AsciiEquivs</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>ch</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{
    <case>case <expr>0x2010</expr>:		<comment type="block">/* groff "-" */</comment>
    </case><case>case <expr>0x2011</expr>:
    </case><case>case <expr>0x2012</expr>:
    </case><case>case <expr>0x2013</expr>:
    </case><case>case <expr>0x2014</expr>:
    </case><case>case <expr>0x2015</expr>:
    </case><case>case <expr>0x2212</expr>:		<comment type="block">/* groff "\-" */</comment>
	<expr_stmt><expr><name>ch</name> = '-'</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>0x2018</expr>:		<comment type="block">/* groff "`" */</comment>
	<expr_stmt><expr><name>ch</name> = '`'</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>0x2019</expr>:		<comment type="block">/* groff ' */</comment>
	<expr_stmt><expr><name>ch</name> = '\''</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>0x201C</expr>:		<comment type="block">/* groff lq */</comment>
    </case><case>case <expr>0x201D</expr>:		<comment type="block">/* groff rq */</comment>
	<expr_stmt><expr><name>ch</name> = '"'</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>0x2329</expr>:		<comment type="block">/* groff ".URL" */</comment>
	<expr_stmt><expr><name>ch</name> = '&lt;'</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>0x232a</expr>:		<comment type="block">/* groff ".URL" */</comment>
	<expr_stmt><expr><name>ch</name> = '&gt;'</expr>;</expr_stmt>
	<break>break;</break>
    </case><default>default:
	<if>if <condition>(<expr><name>ch</name> &gt;= 0xff01 &amp;&amp; <name>ch</name> &lt;= 0xff5e</expr>)</condition><then> <block>{
	    <comment type="block">/* "Fullwidth" codes (actually double-width) */</comment>
	    <expr_stmt><expr><name>ch</name> -= 0xff00</expr>;</expr_stmt>
	    <expr_stmt><expr><name>ch</name> += <name>ANSI_SPA</name></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
    </default>}</block></switch>
    <return>return <expr><name>ch</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Actually this should be called "groff_workaround()" - for the places where
 * groff stomps on compatibility.  Still, if enough people get used to it,
 * this might someday become a quasi-standard.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>ucs_workaround</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	       <param><decl><type><name>unsigned</name></type> <name>ch</name></decl></param>,
	       <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,
	       <param><decl><type><name>GC</name></type> <name>gc</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>x</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>y</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>chrset</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>on_wide</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fixed</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name> &amp;&amp; <name>screen</name>-&gt;<name>utf8_mode</name> &amp;&amp; <name>ch</name> &gt; 256</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>IChar</name></type> <name>eqv</name> =<init> <expr>(<name>IChar</name>) <call><name>AsciiEquivs</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>eqv</name> != (<name>IChar</name>) <name>ch</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>width</name> =<init> <expr><call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>int</name>) <name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <do>do <block>{
		<expr_stmt><expr><call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			      <argument><expr><name>flags</name></expr></argument>,
			      <argument><expr><name>gc</name></expr></argument>,
			      <argument><expr><name>x</name></expr></argument>,
			      <argument><expr><name>y</name></expr></argument>,
			      <argument><expr><name>chrset</name></expr></argument>,
			      <argument><expr>&amp;<name>eqv</name></expr></argument>,
			      <argument><expr>1</expr></argument>,
			      <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> += <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>eqv</name> = '?'</expr>;</expr_stmt>
	    }</block> while <condition>(<expr><name>width</name>-- &gt; 1</expr>)</condition>;</do>

	    <expr_stmt><expr><name>fixed</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>fixed</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if></else></if>
    }</block></then></if>
    <return>return <expr><name>fixed</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Use this when the characters will not fill the cell area properly.  Fill the
 * area where we'll write the characters, otherwise we'll get gaps between
 * them, e.g., in the original background color.
 *
 * The cursor is a special case, because the XFillRectangle call only uses the
 * foreground, while we've set the cursor color in the background.  So we need
 * a special GC for that.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>xtermFillCells</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	       <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,
	       <param><decl><type><name>GC</name></type> <name>gc</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>x</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>y</name></decl></param>,
	       <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTwin</name> *</type><name>currentWin</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!(<name>flags</name> &amp; <name>NOBACKGROUND</name>)</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>CgsEnum</name></type> <name>srcId</name> =<init> <expr><call><name>getCgsId</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CgsEnum</name></type> <name>dstId</name> =<init> <expr><name>gcMAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pixel</name></type> <name>fg</name> =<init> <expr><call><name>getCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pixel</name></type> <name>bg</name> =<init> <expr><call><name>getCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>srcId</name></expr>)</condition> <block>{
	<case>case <expr><name>gcVTcursNormal</name></expr>:
	</case><case>case <expr><name>gcVTcursReverse</name></expr>:
	    <expr_stmt><expr><name>dstId</name> = <name>gcVTcursOutline</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>gcVTcursFilled</name></expr>:
	</case><case>case <expr><name>gcVTcursOutline</name></expr>:
	    <comment type="block">/* FIXME */</comment>
	    <break>break;</break>
	</case><case>case <expr><name>gcNorm</name></expr>:
	    <expr_stmt><expr><name>dstId</name> = <name>gcNormReverse</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>gcNormReverse</name></expr>:
	    <expr_stmt><expr><name>dstId</name> = <name>gcNorm</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>gcBold</name></expr>:
	    <expr_stmt><expr><name>dstId</name> = <name>gcBoldReverse</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>gcBoldReverse</name></expr>:
	    <expr_stmt><expr><name>dstId</name> = <name>gcBold</name></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BOX_CHARS</name></expr></cpp:if>
	</case><case>case <expr><name>gcLine</name></expr>:
	</case><case>case <expr><name>gcDots</name></expr>:
	    <comment type="block">/* FIXME */</comment>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	</case><case>case <expr><name>gcCNorm</name></expr>:
	</case><case>case <expr><name>gcCBold</name></expr>:
	    <comment type="block">/* FIXME */</comment>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	</case><case>case <expr><name>gcWide</name></expr>:
	    <expr_stmt><expr><name>dstId</name> = <name>gcWideReverse</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>gcWBold</name></expr>:
	    <expr_stmt><expr><name>dstId</name> = <name>gcBoldReverse</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>gcWideReverse</name></expr>:
	</case><case>case <expr><name>gcWBoldReverse</name></expr>:
	    <comment type="block">/* FIXME */</comment>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	</case><case>case <expr><name>gcTKcurs</name></expr>:
	    <comment type="block">/* FIXME */</comment>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr><name>gcMAX</name></expr>:
	    <break>break;</break>
	</case>}</block></switch>

	<if>if <condition>(<expr><name>dstId</name> != <name>gcMAX</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>dstId</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>dstId</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>XFillRectangle</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>dstId</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
			   <argument><expr><name>len</name> * (<name>Cardinal</name>) <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>(<name>unsigned</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>xtermSetClipRectangles</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>dpy</name></decl></param>,
		       <param><decl><type><name>GC</name></type> <name>gc</name></decl></param>,
		       <param><decl><type><name>int</name></type> <name>x</name></decl></param>,
		       <param><decl><type><name>int</name></type> <name>y</name></decl></param>,
		       <param><decl><type><name>XRectangle</name> *</type> <name>rp</name></decl></param>,
		       <param><decl><type><name>Cardinal</name></type> <name>nr</name></decl></param>,
		       <param><decl><type><name>int</name></type> <name>order</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
    TScreen *screen = TScreenOf(term);
    Drawable draw = VWindow(screen);

    XSetClipMask(dpy, gc, None);
    XDrawRectangle(screen-&gt;display, draw, gc,
		   x + rp-&gt;x - 1,
		   y + rp-&gt;y - 1,
		   rp-&gt;width,
		   rp-&gt;height);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>XSetClipRectangles</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
		       <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr>(<name>int</name>) <name>nr</name></expr></argument>, <argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("clipping @(%3d,%3d) (%3d,%3d)..(%3d,%3d)\n",
	   <name>y</name>, <name>x</name>,
	   <name>rp</name>-&gt;<name>y</name>, <name>rp</name>-&gt;<name>x</name>, <name>rp</name>-&gt;<name>height</name>, <name>rp</name>-&gt;<name>width</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>xtermSetClipRectangles</name>(dpy, gc, x, y, rp, nr, order) \
	    XSetClipRectangles(dpy, gc, x, y, rp, (int) nr, order)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_CLIP_BOLD</name></expr></cpp:if>
<comment type="block">/*
 * This special case is a couple of percent slower, but avoids a lot of pixel
 * trash in rxcurses' hanoi.cmd demo (e.g., 10x20 font).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>beginClipping</name>(screen,gc,pwidth,plength) \
	    if (screen-&gt;use_clipping &amp;&amp; (pwidth &gt; 2)) { \
		XRectangle clip; \
		int clip_x = x; \
		int clip_y = y - FontHeight(screen) + FontDescent(screen); \
		clip.x = 0; \
		clip.y = 0; \
		clip.height = (unsigned short) FontHeight(screen); \
		clip.width = (unsigned short) (pwidth * plength); \
		xtermSetClipRectangles(screen-&gt;display, gc, \
				       clip_x, clip_y, \
				       &amp;clip, 1, Unsorted); \
	    }</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>endClipping</name>(screen,gc) \
	    XSetClipMask(screen-&gt;display, gc, None)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>beginClipping</name>(screen,gc,pwidth,plength)</cpp:define>		<comment type="block">/* nothing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>endClipping</name>(screen,gc)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_CLIP_BOLD */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_CLIP_BOLD</name> &amp;&amp; <name>OPT_RENDERFONT</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_XFTDRAWSETCLIP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_XFTDRAWSETCLIPRECTANGLES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>beginXftClipping</name>(screen,px,py,plength) \
	    if (screen-&gt;use_clipping &amp;&amp; (FontWidth(screen) &gt; 2)) { \
		XRectangle clip; \
		int clip_x = px; \
		int clip_y = py - FontHeight(screen) + FontDescent(screen); \
		clip.x = 0; \
		clip.y = 0; \
		clip.height = (unsigned short) (FontHeight(screen)); \
		clip.width = (unsigned short) (FontWidth(screen) * plength); \
		XftDrawSetClipRectangles (screen-&gt;renderDraw, \
					  clip_x, clip_y, \
					  &amp;clip, 1); \
	    }</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>endXftClipping</name>(screen) \
	    XftDrawSetClip (screen-&gt;renderDraw, 0)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>beginXftClipping</name>(screen,px,py,plength)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>endXftClipping</name>(screen)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_CLIP_BOLD */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
<function><type><name>static</name> <name>int</name></type>
<name>drawClippedXftString</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		     <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,
		     <param><decl><type><name>XftFont</name> *</type> <name>font</name></decl></param>,
		     <param><decl><type><name>XftColor</name> *</type> <name>fg_color</name></decl></param>,
		     <param><decl><type><name>int</name></type> <name>x</name></decl></param>,
		     <param><decl><type><name>int</name></type> <name>y</name></decl></param>,
		     <param><decl><type><name>IChar</name> *</type> <name>text</name></decl></param>,
		     <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ncells</name> =<init> <expr><call><name>xtermXftWidth</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
			       <argument><expr><name>fg_color</name></expr></argument>,
			       <argument><expr><name>font</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
			       <argument><expr><name>text</name></expr></argument>,
			       <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>beginXftClipping</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>ncells</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>xtermXftDrawString</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
		       <argument><expr><name>fg_color</name></expr></argument>,
		       <argument><expr><name>font</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
		       <argument><expr><name>text</name></expr></argument>,
		       <argument><expr><name>len</name></expr></argument>,
		       <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>endXftClipping</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ncells</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WhichVFontData</name>(screen,name) \
		(IsIcon(screen) ? &amp;((screen)-&gt;fnt_icon) \
				: &amp;((screen)-&gt;name))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WhichVFontData</name>(screen,name) \
				(&amp;((screen)-&gt;name))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Draws text with the specified combination of bold/underline.  The return
 * value is the updated x position.
 */</comment>
<function><type><name>int</name></type>
<name>drawXtermText</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	      <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,
	      <param><decl><type><name>GC</name></type> <name>gc</name></decl></param>,
	      <param><decl><type><name>int</name></type> <name>x</name></decl></param>,
	      <param><decl><type><name>int</name></type> <name>y</name></decl></param>,
	      <param><decl><type><name>int</name></type> <name>chrset</name></decl></param>,
	      <param><decl><type><name>IChar</name> *</type> <name>text</name></decl></param>,
	      <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>,
	      <param><decl><type><name>int</name></type> <name>on_wide</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>real_length</name> =<init> <expr><name>len</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>underline_len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <comment type="block">/* Intended width of the font to draw (as opposed to the actual width of
       the X font, and the width of the default font) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>font_width</name> =<init> <expr>((<name>flags</name> &amp; <name>DOUBLEWFONT</name>) ? 2 : 1) * <name>screen</name>-&gt;<name>fnt_wide</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>did_ul</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>text</name> == 0</expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><name>chrset</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* We could try drawing double-size characters in the icon, but
	 * given that the icon font is usually nil or nil2, there
	 * doesn't seem to be much point.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>inx</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GC</name></type> <name>gc2</name> =<init> <expr>((!<call><name>IsIcon</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> &amp;&amp; <name>screen</name>-&gt;<name>font_doublesize</name>)
		  ? <call><name>xterm_DoubleGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>chrset</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr>&amp;<name>inx</name></expr></argument>)</argument_list></call>
		  : 0)</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DRAWTEXT%c[%4d,%4d] (%d)%3d:%s\n",
	       <name>screen</name>-&gt;<name>cursor_state</name> == <name>OFF</name> ? ' ' : '*',
	       <name>y</name>, <name>x</name>, <name>chrset</name>, <name>len</name>,
	       <call><name>visibleIChars</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>gc2</name> != 0</expr>)</condition><then> <block>{		<comment type="block">/* draw actual double-sized characters */</comment>
	    <decl_stmt><decl><type><name>XFontStruct</name> *</type><name>fs</name> =<init> <expr><name>screen</name>-&gt;<name><name>double_fonts</name><index>[<expr><name>inx</name></expr>]</index></name>.<name>fs</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
	    <if>if <condition>(<expr>!<call><name>UsingRenderFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <block>{
		<decl_stmt><decl><type><name>XRectangle</name></type> <name>rect</name>, *<name>rp</name> =<init> <expr>&amp;<name>rect</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cardinal</name></type> <name>nr</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>font_width</name> *= 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> |= <name>DOUBLEWFONT</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rect</name>.<name>x</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rect</name>.<name>y</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rect</name>.<name>width</name> = (<name>unsigned</name> <name>short</name>) ((<name>int</name>) <name>len</name> * <name>font_width</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>rect</name>.<name>height</name> = (<name>unsigned</name> <name>short</name>) (<call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("drawing %s\n", <call><name>visibleChrsetName</name><argument_list>(<argument><expr>(<name>unsigned</name>) <name>chrset</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>chrset</name></expr>)</condition> <block>{
		<case>case <expr><name>CSET_DHL_TOP</name></expr>:
		    <expr_stmt><expr><name>rect</name>.<name>y</name> = (<name>short</name>) -(<name>fs</name>-&gt;<name>ascent</name> / 2)</expr>;</expr_stmt>
		    <expr_stmt><expr><name>y</name> -= <name>rect</name>.<name>y</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>flags</name> |= <name>DOUBLEHFONT</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr><name>CSET_DHL_BOT</name></expr>:
		    <expr_stmt><expr><name>rect</name>.<name>y</name> = <call>(<name>short</name>) <argument_list>(<argument><expr><name>rect</name>.<name>height</name> - (<name>fs</name>-&gt;<name>ascent</name> / 2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>y</name> -= <name>rect</name>.<name>y</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>flags</name> |= <name>DOUBLEHFONT</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><default>default:
		    <expr_stmt><expr><name>nr</name> = 0</expr>;</expr_stmt>
		    <break>break;</break>
		</default>}</block></switch>

		<if>if <condition>(<expr><name>nr</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>xtermSetClipRectangles</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>gc2</name></expr></argument>,
					   <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>YXBanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><call><name>XSetClipMask</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>gc2</name></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	    }</block></then></if>

	    <comment type="block">/* Call ourselves recursively with the new gc */</comment>

	    <comment type="block">/*
	     * If we're trying to use proportional font, or if the
	     * font server didn't give us what we asked for wrt
	     * width, position each character independently.
	     */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>fnt_prop</name>
		|| (<name>fs</name>-&gt;<name>min_bounds</name>.<name>width</name> != <name>fs</name>-&gt;<name>max_bounds</name>.<name>width</name>)
		|| (<name>fs</name>-&gt;<name>min_bounds</name>.<name>width</name> != 2 * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<comment type="block">/* It is hard to fall-through to the main
		   branch: in a lot of places the check
		   for the cached font info is for
		   normal/bold fonts only. */</comment>
		<while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
		    <expr_stmt><expr><name>x</name> = <call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>gc2</name></expr></argument>,
				      <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr>0</expr></argument>,
				      <argument><expr><name>text</name>++</expr></argument>,
				      <argument><expr>1</expr></argument>, <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>x</name> += <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>x</name> = <call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>gc2</name></expr></argument>,
				  <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr>0</expr></argument>,
				  <argument><expr><name>text</name></expr></argument>,
				  <argument><expr><name>len</name></expr></argument>, <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> += (<name>int</name>) <name>len</name> *<call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("drawtext [%4d,%4d]\n", <name>y</name>, <name>x</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{		<comment type="block">/* simulate double-sized characters */</comment>
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>need</name> =<init> <expr>2 * <name>len</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>IChar</name> *</type><name>temp</name> =<init> <expr><call><name>TypeMallocN</name><argument_list>(<argument><expr><name>IChar</name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	    <while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
		<expr_stmt><expr><name><name>temp</name><index>[<expr><name>n</name>++</expr>]</index></name> = *<name>text</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>temp</name><index>[<expr><name>n</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt>
	    }</block></while>
	    <expr_stmt><expr><name>x</name> = <call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			      <argument><expr><name>flags</name></expr></argument>,
			      <argument><expr><name>gc</name></expr></argument>,
			      <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
			      <argument><expr>0</expr></argument>,
			      <argument><expr><name>temp</name></expr></argument>,
			      <argument><expr><name>n</name></expr></argument>,
			      <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr><name>x</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>UsingRenderFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>VTwin</name> *</type><name>currentWin</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><name>screen</name>-&gt;<name>display</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XftFont</name> *</type><name>font</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XGCValues</name></type> <name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fontnum</name> =<init> <expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ncells</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>renderDraw</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>scr</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Drawable</name></type> <name>draw</name> =<init> <expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Visual</name> *</type><name>visual</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>scr</name> = <call><name>DefaultScreen</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>visual</name> = <call><name>DefaultVisual</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>scr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>renderDraw</name> = <call><name>XftDrawCreate</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>draw</name></expr></argument>, <argument><expr><name>visual</name></expr></argument>,
					       <argument><expr><call><name>DefaultColormap</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>scr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>UNDERLINE</name>)
	    &amp;&amp; !<name>screen</name>-&gt;<name>colorULMode</name>
	    &amp;&amp; <name>screen</name>-&gt;<name>italicULMode</name>
	    &amp;&amp; <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderFontItal</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>font</name> = <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderFontItal</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>did_ul</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr>(<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)
		&amp;&amp; <call><name>UseBoldFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderFontBold</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>font</name> = <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderFontBold</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>font</name> = <call><name>XFT_FONT</name><argument_list>(<argument><expr><name><name>renderFontNorm</name><index>[<expr><name>fontnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
	<expr_stmt><expr><name>values</name>.<name>foreground</name> = <call><name>getCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name>.<name>background</name> = <call><name>getCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!(<name>flags</name> &amp; <name>NOBACKGROUND</name>)</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>XftColor</name> *</type><name>bg_color</name> =<init> <expr><call><name>getXftColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>values</name>.<name>background</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name>ncells</name> = <call><name>xtermXftWidth</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
				   <argument><expr><name>bg_color</name></expr></argument>,
				   <argument><expr><name>font</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
				   <argument><expr><name>text</name></expr></argument>,
				   <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XftDrawRect</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>renderDraw</name></expr></argument>,
			<argument><expr><name>bg_color</name></expr></argument>,
			<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
			<argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>ncells</name> * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr>(<name>unsigned</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>y</name> += <name>font</name>-&gt;<name>ascent</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BOX_CHARS</name></expr></cpp:if>
	<block>{
	    <comment type="block">/* adding code to substitute simulated line-drawing characters */</comment>
	    <decl_stmt><decl><type><name>int</name></type> <name>last</name>, <name>first</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Dimension</name></type> <name>old_wide</name>, <name>old_high</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>curX</name> =<init> <expr><name>x</name></expr></init></decl>;</decl_stmt>

	    <for>for (<init><expr><name>last</name> = 0</expr>;</init> <condition><expr><name>last</name> &lt; (<name>int</name>) <name>len</name></expr>;</condition> <incr><expr><name>last</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>Boolean</name></type> <name>replace</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Boolean</name></type> <name>missing</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>ch</name> =<init> <expr>(<name>unsigned</name>) <name><name>text</name><index>[<expr><name>last</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>

		<if>if <condition>(<expr><call><name>xtermIsDecGraphic</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <comment type="block">/*
		     * Xft generally does not have the line-drawing characters
		     * in cells 1-31.  Assume this (we cannot inspect the
		     * picture easily...), and attempt to fill in from real
		     * line-drawing character in the font at the Unicode
		     * position.  Failing that, use our own box-characters.
		     */</comment>
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>force_box_chars</name>
			|| <call><name>xtermXftMissing</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>font</name></expr></argument>, <argument><expr><call><name>dec2ucs</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>missing</name> = 1</expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><name>ch</name> = <call><name>dec2ucs</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>replace</name> = <name>True</name></expr>;</expr_stmt>
		    }</block></else></if>
		}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> &gt;= 256</expr>)</condition><then> <block>{
		    <comment type="block">/*
		     * If we're reading UTF-8 from the client, we may have a
		     * line-drawing character.  Translate it back to our
		     * box-code if Xft tells us that the glyph is missing.
		     */</comment>
		    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
			unsigned part = ucs2dec(ch);
			if (xtermIsDecGraphic(part) &amp;&amp;
			    (screen-&gt;force_box_chars
			     || xtermXftMissing(xw, font, ch))) {
			    ch = part;
			    missing = True;
			}
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		}</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><call><name>xtermIsDecGraphic</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <comment type="block">/*
		     * Xft generally does not have the line-drawing characters
		     * in cells 1-31.  Check for this, and attempt to fill in
		     * from real line-drawing character in the font at the
		     * Unicode position.  Failing that, use our own
		     * box-characters.
		     */</comment>
		    <if>if <condition>(<expr><call><name>xtermXftMissing</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>font</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>missing</name> = 1</expr>;</expr_stmt>
		    }</block></then></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * If we now have one of our box-codes, draw it directly.
		 */</comment>
		<if>if <condition>(<expr><name>missing</name> || <name>replace</name></expr>)</condition><then> <block>{
		    <comment type="block">/* line drawing character time */</comment>
		    <if>if <condition>(<expr><name>last</name> &gt; <name>first</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nc</name> = <call><name>drawClippedXftString</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
						  <argument><expr><name>flags</name></expr></argument>,
						  <argument><expr><name>font</name></expr></argument>,
						  <argument><expr><call><name>getXftColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>values</name>.<name>foreground</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>curX</name></expr></argument>,
						  <argument><expr><name>y</name></expr></argument>,
						  <argument><expr><name>text</name> + <name>first</name></expr></argument>,
						  <argument><expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>last</name> - <name>first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curX</name> += <name>nc</name> * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>underline_len</name> += (<name>Cardinal</name>) <name>nc</name></expr>;</expr_stmt>
		    }</block></then></if>
		    <if>if <condition>(<expr><name>missing</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>old_wide</name> = <name>screen</name>-&gt;<name>fnt_wide</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_high</name> = <name>screen</name>-&gt;<name>fnt_high</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>fnt_wide</name> = (<name>Dimension</name>) <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>fnt_high</name> = (<name>Dimension</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>xtermDrawBoxChar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
					 <argument><expr><name>curX</name></expr></argument>, <argument><expr><name>y</name> - <call><name>FontAscent</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curX</name> += <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>underline_len</name> += 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>fnt_wide</name> = <name>old_wide</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>fnt_high</name> = <name>old_high</name></expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>IChar</name></type> <name>ch2</name> =<init> <expr>(<name>IChar</name>) <name>ch</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>nc</name> = <call><name>drawClippedXftString</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
						  <argument><expr><name>flags</name></expr></argument>,
						  <argument><expr><name>font</name></expr></argument>,
						  <argument><expr><call><name>getXftColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>values</name>.<name>foreground</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>curX</name></expr></argument>,
						  <argument><expr><name>y</name></expr></argument>,
						  <argument><expr>&amp;<name>ch2</name></expr></argument>,
						  <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curX</name> += <name>nc</name> * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>underline_len</name> += (<name>Cardinal</name>) <name>nc</name></expr>;</expr_stmt>
		    }</block></else></if>
		    <expr_stmt><expr><name>first</name> = <name>last</name> + 1</expr>;</expr_stmt>
		}</block></then></if>
	    }</block></for>
	    <if>if <condition>(<expr><name>last</name> &gt; <name>first</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>underline_len</name> += (<name>Cardinal</name>)
		    <call><name>drawClippedXftString</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
					 <argument><expr><name>flags</name></expr></argument>,
					 <argument><expr><name>font</name></expr></argument>,
					 <argument><expr><call><name>getXftColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>values</name>.<name>foreground</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>curX</name></expr></argument>,
					 <argument><expr><name>y</name></expr></argument>,
					 <argument><expr><name>text</name> + <name>first</name></expr></argument>,
					 <argument><expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>last</name> - <name>first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{
	    <expr_stmt><expr><name>underline_len</name> += (<name>Cardinal</name>)
		<call><name>drawClippedXftString</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				     <argument><expr><name>flags</name></expr></argument>,
				     <argument><expr><name>font</name></expr></argument>,
				     <argument><expr><call><name>getXftColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>values</name>.<name>foreground</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><name>x</name></expr></argument>,
				     <argument><expr><name>y</name></expr></argument>,
				     <argument><expr><name>text</name></expr></argument>,
				     <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_BOX_CHARS */</comment>

	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>UNDERLINE</name>) &amp;&amp; <name>screen</name>-&gt;<name>underline</name> &amp;&amp; !<name>did_ul</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><call><name>FontDescent</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>y</name>++</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>XDrawLine</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
		      <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
		      <argument><expr><name>x</name> + (<name>int</name>) <name>underline_len</name> * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - 1</expr></argument>,
		      <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>x</name> + (<name>int</name>) <name>len</name> *<call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_RENDERFONT */</comment>
    <comment type="block">/*
     * If we're asked to display a proportional font, do this with a fixed
     * pitch.  Yes, it's ugly.  But we cannot distinguish the use of xterm
     * as a dumb terminal vs its use as in fullscreen programs such as vi.
     * Hint: do not try to use a proportional font in the icon.
     */</comment>
    <if>if <condition>(<expr>!<call><name>IsIcon</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> &amp;&amp; !(<name>flags</name> &amp; <name>CHARBYCHAR</name>) &amp;&amp; <name>screen</name>-&gt;<name>fnt_prop</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>adj</name>, <name>width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XTermFonts</name> *</type><name>font</name> =<init> <expr>((<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)
			    ? <call><name>WhichVFontData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>fnts</name><index>[<expr><name>fBold</name></expr>]</index></name></expr></argument>)</argument_list></call>
			    : <call><name>WhichVFontData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>fnts</name><index>[<expr><name>fNorm</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>cells</name> =<init> <expr><call><name>WideCells</name><argument_list>(<argument><expr>*<name>text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BOX_CHARS</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <if>if <condition>(<expr>*<name>text</name> == <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>++<name>text</name></expr>;</expr_stmt>
		<continue>continue;</continue>
	    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr><call><name>IsXtermMissingChar</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>*<name>text</name></expr></argument>, <argument><expr><name>font</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>adj</name> = 0</expr>;</expr_stmt>
	    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <block>{
		<macro><name>if_WIDE_OR_NARROW</name><argument_list>(<argument>screen</argument>, <argument>{
		    XChar2b temp[1];
		    temp[0].byte2 = LO_BYTE(*text);
		    temp[0].byte1 = HI_BYTE(*text);
		    width = XTextWidth16(font-&gt;fs, temp, 1);
		}</argument>
		, <argument>{
		    char temp[1];
		    temp[0] = (char) LO_BYTE(*text);
		    width = XTextWidth(font-&gt;fs, temp, 1);
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<expr_stmt><expr><name>adj</name> = (<call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>width</name>) / 2</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>adj</name> &lt; 0</expr>)</condition><then>
		    <expr_stmt><expr><name>adj</name> = 0</expr>;</expr_stmt></then></if>
	    }</block></else></if></else></if>
	    <expr_stmt><expr><call><name>xtermFillCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr>(<name>Cardinal</name>) <name>cells</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>x</name> = <call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			      <argument><expr><name>flags</name> | <name>NOBACKGROUND</name> | <name>CHARBYCHAR</name></expr></argument>,
			      <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>x</name> + <name>adj</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>chrset</name></expr></argument>,
			      <argument><expr><name>text</name>++</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call> - <name>adj</name></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>x</name></expr>;</return>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BOX_CHARS</name></expr></cpp:if>
    <comment type="block">/* If the font is incomplete, draw some substitutions */</comment>
    <if>if <condition>(<expr>!<call><name>IsIcon</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; !(<name>flags</name> &amp; <name>NOTRANSLATION</name>)
	&amp;&amp; (!<name>screen</name>-&gt;<name>fnt_boxes</name> || <name>screen</name>-&gt;<name>force_box_chars</name>)</expr>)</condition><then> <block>{
	<comment type="block">/* Fill in missing box-characters.
	   Find regions without missing characters, and draw
	   them calling ourselves recursively.  Draw missing
	   characters via xtermDrawBoxChar(). */</comment>
	<decl_stmt><decl><type><name>XTermFonts</name> *</type><name>font</name> =<init> <expr>((<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)
			    ? <call><name>WhichVFontData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>fnts</name><index>[<expr><name>fBold</name></expr>]</index></name></expr></argument>)</argument_list></call>
			    : <call><name>WhichVFontData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>fnts</name><index>[<expr><name>fNorm</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>last</name>, <name>first</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bool</name></type> <name>drewBoxes</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>last</name> = 0</expr>;</init> <condition><expr><name>last</name> &lt; (<name>int</name>) <name>len</name></expr>;</condition> <incr><expr><name>last</name>++</expr></incr>) <block>{
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>ch</name> =<init> <expr>(<name>unsigned</name>) <name><name>text</name><index>[<expr><name>last</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Bool</name></type> <name>isMissing</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>ch_width</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>

	    <if>if <condition>(<expr><name>ch</name> == <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>last</name> &gt; <name>first</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>x</name> = <call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name> | <name>NOTRANSLATION</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
				      <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
				      <argument><expr><name>chrset</name></expr></argument>, <argument><expr><name>text</name> + <name>first</name></expr></argument>,
				      <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>last</name> - <name>first</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>first</name> = <name>last</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>drewBoxes</name> = <name>True</name></expr>;</expr_stmt>
		<continue>continue;</continue>
	    }</block></then></if>
	    <expr_stmt><expr><name>ch_width</name> = <call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>int</name>) <name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>isMissing</name> =
		<call><name>IsXtermMissingChar</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>,
				   <argument><expr>((<name>on_wide</name> || <name>ch_width</name> &gt; 1)
				    &amp;&amp; <call><name>okFont</name><argument_list>(<argument><expr><call><name>NormalWFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
				   ? <call><name>WhichVFontData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>fnts</name><index>[<expr><name>fWide</name></expr>]</index></name></expr></argument>)</argument_list></call>
				   : <name>font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <expr_stmt><expr><name>isMissing</name> = <call><name>IsXtermMissingChar</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>ch_width</name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <comment type="block">/*
	     * If the character is not missing, but we're in wide-character
	     * mode and the character happens to be a wide-character that
	     * corresponds to the line-drawing set, allow the forceBoxChars
	     * resource (or menu entry) to force it to display using our
	     * tables.
	     */</comment>
	    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		if (!isMissing
		    &amp;&amp; ch &gt; 255
		    &amp;&amp; ucs2dec(ch) &lt; 32
		    &amp;&amp; TScreenOf(xw)-&gt;force_box_chars) {
		    ch = ucs2dec(ch);
		    isMissing = True;
		}
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	    <if>if <condition>(<expr><name>isMissing</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>last</name> &gt; <name>first</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>x</name> = <call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name> | <name>NOTRANSLATION</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
				      <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
				      <argument><expr><name>chrset</name></expr></argument>, <argument><expr><name>text</name> + <name>first</name></expr></argument>,
				      <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>last</name> - <name>first</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
		<if>if <condition>(<expr><call><name>ucs_workaround</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
				   <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
				   <argument><expr><name>chrset</name></expr></argument>, <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <comment type="block">/*
		     * if true, we drew at least one cell whether or not it is
		     * printable
		     */</comment>
		    <if>if <condition>(<expr><name>ch_width</name> &lt;= 0</expr>)</condition><then>
			<expr_stmt><expr><name>ch_width</name> = 1</expr>;</expr_stmt></then></if>
		}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
		    <if>if <condition>(<expr><name>ch_width</name> &lt;= 0</expr>)</condition><then>
			<expr_stmt><expr><name>ch_width</name> = 1</expr>;</expr_stmt></then></if>
		    <expr_stmt><expr><call><name>xtermDrawBoxChar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
				     <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
				     <argument><expr><name>ch_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name>x</name> += (<name>ch_width</name> * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> = <name>last</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>drewBoxes</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>last</name> &lt;= <name>first</name></expr>)</condition><then> <block>{
	    <return>return <expr><name>x</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>text</name> += <name>first</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>last</name> - <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags</name> |= <name>NOTRANSLATION</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>drewBoxes</name></expr>)</condition><then> <block>{
	    <return>return <expr><call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				 <argument><expr><name>flags</name></expr></argument>,
				 <argument><expr><name>gc</name></expr></argument>,
				 <argument><expr><name>x</name></expr></argument>,
				 <argument><expr><name>y</name></expr></argument>,
				 <argument><expr><name>chrset</name></expr></argument>,
				 <argument><expr><name>text</name></expr></argument>,
				 <argument><expr><name>len</name></expr></argument>,
				 <argument><expr><name>on_wide</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_BOX_CHARS */</comment>
    <comment type="block">/*
     * Behave as if the font has (maybe Unicode-replacements for) drawing
     * characters in the range 1-31 (either we were not asked to ignore them,
     * or the caller made sure that there is none).
     */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("drawtext%c[%4d,%4d] (%d) %d:%s\n",
	   <name>screen</name>-&gt;<name>cursor_state</name> == <name>OFF</name> ? ' ' : '*',
	   <name>y</name>, <name>x</name>, <name>chrset</name>, <name>len</name>,
	   <call><name>visibleIChars</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> += <call><name>FontAscent</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name> || <name>screen</name>-&gt;<name>unicode_font</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XChar2b</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bool</name></type> <name>needWide</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ascent_adjust</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>src</name>, <name>dst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BumpTypedBuffer</name><argument_list>(<argument><expr><name>XChar2b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> = <call><name>BfBuf</name><argument_list>(<argument><expr><name>XChar2b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>src</name> = <name>dst</name> = 0</expr>;</init> <condition><expr><name>src</name> &lt; (<name>int</name>) <name>len</name></expr>;</condition> <incr><expr><name>src</name>++</expr></incr>) <block>{
	    <decl_stmt><decl><type><name>IChar</name></type> <name>ch</name> =<init> <expr><name><name>text</name><index>[<expr><name>src</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>ch</name> == <name>HIDDEN_CHAR</name></expr>)</condition><then>
		<continue>continue;</continue></then></if>

	    <if>if <condition>(<expr>!<name>needWide</name>
		&amp;&amp; !<call><name>IsIcon</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
		&amp;&amp; ((<name>on_wide</name> || <call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>int</name>) <name>ch</name></expr></argument>)</argument_list></call> &gt; 1)
		    &amp;&amp; <call><name>okFont</name><argument_list>(<argument><expr><call><name>NormalWFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>needWide</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/*
	     * bitmap-fonts are limited to 16-bits.
	     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDER_ICHAR</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>ch</name> &gt; 0xffff</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ch</name> = <name>UCS_REPL</name></expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>dst</name></expr>]</index></name>.<name>byte2</name> = <call><name>LO_BYTE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>dst</name></expr>]</index></name>.<name>byte1</name> = <call><name>HI_BYTE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MINI_LUIT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>UCS2SBUF</name>(value)	buffer[dst].byte2 = LO_BYTE(value);\
	    		buffer[dst].byte1 = HI_BYTE(value)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>Map2Sbuf</name>(from,to) (text[src] == from) { UCS2SBUF(to); }</cpp:define>

	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>latin9_mode</name> &amp;&amp; !<name>screen</name>-&gt;<name>utf8_mode</name> &amp;&amp; <name><name>text</name><index>[<expr><name>src</name></expr>]</index></name> &lt; 256</expr>)</condition><then> <block>{

		<comment type="block">/* see http://www.cs.tut.fi/~jkorpela/latin9.html */</comment>
		<comment type="block">/* *INDENT-OFF* */</comment>
		<if>if Map2Sbuf<condition>(<expr>0xa4</expr>, <expr>0x20ac</expr>)</condition><then>
		<else>else <if>if Map2Sbuf<condition>(<expr>0xa6</expr>, <expr>0x0160</expr>)</condition><then>
		<else>else <if>if Map2Sbuf<condition>(<expr>0xa8</expr>, <expr>0x0161</expr>)</condition><then>
		<else>else <if>if Map2Sbuf<condition>(<expr>0xb4</expr>, <expr>0x017d</expr>)</condition><then>
		<else>else <if>if Map2Sbuf<condition>(<expr>0xb8</expr>, <expr>0x017e</expr>)</condition><then>
		<else>else <if>if Map2Sbuf<condition>(<expr>0xbc</expr>, <expr>0x0152</expr>)</condition><then>
		<else>else <if>if Map2Sbuf<condition>(<expr>0xbd</expr>, <expr>0x0153</expr>)</condition><then>
		<else>else <if>if Map2Sbuf<condition>(<expr>0xbe</expr>, <expr>0x0178</expr>)</condition><then/></if></else></then></if></else></then></if></else></then></if></else></then></if></else></then></if></else></then></if></else></then></if>
		<comment type="block">/* *INDENT-ON* */</comment>

	    }</block></then></if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>unicode_font</name>
		&amp;&amp; (<name><name>text</name><index>[<expr><name>src</name></expr>]</index></name> == <name>ANSI_DEL</name> ||
		    <name><name>text</name><index>[<expr><name>src</name></expr>]</index></name> &lt; <name>ANSI_SPA</name>)</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>unsigned</name></type> <name>ni</name> =<init> <expr><call><name>dec2ucs</name><argument_list>(<argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name><name>text</name><index>[<expr><name>src</name></expr>]</index></name> == <name>ANSI_DEL</name>)
						  ? 0
						  : <name><name>text</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>UCS2SBUF</name><argument_list>(<argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MINI_LUIT */</comment>
	    <expr_stmt><expr>++<name>dst</name></expr>;</expr_stmt>
	}</block></for>
	<comment type="block">/* FIXME This is probably wrong. But it works. */</comment>
	<expr_stmt><expr><name>underline_len</name> = <name>len</name></expr>;</expr_stmt>

	<comment type="block">/* Set the drawing font */</comment>
	<if>if <condition>(<expr>!(<name>flags</name> &amp; (<name>DOUBLEHFONT</name> | <name>DOUBLEWFONT</name>))</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>VTwin</name> *</type><name>currentWin</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>VTFontEnum</name></type> <name>fntId</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>CgsEnum</name></type> <name>cgsId</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg</name> =<init> <expr><call><name>getCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg</name> =<init> <expr><call><name>getCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>needWide</name>
		&amp;&amp; (<call><name>okFont</name><argument_list>(<argument><expr><call><name>NormalWFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> || <call><name>okFont</name><argument_list>(<argument><expr><call><name>BoldWFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>) != 0
		    &amp;&amp; <call><name>okFont</name><argument_list>(<argument><expr><call><name>BoldWFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>fntId</name> = <name>fWBold</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>cgsId</name> = <name>gcWBold</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><name>fntId</name> = <name>fWide</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>cgsId</name> = <name>gcWide</name></expr>;</expr_stmt>
		}</block></else></if>
	    }</block></then> <else>else <if>if <condition>(<expr>(<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>) != 0
		       &amp;&amp; <call><name>okFont</name><argument_list>(<argument><expr><call><name>BoldFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>fntId</name> = <name>fBold</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cgsId</name> = <name>gcBold</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>fntId</name> = <name>fNorm</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cgsId</name> = <name>gcNorm</name></expr>;</expr_stmt>
	    }</block></else></if></else></if>

	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>gc</name> = <call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name>fntId</name> != <name>fNorm</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>XFontStruct</name> *</type><name>thisFp</name> =<init> <expr><call><name>WhichVFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>fnts</name><index>[<expr><name>fntId</name></expr>]</index></name>.<name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ascent_adjust</name> = (<name>thisFp</name>-&gt;<name>ascent</name>
				 - <call><name>NormalFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>-&gt;<name>ascent</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>thisFp</name>-&gt;<name>max_bounds</name>.<name>width</name> ==
		    <call><name>NormalFont</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>-&gt;<name>max_bounds</name>.<name>width</name> * 2</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>underline_len</name> = <name>real_length</name> = <call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>dst</name> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>cgsId</name> == <name>gcWide</name> || <name>cgsId</name> == <name>gcWBold</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>underline_len</name> = <name>real_length</name> = <call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>dst</name> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>xtermFillCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				   <argument><expr><name>flags</name></expr></argument>,
				   <argument><expr><name>gc</name></expr></argument>,
				   <argument><expr><name>x</name></expr></argument>,
				   <argument><expr><name>y</name> - <name>thisFp</name>-&gt;<name>ascent</name></expr></argument>,
				   <argument><expr><name>real_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
	    }</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>flags</name> &amp; <name>NOBACKGROUND</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XDrawString16</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
			  <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
			  <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name> + <name>ascent_adjust</name></expr></argument>,
			  <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>XDrawImageString16</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
			       <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
			       <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name> + <name>ascent_adjust</name></expr></argument>,
			       <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr>(<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>) &amp;&amp; <name>screen</name>-&gt;<name>enbolden</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>beginClipping</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr>(<name>Cardinal</name>) <name>font_width</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XDrawString16</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
			  <argument><expr><name>x</name> + 1</expr></argument>,
			  <argument><expr><name>y</name> + <name>ascent_adjust</name></expr></argument>,
			  <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>endClipping</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_WIDE_CHARS */</comment>
    <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>length</name> =<init> <expr>(<name>int</name>) <name>len</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* X should have used unsigned */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>dst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BumpTypedBuffer</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> = <call><name>BfBuf</name><argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>dst</name> = 0</expr>;</init> <condition><expr><name>dst</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>dst</name></expr></incr>)
	    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>dst</name></expr>]</index></name> = (<name>char</name>) <call><name>LO_BYTE</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>dst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> =<init> <expr>(<name>char</name> *) <name>text</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>flags</name> &amp; <name>NOBACKGROUND</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XDrawString</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
			<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>XDrawImageString</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
			     <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>underline_len</name> = (<name>Cardinal</name>) <name>length</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>) &amp;&amp; <name>screen</name>-&gt;<name>enbolden</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>beginClipping</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>font_width</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XDrawString</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
			<argument><expr><name>x</name> + 1</expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>endClipping</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>UNDERLINE</name>) &amp;&amp; <name>screen</name>-&gt;<name>underline</name> &amp;&amp; !<name>did_ul</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>FontDescent</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then>
	    <expr_stmt><expr><name>y</name>++</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>XDrawLine</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc</name></expr></argument>,
		  <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr>(<name>x</name> + (<name>int</name>) <name>underline_len</name> * <name>font_width</name> - 1)</expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>x</name> + (<name>int</name>) <name>real_length</name> *<call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
 * Allocate buffer - workaround for wide-character interfaces.
 */</comment>
<function><type><name>void</name></type>
<name>allocXtermChars</name><parameter_list>(<param><decl><type><name>ScrnPtr</name> *</type> <name>buffer</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>*<name>buffer</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>buffer</name> = (<name>ScrnPtr</name>) <call><name>XtMalloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr>*<name>buffer</name> = (<name>ScrnPtr</name>) <call><name>XtRealloc</name><argument_list>(<argument><expr>(<name>char</name> *) *<name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* set up size hints for window manager; min 1 char by 1 char */</comment>
<function><type><name>void</name></type>
<name>xtermSizeHints</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>scrollbarWidth</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermSizeHints\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("   border    %d\n", <name>xw</name>-&gt;<name>core</name>.<name>border_width</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("   scrollbar %d\n", <name>scrollbarWidth</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>base_width</name> = 2 * <name>screen</name>-&gt;<name>border</name> + <name>scrollbarWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>base_height</name> = 2 * <name>screen</name>-&gt;<name>border</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("   toolbar   %d\n", <call><name>ToolbarHeight</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>base_height</name> += <call><name>ToolbarHeight</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>base_height</name> += <call><name>BorderWidth</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call> * 2</expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>base_width</name> += <call><name>BorderWidth</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call> * 2</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>width_inc</name> = <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>height_inc</name> = <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>min_width</name> = <name>xw</name>-&gt;<name>hints</name>.<name>base_width</name> + <name>xw</name>-&gt;<name>hints</name>.<name>width_inc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>min_height</name> = <name>xw</name>-&gt;<name>hints</name>.<name>base_height</name> + <name>xw</name>-&gt;<name>hints</name>.<name>height_inc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>width</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>xw</name>-&gt;<name>hints</name>.<name>min_width</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>height</name> = <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>xw</name>-&gt;<name>hints</name>.<name>min_height</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name> |= (<name>PSize</name> | <name>PBaseSize</name> | <name>PMinSize</name> | <name>PResizeInc</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE_HINTS</name><argument_list>(<argument><expr>&amp;(<name>xw</name>-&gt;<name>hints</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>getXtermSizeHints</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>supp</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>XGetWMNormalHints</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>&amp;<name>xw</name>-&gt;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>supp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>hints</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>TRACE_HINTS</name><argument_list>(<argument><expr>&amp;(<name>xw</name>-&gt;<name>hints</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Returns a GC, selected according to the font (reverse/bold/normal) that is
 * required for the current position (implied).  The GC is updated with the
 * current screen foreground and background colors.
 */</comment>
<function><type><name>GC</name></type>
<name>updatedXtermGC</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>fg_bg</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>hilite</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTwin</name> *</type><name>win</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CgsEnum</name></type> <name>cgsId</name> =<init> <expr><name>gcMAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>my_fg</name> =<init> <expr><call><name>extract_fg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>my_bg</name> =<init> <expr><call><name>extract_bg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg_pix</name> =<init> <expr><call><name>getXtermForeground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>my_fg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg_pix</name> =<init> <expr><call><name>getXtermBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>my_bg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>xx_pix</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>selbg_pix</name> =<init> <expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>selfg_pix</name> =<init> <expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>always</name> =<init> <expr><name>screen</name>-&gt;<name>hilite_color</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>use_selbg</name> =<init> <expr><call>(<name>Boolean</name>) <argument_list>(<argument><expr><name>always</name> ||
				   <call><name>isNotForeground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>, <argument><expr><name>selbg_pix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>use_selfg</name> =<init> <expr><call>(<name>Boolean</name>) <argument_list>(<argument><expr><name>always</name> &amp;&amp;
				   <call><name>isNotBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>, <argument><expr><name>selfg_pix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr>(<name>void</name>) <name>fg_bg</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>my_bg</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>my_fg</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Discard video attributes overridden by colorXXXMode's.
     */</comment>
    <expr_stmt><expr><call><name>checkVeryBoldColors</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>my_fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ReverseOrHilite</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hilite</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcBoldReverse</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcNormReverse</name></expr>;</expr_stmt>
	}</block></else></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
	<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>hilite_color</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>selbg_pix</name> != <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call>
		&amp;&amp; <name>selbg_pix</name> != <name>fg_pix</name>
		&amp;&amp; <name>selbg_pix</name> != <name>bg_pix</name>
		&amp;&amp; <name>selbg_pix</name> != <name>xw</name>-&gt;<name>dft_foreground</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>bg_pix</name> = <name>fg_pix</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fg_pix</name> = <name>selbg_pix</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>fg_pix</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>, <argument><expr><name>xx_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>hilite_color</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>hilite_reverse</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>use_selbg</name></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><name>use_selfg</name></expr>)</condition><then>
			<expr_stmt><expr><name>bg_pix</name> = <name>fg_pix</name></expr>;</expr_stmt></then>
		    <else>else
			<expr_stmt><expr><name>fg_pix</name> = <name>bg_pix</name></expr>;</expr_stmt></else></if>
		}</block></then></if>
		<if>if <condition>(<expr><name>use_selbg</name></expr>)</condition><then>
		    <expr_stmt><expr><name>bg_pix</name> = <name>selbg_pix</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>use_selfg</name></expr>)</condition><then>
		    <expr_stmt><expr><name>fg_pix</name> = <name>selfg_pix</name></expr>;</expr_stmt></then></if>
	    }</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcBold</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcNorm</name></expr>;</expr_stmt>
	}</block></else></if>
    }</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>hilite_color</name> || !<name>screen</name>-&gt;<name>hilite_reverse</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>hilite</name> &amp;&amp; !<name>screen</name>-&gt;<name>hilite_reverse</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>use_selbg</name></expr>)</condition><then>
		<expr_stmt><expr><name>bg_pix</name> = <name>selbg_pix</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>use_selfg</name></expr>)</condition><then>
		<expr_stmt><expr><name>fg_pix</name> = <name>selfg_pix</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_TEXT</name></expr></cpp:if>
    <if>if <condition>(<expr>(<name>screen</name>-&gt;<name>blink_state</name> == <name>ON</name>) &amp;&amp; (!<name>screen</name>-&gt;<name>blink_as_bold</name>) &amp;&amp; (<name>flags</name> &amp; <name>BLINK</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>fg_pix</name> = <name>bg_pix</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Resets the foreground/background of the GC returned by 'updatedXtermGC()'
 * to the values that would be set in SGR_Foreground and SGR_Background. This
 * duplicates some logic, but only modifies 1/4 as many GC's.
 */</comment>
<function><type><name>void</name></type>
<name>resetXtermGC</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>hilite</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTwin</name> *</type><name>win</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CgsEnum</name></type> <name>cgsId</name> =<init> <expr><name>gcMAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg_pix</name> =<init> <expr><call><name>getXtermForeground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>cur_foreground</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg_pix</name> =<init> <expr><call><name>getXtermBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>cur_background</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>checkVeryBoldColors</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>cur_foreground</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ReverseOrHilite</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hilite</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcBoldReverse</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcNormReverse</name></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcBold</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>cgsId</name> = <name>gcNorm</name></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>cgsId</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
<comment type="block">/*
 * Extract the foreground-color index from a color pair.
 * If we've got BOLD or UNDERLINE color-mode active, those will be used.
 */</comment>
<function><type><name>unsigned</name></type>
<name>extract_fg</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>color</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>fg</name> =<init> <expr><call><name>ExtractForeground</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>colorAttrMode</name>
	|| (<name>fg</name> == <call><name>ExtractBackground</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>fg</name> = <call><name>MapToColorMode</name><argument_list>(<argument><expr><name>fg</name></expr></argument>, <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>fg</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Extract the background-color index from a color pair.
 * If we've got INVERSE color-mode active, that will be used.
 */</comment>
<function><type><name>unsigned</name></type>
<name>extract_bg</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>color</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>bg</name> =<init> <expr><call><name>ExtractBackground</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>colorAttrMode</name>
	|| (<name>bg</name> == <call><name>ExtractForeground</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>colorRVMode</name> &amp;&amp; (<name>flags</name> &amp; <name>INVERSE</name>)</expr>)</condition><then>
	    <expr_stmt><expr><name>bg</name> = <name>COLOR_RV</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <return>return <expr><name>bg</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Combine the current foreground and background into a single 8-bit number.
 * Note that we're storing the SGR foreground, since cur_foreground may be set
 * to COLOR_UL, COLOR_BD or COLOR_BL, which would make the code larger than 8
 * bits.
 *
 * This assumes that fg/bg are equal when we override with one of the special
 * attribute colors.
 */</comment>
<function><type><name>CellColor</name></type>
<name>makeColorPair</name><parameter_list>(<param><decl><type><name>int</name></type> <name>fg</name></decl></param>, <param><decl><type><name>int</name></type> <name>bg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>my_bg</name> =<init> <expr>(<name>bg</name> &gt;= 0) &amp;&amp; (<name>bg</name> &lt; <name>NUM_ANSI_COLORS</name>) ? (<name>unsigned</name>) <name>bg</name> : 0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>my_fg</name> =<init> <expr>(<name>fg</name> &gt;= 0) &amp;&amp; (<name>fg</name> &lt; <name>NUM_ANSI_COLORS</name>) ? (<name>unsigned</name>) <name>fg</name> : <name>my_bg</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call>(<name>CellColor</name>) <argument_list>(<argument><expr><name>my_fg</name> | (<name>my_bg</name> &lt;&lt; <name>COLOR_BITS</name>)</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Using the "current" SGR background, clear a rectangle.
 */</comment>
<function><type><name>void</name></type>
<name>ClearCurBackground</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>top</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>left</name></decl></param>,
		   <param><decl><type><name>unsigned</name></type> <name>height</name></decl></param>,
		   <param><decl><type><name>unsigned</name></type> <name>width</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ClearCurBackground(%d,%d,%d,%d) %d\n",
	   <name>top</name>, <name>left</name>, <name>height</name>, <name>width</name>, <name>xw</name>-&gt;<name>cur_background</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>set_background</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>cur_background</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XClearArea</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>left</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_background</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_ISO_COLORS */</comment>

<comment type="block">/*
 * Returns a single base character for the given cell.
 */</comment>
<function><type><name>unsigned</name></type>
<name>getXtermCell</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ld</name> &amp;&amp; (<name>col</name> &lt; (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>((<name>ld</name> &amp;&amp; (<name>col</name> &lt; (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name>))
	    ? <name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>col</name></expr>]</index></name>
	    : (<name>unsigned</name>) ' ')</expr>;</return>
}</block></function>

<comment type="block">/*
 * Sets a single base character for the given cell.
 */</comment>
<function><type><name>void</name></type>
<name>putXtermCell</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>, <param><decl><type><name>int</name></type> <name>ch</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ld</name> &amp;&amp; (<name>col</name> &lt; (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ld</name> &amp;&amp; (<name>col</name> &lt; (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>col</name></expr>]</index></name> = (<name>CharData</name>) <name>ch</name></expr>;</expr_stmt>
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    size_t off;
	    for_each_combData(off, ld) {
		ld-&gt;combData[off][col] = 0;
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></then></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
 * Add a combining character for the given cell
 */</comment>
<function><type><name>void</name></type>
<name>addXtermCombining</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ch</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>ch</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("addXtermCombining %d,%d %#x (%d)\n",
	       <name>row</name>, <name>col</name>, <name>ch</name>, <call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>wchar_t</name>) <name>ch</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>for_each_combData</name><argument_list>(<argument>off</argument>, <argument>ld</argument>)</argument_list></macro> <block>{
	    <if>if <condition>(<expr>!<name>ld</name>-&gt;<name><name>combData</name><index>[<expr><name>off</name></expr>]</index><index>[<expr><name>col</name></expr>]</index></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ld</name>-&gt;<name><name>combData</name><index>[<expr><name>off</name></expr>]</index><index>[<expr><name>col</name></expr>]</index></name> = (<name>CharData</name>) <name>ch</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_MY_MEMMOVE</name></cpp:ifdef>
<function><type><name>void</name> *</type>
<name>my_memmove</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>s1</name></decl></param>, <param><decl><type><name>void</name> *</type><name>s2</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>n</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>p1</name> =<init> <expr>(<name>char</name> *) <name>s1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p2</name> =<init> <expr>(<name>char</name> *) <name>s2</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>p1</name> + <name>n</name> &gt; <name>p2</name>) &amp;&amp; (<name>p2</name> + <name>n</name> &gt; <name>p1</name>)</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>bfr</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>static</name> <name>size_t</name></type> <name>length</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>length</name> &lt; <name>n</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>length</name> = (<name>n</name> * 3) / 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>bfr</name> = ((<name>bfr</name> != 0)
		       ? <call><name>TypeRealloc</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>bfr</name></expr></argument>)</argument_list></call>
		       : <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bfr</name> == <name>NULL</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_MMALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    }</block></then></if>
	    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
		<expr_stmt><expr><name><name>bfr</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>p2</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>
	    <expr_stmt><expr><name>p2</name> = <name>bfr</name></expr>;</expr_stmt>
	}</block></then></if>
	<while>while <condition>(<expr><name>n</name>-- != 0</expr>)</condition>
	    <expr_stmt><expr><name><name>p1</name><index>[<expr><name>n</name></expr>]</index></name> = <name><name>p2</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt></while>
    }</block></then></if>
    <return>return <expr><name>s1</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_MY_MEMMOVE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRERROR</name></cpp:ifndef>
<function><type><name>char</name> *</type>
<name>my_strerror</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>extern</name> <name>char</name> *</type><name><name>sys_errlist</name><index>[]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>extern</name> <name>int</name></type> <name>sys_nerr</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; <name>n</name> &lt; <name>sys_nerr</name></expr>)</condition><then>
	<return>return <expr><name><name>sys_errlist</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return></then></if>
    <return>return <expr>"?"</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>update_keyboard_type</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>update_delete_del</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_tcap_fkeys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_old_fkeys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_hp_fkeys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_sco_fkeys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_sun_fkeys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_sun_kbd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>set_keyboard_type</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>xtermKeyboardType</name></type> <name>type</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>set</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>xtermKeyboardType</name></type> <name>save</name> =<init> <expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_keyboard_type(%s, %s) currently %s\n",
	   <call><name>visibleKeyboardType</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call>,
	   <call><name>BtoS</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call>,
	   <call><name>visibleKeyboardType</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>set</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> = <name>type</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> = <name>keyboardIsDefault</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>save</name> != <name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>update_keyboard_type</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>toggle_keyboard_type</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>xtermKeyboardType</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>xtermKeyboardType</name></type> <name>save</name> =<init> <expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("toggle_keyboard_type(%s) currently %s\n",
	   <call><name>visibleKeyboardType</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call>,
	   <call><name>visibleKeyboardType</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> == <name>type</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> = <name>keyboardIsDefault</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> = <name>type</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>save</name> != <name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>update_keyboard_type</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>init_keyboard_type</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>xtermKeyboardType</name></type> <name>type</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>set</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>Bool</name></type> <name>wasSet</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("init_keyboard_type(%s, %s) currently %s\n",
	   <call><name>visibleKeyboardType</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call>,
	   <call><name>BtoS</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call>,
	   <call><name>visibleKeyboardType</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>set</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>wasSet</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Conflicting keyboard type option (%u/%u)\n"</expr></argument>,
		    <argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> = <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>wasSet</name> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_keyboard_type</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * If the keyboardType resource is set, use that, overriding the individual
 * boolean resources for different keyboard types.
 */</comment>
<function><type><name>void</name></type>
<name>decode_keyboard_type</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XTERM_RESOURCE</name> *</type> <name>rp</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DATA</name>(n, t, f) { n, t, XtOffsetOf(XTERM_RESOURCE, f) }</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FLAG</name>(n) *(Boolean *)(((char *)rp) + table[n].offset)</cpp:define>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xtermKeyboardType</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>offset</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>table</name><index>[]</index></name> = <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HP_FUNC_KEYS</name></expr></cpp:if>
	<expr><call><name>DATA</name><argument_list>(<argument><expr><name>NAME_HP_KT</name></expr></argument>, <argument><expr><name>keyboardIsHP</name></expr></argument>, <argument><expr><name>hpFunctionKeys</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCO_FUNC_KEYS</name></expr></cpp:if>
	    <expr><call><name>DATA</name><argument_list>(<argument><expr><name>NAME_SCO_KT</name></expr></argument>, <argument><expr><name>keyboardIsSCO</name></expr></argument>, <argument><expr><name>scoFunctionKeys</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUN_FUNC_KEYS</name></expr></cpp:if>
	    <expr><call><name>DATA</name><argument_list>(<argument><expr><name>NAME_SUN_KT</name></expr></argument>, <argument><expr><name>keyboardIsSun</name></expr></argument>, <argument><expr><name>sunFunctionKeys</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
	    <expr><call><name>DATA</name><argument_list>(<argument><expr><name>NAME_VT220_KT</name></expr></argument>, <argument><expr><name>keyboardIsVT220</name></expr></argument>, <argument><expr><name>sunKeyboard</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TCAP_FKEYS</name></expr></cpp:if>
	    <expr><call><name>DATA</name><argument_list>(<argument><expr><name>NAME_TCAP_KT</name></expr></argument>, <argument><expr><name>keyboardIsTermcap</name></expr></argument>, <argument><expr><name>termcapKeys</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("decode_keyboard_type(%s)\n", <name>rp</name>-&gt;<name>keyboardType</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>rp</name>-&gt;<name>keyboardType</name></expr></argument>, <argument><expr>"unknown"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/*
	 * Let the individual resources comprise the keyboard-type.
	 */</comment>
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
	    <expr_stmt><expr><call><name>init_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>type</name></expr></argument>, <argument><expr><call><name>FLAG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>rp</name>-&gt;<name>keyboardType</name></expr></argument>, <argument><expr>"default"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/*
	 * Set the keyboard-type to the Sun/PC type, allowing modified
	 * function keys, etc.
	 */</comment>
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
	    <expr_stmt><expr><call><name>init_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>type</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type><name>Bool</name></type> <name>found</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Choose an individual keyboard type.
	 */</comment>
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	    <if>if <condition>(<expr>!<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>rp</name>-&gt;<name>keyboardType</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>FLAG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> = <name>True</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>FLAG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> = <name>False</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>init_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>type</name></expr></argument>, <argument><expr><call><name>FLAG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<if>if <condition>(<expr>!<name>found</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
		    <argument><expr>"KeyboardType resource \"%s\" not found\n"</expr></argument>,
		    <argument><expr><name>rp</name>-&gt;<name>keyboardType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if></else></if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DATA</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FLAG</name></cpp:undef>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCHAR_H</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCWIDTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * If xterm is running in a UTF-8 locale, it is still possible to encounter
 * old runtime configurations which yield incomplete or inaccurate data.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>systemWcwidthOk</name><parameter_list>(<param><decl><type><name>int</name></type> <name>samplesize</name></decl></param>, <param><decl><type><name>int</name></type> <name>samplepass</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>wchar_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>oops</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>n</name> = 21</expr>;</init> <condition><expr><name>n</name> &lt;= 25</expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>code</name> =<init> <expr>(<name>int</name>) <call><name>dec2ucs</name><argument_list>(<argument><expr>(<name>unsigned</name>) <name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>system_code</name> =<init> <expr><call><name>wcwidth</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>intern_code</name> =<init> <expr><call><name>mk_wcwidth</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Solaris 10 wcwidth() returns "2" for all of the line-drawing (page
	 * 0x2500) and most of the geometric shapes (a few are excluded, just
	 * to make it more difficult to use).  Do a sanity check to avoid using
	 * it.
	 */</comment>
	<if>if <condition>(<expr>(<name>system_code</name> &lt; 0 &amp;&amp; <name>intern_code</name> &gt;= 1)
	    || (<name>system_code</name> &gt;= 0 &amp;&amp; <name>intern_code</name> != <name>system_code</name>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("systemWcwidthOk: broken system line-drawing wcwidth\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>oops</name> += (<name>samplepass</name> + 1)</expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
    }</block></for>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (<name>wchar_t</name>) <name>samplesize</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>system_code</name> =<init> <expr><call><name>wcwidth</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>intern_code</name> =<init> <expr><call><name>mk_wcwidth</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since mk_wcwidth() is designed to check for nonspacing characters,
	 * and has rough range-checks for double-width characters, it will
	 * generally not detect cases where a code has not been assigned.
	 *
	 * Some experimentation with GNU libc suggests that up to 1/4 of the
	 * codes would differ, simply because the runtime library would have a
	 * table listing the unassigned codes, and return -1 for those.  If
	 * mk_wcwidth() has no information about a code, it returns 1.  On the
	 * other hand, if the runtime returns a positive number, the two should
	 * agree.
	 *
	 * The "up to" is measured for 4k, 8k, 16k of data.  With only 1k, the
	 * number of differences was only 77.  However, that is only one
	 * system, and this is only a sanity check to avoid using broken
	 * libraries.
	 */</comment>
	<if>if <condition>(<expr>(<name>system_code</name> &lt; 0 &amp;&amp; <name>intern_code</name> &gt;= 1)
	    || (<name>system_code</name> &gt;= 0 &amp;&amp; <name>intern_code</name> != <name>system_code</name>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr>++<name>oops</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("systemWcwidthOk: %d/%d mismatches, allowed %d\n",
	   <name>oops</name>, <name>samplesize</name>, <name>samplepass</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>oops</name> &lt;= <name>samplepass</name>)</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WCWIDTH */</comment>

<function><type><name>void</name></type>
<name>decode_wcwidth</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>mode</name> =<init> <expr>((<name>xw</name>-&gt;<name>misc</name>.<name>cjk_width</name> ? 2 : 0)
		+ (<name>xw</name>-&gt;<name>misc</name>.<name>mk_width</name> ? 1 : 0)
		+ 1)</expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{
    <default>default:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCHAR_H</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCWIDTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><call><name>xtermEnvUTF8</name><argument_list>()</argument_list></call> &amp;&amp;
	    <call><name>systemWcwidthOk</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>mk_samplesize</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>mk_samplepass</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>my_wcwidth</name> = <name>wcwidth</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("using system wcwidth() function\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
	<comment type="block">/* FALLTHRU */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </default><case>case <expr>2</expr>:
	<expr_stmt><expr><name>my_wcwidth</name> = &amp;<name>mk_wcwidth</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("using MK wcwidth() function\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>3</expr>:
    </case><case>case <expr>4</expr>:
	<expr_stmt><expr><name>my_wcwidth</name> = &amp;<name>mk_wcwidth_cjk</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("using MK-CJK wcwidth() function\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>

    <for>for (<init><expr><name>first_widechar</name> = 128</expr>;</init> <condition><expr><name>first_widechar</name> &lt; 4500</expr>;</condition> <incr><expr>++<name>first_widechar</name></expr></incr>) <block>{
	<if>if <condition>(<expr><call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>int</name>) <name>first_widechar</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("first_widechar %#x\n", <name>first_widechar</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
    }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
