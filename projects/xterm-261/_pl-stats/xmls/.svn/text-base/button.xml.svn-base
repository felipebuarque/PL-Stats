<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" dir="" filename="button.c"><comment type="block">/* $XTermId: button.c,v 1.377 2010/06/04 09:27:07 tom Exp $ */</comment>

<comment type="block">/*
 * Copyright 1999-2009,2010 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */</comment>

<comment type="block">/*
button.c	Handles button events in the terminal emulator.
		does cut/paste operations, change modes via menu,
		passes button events through to some applications.
				J. Gettys.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xatom.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/Atoms.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/StdSel.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xutf8.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fontutils.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;data.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;error.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;menu.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xcharmouse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;charclass.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xstrings.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SELECT_REGEX</name></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PCREPOSIX_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pcreposix.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* POSIX regex.h */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;regex.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wcwidth.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CharacterClass</name>(value) \
	charClass[value &amp; ((sizeof(charClass)/sizeof(charClass[0]))-1)]</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * We'll generally map rows to indices when doing selection.
     * Simplify that with a macro.
     *
     * Note that ROW2INX() is safe to use with auto increment/decrement for
     * the row expression since that is evaluated once.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>GET_LINEDATA</name>(screen, row) \
	getLineData(screen, ROW2INX(screen, row))</cpp:define>

    <comment type="block">/*
     * We reserve shift modifier for cut/paste operations.  In principle we
     * can pass through control and meta modifiers, but in practice, the
     * popup menu uses control, and the window manager is likely to use meta,
     * so those events are not delivered to SendMousePosition.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>OurModifiers</name> (ShiftMask | ControlMask | Mod1Mask)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>AllModifiers</name> (ShiftMask | LockMask | ControlMask | Mod1Mask | \
		      Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>KeyModifiers</name> (event-&gt;xbutton.state &amp; OurModifiers)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>KeyState</name>(x) (((int) ((x) &amp; (ShiftMask|ControlMask))) \
			  + (((x) &amp; Mod1Mask) ? 2 : 0))</cpp:define>
    <comment type="block">/* adds together the bits:
       shift key -&gt; 1
       meta key  -&gt; 2
       control key -&gt; 4 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive>	<name>Coordinate</name>(s,c)	((c)-&gt;row * MaxCols(s) + (c)-&gt;col)</cpp:define>

<decl_stmt><decl><type><name>static</name> <name>const</name> <name>CELL</name></type> <name>zeroCELL</name> =<init>
<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>
<function_decl><type><name>static</name> <name>Bool</name></type> <name>SendLocatorPosition</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>CheckLocatorPosition</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_LOCATOR */</comment>

<comment type="block">/* Multi-click handling */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
<decl_stmt><decl><type><name>static</name> <name>Time</name></type> <name>lastButtonDownTime</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ExtendingSelection</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>Time</name></type> <name>lastButton3UpTime</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>Time</name></type> <name>lastButton3DoubleDownTime</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>CELL</name></type> <name>lastButton3</name></decl>;</decl_stmt>	<comment type="block">/* At the release time */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>

<function_decl><type><name>static</name> <name>Char</name> *</type><name>SaveText</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>scol</name></decl></param>, <param><decl><type><name>int</name></type> <name>ecol</name></decl></param>,
		      <param><decl><type><name>Char</name> *</type> <name>lp</name></decl></param>, <param><decl><type><name>int</name> *</type><name>eol</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>int</name></type> <name>Length</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>scol</name></decl></param>, <param><decl><type><name>int</name></type> <name>ecol</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>ComputeSelect</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>startc</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>endc</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>extend</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>EditorButton</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XButtonEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>EndExtend</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>w</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>, <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>, <param><decl><type><name>Cardinal</name></type>
		      <name>num_params</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>use_cursor_loc</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>ExtendExtend</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>PointToCELL</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>y</name></decl></param>, <param><decl><type><name>int</name></type> <name>x</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>ReHiliteText</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>first</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>last</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>SaltTextAway</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cellc</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>,
			 <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>num_params</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>SelectSet</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>, <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>num_params</name></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>static</name> <name>void</name> <name>SelectionReceived</name></type> <name>PROTO_XT_SEL_CB_ARGS</name></decl>;</decl_stmt>
<function_decl><type><name>static</name> <name>void</name></type> <name>StartSelect</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>TrackDown</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XButtonEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>TrackText</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>first</name></decl></param>, <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>last</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>_OwnSelection</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>String</name> *</type> <name>selections</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>count</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>do_select_end</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>, <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,
			  <param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>use_cursor_loc</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>Bool</name></type>
<name>SendMousePosition</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If send_mouse_pos mode isn't on, we shouldn't be here */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>MOUSE_OFF</name></expr>)</condition><then>
	<return>return <expr><name>False</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>DEC_LOCATOR</name></expr>)</condition><then> <block>{
	<return>return <expr>(<call><name>SendLocatorPosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call>)</expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_LOCATOR */</comment>

    <comment type="block">/* Make sure the event is an appropriate type */</comment>
    <if>if <condition>(<expr>(<name>screen</name>-&gt;<name>send_mouse_pos</name> != <name>BTN_EVENT_MOUSE</name>)
	&amp;&amp; (<name>screen</name>-&gt;<name>send_mouse_pos</name> != <name>ANY_EVENT_MOUSE</name>)
	&amp;&amp; <name>event</name>-&gt;<name>type</name> != <name>ButtonPress</name>
	&amp;&amp; <name>event</name>-&gt;<name>type</name> != <name>ButtonRelease</name></expr>)</condition><then>
	<return>return <expr><name>False</name></expr>;</return></then></if>

    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name></expr>)</condition> <block>{
    <case>case <expr><name>X10_MOUSE</name></expr>:		<comment type="block">/* X10 compatibility sequences */</comment>

	<if>if <condition>(<expr><name>KeyModifiers</name> == 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>EditorButton</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>XButtonEvent</name> *) <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <return>return <expr><name>True</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>False</name></expr>;</return>

    </case><case>case <expr><name>VT200_HIGHLIGHT_MOUSE</name></expr>:	<comment type="block">/* DEC vt200 hilite tracking */</comment>
	<if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name> &amp;&amp;
	    <name>KeyModifiers</name> == 0 &amp;&amp;
	    <name>event</name>-&gt;<name>xbutton</name>.<name>button</name> == <name>Button1</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TrackDown</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>XButtonEvent</name> *) <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>True</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>KeyModifiers</name> == 0 || <name>KeyModifiers</name> == <name>ControlMask</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>EditorButton</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>XButtonEvent</name> *) <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>True</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>False</name></expr>;</return>

    </case><case>case <expr><name>VT200_MOUSE</name></expr>:		<comment type="block">/* DEC vt200 compatible */</comment>

	<comment type="block">/* xterm extension for motion reporting. June 1998 */</comment>
	<comment type="block">/* EditorButton() will distinguish between the modes */</comment>
    </case><case>case <expr><name>BTN_EVENT_MOUSE</name></expr>:
    </case><case>case <expr><name>ANY_EVENT_MOUSE</name></expr>:
	<if>if <condition>(<expr><name>KeyModifiers</name> == 0 || <name>KeyModifiers</name> == <name>ControlMask</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>MotionNotify</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>((<name>XButtonEvent</name> *) <name>event</name>)-&gt;<name>button</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>EditorButton</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>XButtonEvent</name> *) <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>True</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name>False</name></expr>;</return>

    </case><default>default:
	<return>return <expr><name>False</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive>	<name>LocatorCoords</name>( row, col, x, y, oor )			\
    if( screen-&gt;locator_pixels ) {				\
	(oor)=False; (row) = (y)+1; (col) = (x)+1;		\
	<comment type="block">/* Limit to screen dimensions */</comment>			\
	if ((row) &lt; 1) (row) = 1,(oor)=True;			\
	else if ((row) &gt; screen-&gt;border*2+Height(screen))	\
	    (row) = screen-&gt;border*2+Height(screen),(oor)=True;	\
	if ((col) &lt; 1) (col) = 1,(oor)=True;			\
	else if ((col) &gt; OriginX(screen)*2+Width(screen))	\
	    (col) = OriginX(screen)*2+Width(screen),(oor)=True;	\
    } else {							\
	(oor)=False;						\
	<comment type="block">/* Compute character position of mouse pointer */</comment>	\
	(row) = ((y) - screen-&gt;border) / FontHeight(screen);	\
	(col) = ((x) - OriginX(screen)) / FontWidth(screen);	\
	<comment type="block">/* Limit to screen dimensions */</comment>			\
	if ((row) &lt; 0) (row) = 0,(oor)=True;			\
	else if ((row) &gt; screen-&gt;max_row)			\
	    (row) = screen-&gt;max_row,(oor)=True;			\
	if ((col) &lt; 0) (col) = 0,(oor)=True;			\
	else if ((col) &gt; screen-&gt;max_col)			\
	    (col) = screen-&gt;max_col,(oor)=True;			\
	(row)++; (col)++;					\
    }</cpp:define>

<function><type><name>static</name> <name>Bool</name></type>
<name>SendLocatorPosition</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ANSI</name></type> <name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name>, <name>col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>oor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>button</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure the event is an appropriate type */</comment>
    <if>if <condition>(<expr>(<name>event</name>-&gt;<name>type</name> != <name>ButtonPress</name> &amp;&amp;
	 <name>event</name>-&gt;<name>type</name> != <name>ButtonRelease</name> &amp;&amp;
	 !<name>screen</name>-&gt;<name>loc_filter</name>) ||
	(<name>KeyModifiers</name> != 0 &amp;&amp; <name>KeyModifiers</name> != <name>ControlMask</name>)</expr>)</condition><then>
	<return>return <expr>(<name>False</name>)</expr>;</return></then></if>

    <if>if <condition>(<expr>(<name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name> &amp;&amp;
	 !(<name>screen</name>-&gt;<name>locator_events</name> &amp; <name>LOC_BTNS_DN</name>)) ||
	(<name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name> &amp;&amp;
	 !(<name>screen</name>-&gt;<name>locator_events</name> &amp; <name>LOC_BTNS_UP</name>))</expr>)</condition><then>
	<return>return <expr>(<name>True</name>)</expr>;</return></then></if>

    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>MotionNotify</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>CheckLocatorPosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>True</name>)</expr>;</return>
    }</block></then></if>

    <comment type="block">/* get button # */</comment>
    <expr_stmt><expr><name>button</name> = (<name>int</name>) <name>event</name>-&gt;<name>xbutton</name>.<name>button</name> - 1</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LocatorCoords</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>oor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * DECterm mouse:
     *
     * ESCAPE '[' event ; mask ; row ; column '&amp;' 'w'
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>oor</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* Event - 0 = locator unavailable */</comment>
	<expr_stmt><expr><name>reply</name>.<name>a_inters</name> = '&amp;'</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'w'</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_reset</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>(<name>True</name>)</expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * event:
     *        1       no buttons
     *        2       left button down
     *        3       left button up
     *        4       middle button down
     *        5       middle button up
     *        6       right button down
     *        7       right button up
     *        8       M4 down
     *        9       M4 up
     */</comment>
    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 4</expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>event</name>-&gt;<name>type</name></expr>)</condition> <block>{
    <case>case <expr><name>ButtonPress</name></expr>:
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr>2 + (<name>button</name> &lt;&lt; 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>ButtonRelease</name></expr>:
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr>3 + (<name>button</name> &lt;&lt; 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><default>default:
	<return>return <expr>(<name>True</name>)</expr>;</return>
    </default>}</block></switch>
    <comment type="block">/*
     * mask:
     * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
     *                                 M4 down left down   middle down   right down
     *
     * Notice that Button1 (left) and Button3 (right) are swapped in the mask.
     * Also, mask should be the state after the button press/release,
     * X provides the state not including the button press/release.
     */</comment>
    <expr_stmt><expr><name>state</name> = (<name>event</name>-&gt;<name>xbutton</name>.<name>state</name>
	     &amp; (<name>Button1Mask</name> | <name>Button2Mask</name> | <name>Button3Mask</name> | <name>Button4Mask</name>)) &gt;&gt; 8</expr>;</expr_stmt>
    <comment type="block">/* update mask to "after" state */</comment>
    <expr_stmt><expr><name>state</name> ^= (<call>(<name>unsigned</name>) <argument_list>(<argument><expr>1 &lt;&lt; <name>button</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    <comment type="block">/* swap Button1 &amp; Button3 */</comment>
    <expr_stmt><expr><name>state</name> = ((<name>state</name> &amp; (<name>unsigned</name>) ~(4 | 1))
	     | ((<name>state</name> &amp; 1) ? 4 : 0)
	     | ((<name>state</name> &amp; 4) ? 1 : 0))</expr>;</expr_stmt>

    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = (<name>ParmType</name>) <name>state</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = (<name>ParmType</name>) <name>row</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>3</expr>]</index></name> = (<name>ParmType</name>) <name>col</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = '&amp;'</expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'w'</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_reset</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * DECterm turns the Locator off if a button is pressed while a filter rectangle
     * is active. This might be a bug, but I don't know, so I'll emulate it anyways.
     */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>loc_filter</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter</name> = <name>False</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>locator_events</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>(<name>True</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
 * mask:
 * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
 *                                 M4 down left down   middle down   right down
 *
 * Button1 (left) and Button3 (right) are swapped in the mask relative to X.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>	<name>ButtonState</name>(state, mask)	\
{ (state) = (int) (((mask) &amp; (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) &gt;&gt; 8);	\
  <comment type="block">/* swap Button1 &amp; Button3 */</comment>								\
  (state) = ((state) &amp; ~(4|1)) | (((state)&amp;1)?4:0) | (((state)&amp;4)?1:0);			\
}</cpp:define>

<function><type><name>void</name></type>
<name>GetLocatorPosition</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ANSI</name></type> <name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name></type> <name>root</name>, <name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rx</name>, <name>ry</name>, <name>x</name>, <name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr>0</expr>, <expr><name>col</name> = 0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>oor</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>ret</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/*
     * DECterm turns the Locator off if the position is requested while a filter rectangle
     * is active.  This might be a bug, but I don't know, so I'll emulate it anyways.
     */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>loc_filter</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter</name> = <name>False</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>locator_events</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>DEC_LOCATOR</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ret</name> = <call><name>XQueryPointer</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>root</name></expr></argument>,
			    <argument><expr>&amp;<name>child</name></expr></argument>, <argument><expr>&amp;<name>rx</name></expr></argument>, <argument><expr>&amp;<name>ry</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ret</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>LocatorCoords</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>oor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>ret</name> == <name>False</name> || <name>oor</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* Event - 0 = locator unavailable */</comment>
	<expr_stmt><expr><name>reply</name>.<name>a_inters</name> = '&amp;'</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'w'</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_reset</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>ButtonState</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 4</expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 1</expr>;</expr_stmt>	<comment type="block">/* Event - 1 = response to locator request */</comment>
    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = (<name>ParmType</name>) <name>state</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = (<name>ParmType</name>) <name>row</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>3</expr>]</index></name> = (<name>ParmType</name>) <name>col</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = '&amp;'</expr>;</expr_stmt>
    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'w'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_reset</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>InitLocatorFilter</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ANSI</name></type> <name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name></type> <name>root</name>, <name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rx</name>, <name>ry</name>, <name>x</name>, <name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr>0</expr>, <expr><name>col</name> = 0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>oor</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret</name> = <call><name>XQueryPointer</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr>&amp;<name>child</name></expr></argument>, <argument><expr>&amp;<name>rx</name></expr></argument>, <argument><expr>&amp;<name>ry</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ret</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>LocatorCoords</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>oor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>ret</name> == <name>False</name> || <name>oor</name></expr>)</condition><then> <block>{
	<comment type="block">/* Locator is unavailable */</comment>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>loc_filter_top</name> != <name>LOC_FILTER_POS</name> ||
	    <name>screen</name>-&gt;<name>loc_filter_left</name> != <name>LOC_FILTER_POS</name> ||
	    <name>screen</name>-&gt;<name>loc_filter_bottom</name> != <name>LOC_FILTER_POS</name> ||
	    <name>screen</name>-&gt;<name>loc_filter_right</name> != <name>LOC_FILTER_POS</name></expr>)</condition><then> <block>{
	    <comment type="block">/*
	     * If any explicit coordinates were received,
	     * report immediately with no coordinates.
	     */</comment>
	    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* Event - 0 = locator unavailable */</comment>
	    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = '&amp;'</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'w'</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_reset</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <block>{
	    <comment type="block">/*
	     * No explicit coordinates were received, and the pointer is
	     * unavailable.  Report when the pointer re-enters the window.
	     */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MotionOn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * Adjust rectangle coordinates:
     *  1. Replace "LOC_FILTER_POS" with current coordinates
     *  2. Limit coordinates to screen size
     *  3. make sure top and left are less than bottom and right, resp.
     */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_pixels</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>rx</name> = <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> * 2 + <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ry</name> = <name>screen</name>-&gt;<name>border</name> * 2 + <call><name>Height</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>rx</name> = <name>screen</name>-&gt;<name>max_col</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ry</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</expr_stmt>
    }</block></else></if>

<cpp:define>#<cpp:directive>define</cpp:directive>	<name>Adjust</name>( coord, def, max )				\
	if( (coord) == LOC_FILTER_POS )	(coord) = (def);	\
	else if ((coord) &lt; 1)		(coord) = 1;		\
	else if ((coord) &gt; (max))	(coord) = (max)</cpp:define>

    <expr_stmt><expr><call><name>Adjust</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>loc_filter_top</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>ry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Adjust</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>loc_filter_left</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>rx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Adjust</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>loc_filter_bottom</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>ry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Adjust</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>loc_filter_right</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>rx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>loc_filter_top</name> &gt; <name>screen</name>-&gt;<name>loc_filter_bottom</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ry</name> = <name>screen</name>-&gt;<name>loc_filter_top</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_top</name> = <name>screen</name>-&gt;<name>loc_filter_bottom</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_bottom</name> = <name>ry</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>loc_filter_left</name> &gt; <name>screen</name>-&gt;<name>loc_filter_right</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>rx</name> = <name>screen</name>-&gt;<name>loc_filter_left</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_left</name> = <name>screen</name>-&gt;<name>loc_filter_right</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_right</name> = <name>rx</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>col</name> &lt; <name>screen</name>-&gt;<name>loc_filter_left</name>) ||
	(<name>col</name> &gt; <name>screen</name>-&gt;<name>loc_filter_right</name>) ||
	(<name>row</name> &lt; <name>screen</name>-&gt;<name>loc_filter_top</name>) ||
	(<name>row</name> &gt; <name>screen</name>-&gt;<name>loc_filter_bottom</name>)</expr>)</condition><then> <block>{
	<comment type="block">/* Pointer is already outside the rectangle - report immediately */</comment>
	<expr_stmt><expr><call><name>ButtonState</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 4</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 10</expr>;</expr_stmt>	<comment type="block">/* Event - 10 = locator outside filter */</comment>
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = (<name>ParmType</name>) <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = (<name>ParmType</name>) <name>row</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>3</expr>]</index></name> = (<name>ParmType</name>) <name>col</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_inters</name> = '&amp;'</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'w'</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_reset</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * Rectangle is set up.  Allow pointer tracking
     * to detect if the mouse leaves the rectangle.
     */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter</name> = <name>True</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MotionOn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>CheckLocatorPosition</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ANSI</name></type> <name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name>, <name>col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>oor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LocatorCoords</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>oor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Send report if the pointer left the filter rectangle, if
     * the pointer left the window, or if the filter rectangle
     * had no coordinates and the pointer re-entered the window.
     */</comment>
    <if>if <condition>(<expr><name>oor</name> || (<name>screen</name>-&gt;<name>loc_filter_top</name> == <name>LOC_FILTER_POS</name>) ||
	(<name>col</name> &lt; <name>screen</name>-&gt;<name>loc_filter_left</name>) ||
	(<name>col</name> &gt; <name>screen</name>-&gt;<name>loc_filter_right</name>) ||
	(<name>row</name> &lt; <name>screen</name>-&gt;<name>loc_filter_top</name>) ||
	(<name>row</name> &gt; <name>screen</name>-&gt;<name>loc_filter_bottom</name>)</expr>)</condition><then> <block>{
	<comment type="block">/* Filter triggered - disable it */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter</name> = <name>False</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>oor</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* Event - 0 = locator unavailable */</comment>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>ButtonState</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 4</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 10</expr>;</expr_stmt>	<comment type="block">/* Event - 10 = locator outside filter */</comment>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = (<name>ParmType</name>) <name>state</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = (<name>ParmType</name>) <name>row</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>3</expr>]</index></name> = (<name>ParmType</name>) <name>col</name></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>reply</name>.<name>a_inters</name> = '&amp;'</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'w'</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>locator_reset</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_LOCATOR */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
<function><type><name>static</name> <name>int</name></type>
<name>isClick1_clean</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!(<name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name> || <name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name>)
    <comment type="block">/* Disable on Shift-Click-1, including the application-mouse modes */</comment>
	|| (<name>KeyModifiers</name> &amp; <name>ShiftMask</name>)
	|| (<name>screen</name>-&gt;<name>send_mouse_pos</name> != <name>MOUSE_OFF</name>)	<comment type="block">/* Kinda duplicate... */</comment>
	||<name>ExtendingSelection</name></expr>)</condition><then>	<comment type="block">/* Was moved */</comment>
	<return>return <expr>0</expr>;</return></then></if>

    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> != <name>ButtonRelease</name></expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>

    <if>if <condition>(<expr><name>lastButtonDownTime</name> == (<name>Time</name>) 0</expr>)</condition><then> <block>{
	<comment type="block">/* first time or once in a blue moon */</comment>
	<expr_stmt><expr><name>delta</name> = <name>screen</name>-&gt;<name>multiClickTime</name> + 1</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> &gt; <name>lastButtonDownTime</name></expr>)</condition><then> <block>{
	<comment type="block">/* most of the time */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> - <name>lastButtonDownTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* time has rolled over since lastButtonUpTime */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>(((<name>Time</name>) ~ 0) - <name>lastButtonDownTime</name>) + <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <return>return <expr><name>delta</name> &lt;= <name>screen</name>-&gt;<name>multiClickTime</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>isDoubleClick3</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> != <name>ButtonRelease</name>
	|| (<name>KeyModifiers</name> &amp; <name>ShiftMask</name>)
	|| <name>event</name>-&gt;<name>xbutton</name>.<name>button</name> != <name>Button3</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>lastButton3UpTime</name> = 0</expr>;</expr_stmt>	<comment type="block">/* Disable the cached info */</comment>
	<return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* Process Btn3Release. */</comment>
    <if>if <condition>(<expr><name>lastButton3DoubleDownTime</name> == (<name>Time</name>) 0</expr>)</condition><then> <block>{
	<comment type="block">/* No previous click or once in a blue moon */</comment>
	<expr_stmt><expr><name>delta</name> = <name>screen</name>-&gt;<name>multiClickTime</name> + 1</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> &gt; <name>lastButton3DoubleDownTime</name></expr>)</condition><then> <block>{
	<comment type="block">/* most of the time */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> - <name>lastButton3DoubleDownTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* time has rolled over since lastButton3DoubleDownTime */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>(((<name>Time</name>) ~ 0) - <name>lastButton3DoubleDownTime</name>) + <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <if>if <condition>(<expr><name>delta</name> &lt;= <name>screen</name>-&gt;<name>multiClickTime</name></expr>)</condition><then> <block>{
	<comment type="block">/* Double click */</comment>
	<decl_stmt><decl><type><name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* Cannot check ExtendingSelection, since mouse-3 always sets it */</comment>
	<expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;<name>cell</name></expr></argument>, <argument><expr>&amp;<name>lastButton3</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>lastButton3DoubleDownTime</name> = 0</expr>;</expr_stmt>	<comment type="block">/* Disable the third click */</comment>
	    <return>return <expr>1</expr>;</return>
	}</block></then></if>
    }</block></then></if>
    <comment type="block">/* Not a double click, memorize for future check. */</comment>
    <expr_stmt><expr><name>lastButton3UpTime</name> = <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>lastButton3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>CheckSecondPress3</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> != <name>ButtonPress</name>
	|| (<name>KeyModifiers</name> &amp; <name>ShiftMask</name>)
	|| <name>event</name>-&gt;<name>xbutton</name>.<name>button</name> != <name>Button3</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>lastButton3DoubleDownTime</name> = 0</expr>;</expr_stmt>	<comment type="block">/* Disable the cached info */</comment>
	<return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* Process Btn3Press. */</comment>
    <if>if <condition>(<expr><name>lastButton3UpTime</name> == (<name>Time</name>) 0</expr>)</condition><then> <block>{
	<comment type="block">/* No previous click or once in a blue moon */</comment>
	<expr_stmt><expr><name>delta</name> = <name>screen</name>-&gt;<name>multiClickTime</name> + 1</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> &gt; <name>lastButton3UpTime</name></expr>)</condition><then> <block>{
	<comment type="block">/* most of the time */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> - <name>lastButton3UpTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* time has rolled over since lastButton3UpTime */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>(((<name>Time</name>) ~ 0) - <name>lastButton3UpTime</name>) + <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <if>if <condition>(<expr><name>delta</name> &lt;= <name>screen</name>-&gt;<name>multiClickTime</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;<name>cell</name></expr></argument>, <argument><expr>&amp;<name>lastButton3</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* A candidate for a double-click */</comment>
	    <expr_stmt><expr><name>lastButton3DoubleDownTime</name> = <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>lastButton3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>1</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>lastButton3UpTime</name> = 0</expr>;</expr_stmt>	<comment type="block">/* Disable the info about the previous click */</comment>
    }</block></then></if>
    <comment type="block">/* Either too long, or moved, disable. */</comment>
    <expr_stmt><expr><name>lastButton3DoubleDownTime</name> = 0</expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>rowOnCurrentLine</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
		 <param><decl><type><name>int</name></type> <name>line</name></decl></param>,
		 <param><decl><type><name>int</name> *</type><name>deltap</name></decl></param>)</parameter_list>	<comment type="block">/* must be XButtonEvent */</comment>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l1</name>, <name>l2</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>deltap</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>line</name> != <name>screen</name>-&gt;<name>cur_row</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>line</name> &lt; <name>screen</name>-&gt;<name>cur_row</name></expr>)</condition><then>
	    <expr_stmt><expr><name>l1</name> = <name>line</name></expr>, <expr><name>l2</name> = <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>l2</name> = <name>line</name></expr>, <expr><name>l1</name> = <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>l1</name>--</expr>;</expr_stmt>
	<while>while <condition>(<expr>++<name>l1</name> &lt; <name>l2</name></expr>)</condition> <block>{
	    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr>!<call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block></while>
	<if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
	    <comment type="block">/* Everything is on one "wrapped line" now */</comment>
	    <expr_stmt><expr>*<name>deltap</name> = <name>line</name> - <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>eventRow</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>	<comment type="block">/* must be XButtonEvent */</comment>
<block>{
    <return>return <expr>(<name>event</name>-&gt;<name>xbutton</name>.<name>y</name> - <name>screen</name>-&gt;<name>border</name>) / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>eventColBetween</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>	<comment type="block">/* must be XButtonEvent */</comment>
<block>{
    <comment type="block">/* Correct by half a width - we are acting on a boundary, not on a cell. */</comment>
    <return>return <expr>((<name>event</name>-&gt;<name>xbutton</name>.<name>x</name> - <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + (<call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - 1) / 2)
	    / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>ReadLineMovePoint</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>, <param><decl><type><name>int</name></type> <name>ldelta</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Char</name></type> <name><name>line</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>col</name> += <name>ldelta</name> * <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>col</name> == 0</expr>)</condition><then>
	<return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>control_eight_bits</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = '['</expr>;</expr_stmt>	<comment type="block">/* XXX maybe sometimes O is better? */</comment>
    }</block></else></if>
    <expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name></expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>col</name> &gt; 0 ? 'C' : 'D'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>col</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>col</name> = -<name>col</name></expr>;</expr_stmt></then></if>
    <while>while <condition>(<expr><name>col</name>--</expr>)</condition>
	<expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>ReadLineDelete</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell1</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>del</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>del</name> = (<name>cell2</name>-&gt;<name>col</name> - <name>cell1</name>-&gt;<name>col</name>) + ((<name>cell2</name>-&gt;<name>row</name> - <name>cell1</name>-&gt;<name>row</name>) * <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>del</name> &lt;= 0</expr>)</condition><then>		<comment type="block">/* Just in case... */</comment>
	<return>return <expr>0</expr>;</return></then></if>
    <while>while <condition>(<expr><name>del</name>--</expr>)</condition>
	<expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>(<name>Char</name> *) "\177"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>

<comment type="block">/* ^XM-G&lt;line+' '&gt;&lt;col+' '&gt; */</comment>
<function><type><name>void</name></type>
<name>DiredButton</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
	    <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent */</comment>
	    <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,		<comment type="block">/* selections */</comment>
	    <param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name></type> <name><name>Line</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>line</name>, <name>col</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name> || <name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name>)
	    &amp;&amp; (<name>event</name>-&gt;<name>xbutton</name>.<name>y</name> &gt;= <name>screen</name>-&gt;<name>border</name>)
	    &amp;&amp; (<name>event</name>-&gt;<name>xbutton</name>.<name>x</name> &gt;= <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>line</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>event</name>-&gt;<name>xbutton</name>.<name>y</name> - <name>screen</name>-&gt;<name>border</name>)
			       / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>col</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>event</name>-&gt;<name>xbutton</name>.<name>x</name> - <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)
			      / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>Line</name><index>[<expr>0</expr>]</index></name> = <call><name>CONTROL</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>Line</name><index>[<expr>1</expr>]</index></name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>Line</name><index>[<expr>2</expr>]</index></name> = 'G'</expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>Line</name><index>[<expr>3</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>Line</name><index>[<expr>4</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>Line</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ReadLineButton</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
	       <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent */</comment>
	       <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,	<comment type="block">/* selections */</comment>
	       <param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name></type> <name><name>Line</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>line</name>, <name>col</name>, <name>ldelta</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!(<name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name> || <name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name>)
	    || (<name>screen</name>-&gt;<name>send_mouse_pos</name> != <name>MOUSE_OFF</name>) || <name>ExtendingSelection</name></expr>)</condition><then>
	    <goto>goto <name>finish</name>;</goto></then></if>
	<if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>lastButtonDownTime</name> == (<name>Time</name>) 0</expr>)</condition><then> <block>{
		<comment type="block">/* first time and once in a blue moon */</comment>
		<expr_stmt><expr><name>delta</name> = <name>screen</name>-&gt;<name>multiClickTime</name> + 1</expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> &gt; <name>lastButtonDownTime</name></expr>)</condition><then> <block>{
		<comment type="block">/* most of the time */</comment>
		<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name> - <name>lastButtonDownTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<comment type="block">/* time has rolled over since lastButtonUpTime */</comment>
		<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>(((<name>Time</name>) ~ 0) - <name>lastButtonDownTime</name>) + <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if></else></if>
	    <if>if <condition>(<expr><name>delta</name> &gt; <name>screen</name>-&gt;<name>multiClickTime</name></expr>)</condition><then>
		<goto>goto <name>finish</name>;</goto></then></if>	<comment type="block">/* All this work for this... */</comment>
	}</block></then></if>
	<expr_stmt><expr><name>line</name> = (<name>event</name>-&gt;<name>xbutton</name>.<name>y</name> - <name>screen</name>-&gt;<name>border</name>) / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>rowOnCurrentLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>&amp;<name>ldelta</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <goto>goto <name>finish</name>;</goto></then></if>
	<comment type="block">/* Correct by half a width - we are acting on a boundary, not on a cell. */</comment>
	<expr_stmt><expr><name>col</name> = (<name>event</name>-&gt;<name>xbutton</name>.<name>x</name> - <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + (<call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - 1)
	       / 2)
	    / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name> + <name>ldelta</name> * <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>col</name> == 0</expr>)</condition><then>
	    <goto>goto <name>finish</name>;</goto></then></if>
	<expr_stmt><expr><name><name>Line</name><index>[<expr>0</expr>]</index></name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
	<comment type="block">/* XXX: sometimes it is better to send '['? */</comment>
	<expr_stmt><expr><name><name>Line</name><index>[<expr>1</expr>]</index></name> = 'O'</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Line</name><index>[<expr>2</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>col</name> &gt; 0 ? 'C' : 'D'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>col</name> &lt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>col</name> = -<name>col</name></expr>;</expr_stmt></then></if>
	<while>while <condition>(<expr><name>col</name>--</expr>)</condition>
	    <expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>Line</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
      <label><name>finish</name>:</label>
	<if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>do_select_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>

<comment type="block">/* repeats &lt;ESC&gt;n or &lt;ESC&gt;p */</comment>
<function><type><name>void</name></type>
<name>ViButton</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
	 <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent */</comment>
	 <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,	<comment type="block">/* selections */</comment>
	 <param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pty</name> =<init> <expr><name>screen</name>-&gt;<name>respond</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name></type> <name><name>Line</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name> || <name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name></expr>)</condition><then> <block>{

	    <expr_stmt><expr><name>line</name> = <name>screen</name>-&gt;<name>cur_row</name> -
		((<name>event</name>-&gt;<name>xbutton</name>.<name>y</name> - <name>screen</name>-&gt;<name>border</name>) / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>line</name> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>Line</name><index>[<expr>0</expr>]</index></name> = <name>ANSI_ESC</name></expr>;</expr_stmt>	<comment type="block">/* force an exit from insert-mode */</comment>
		<expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>pty</name></expr></argument>, <argument><expr><name>Line</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>line</name> &lt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>line</name> = -<name>line</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>Line</name><index>[<expr>0</expr>]</index></name> = <call><name>CONTROL</name><argument_list>(<argument><expr>'n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><name><name>Line</name><index>[<expr>0</expr>]</index></name> = <call><name>CONTROL</name><argument_list>(<argument><expr>'p'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<while>while <condition>(<expr>--<name>line</name> &gt;= 0</expr>)</condition>
		    <expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>pty</name></expr></argument>, <argument><expr><name>Line</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	    }</block></then></if>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * This function handles button-motion events
 */</comment>
<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleSelectExtend</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		   <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XMotionEvent */</comment>
		   <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>screen</name>-&gt;<name>selection_time</name> = <name>event</name>-&gt;<name>xmotion</name>.<name>time</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name></expr>)</condition> <block>{
	    <comment type="block">/* If not in one of the DEC mouse-reporting modes */</comment>
	<case>case <expr><name>LEFTEXTENSION</name></expr>:
	</case><case>case <expr><name>RIGHTEXTENSION</name></expr>:
	    <expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xmotion</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xmotion</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ExtendExtend</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	    <comment type="block">/* If in motion reporting mode, send mouse position to
	       character process as a key sequence \E[M... */</comment>
	</case><case>case <expr><name>NORMAL</name></expr>:
	    <comment type="block">/* will get here if send_mouse_pos != MOUSE_OFF */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>BTN_EVENT_MOUSE</name>
		|| <name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>ANY_EVENT_MOUSE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>(<name>void</name>) <call><name>SendMousePosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
	</case>}</block></switch>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>HandleKeyboardSelectExtend</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
			   <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,	<comment type="block">/* must be XButtonEvent */</comment>
			   <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
			   <param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExtendExtend</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name>cursorp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>do_select_end</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	      <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent */</comment>
	      <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* selections */</comment>
	      <param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>,
	      <param><decl><type><name>Bool</name></type> <name>use_cursor_loc</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>ldelta1</name>, <name>ldelta2</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>selection_time</name> = <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name></expr>)</condition> <block>{
    <case>case <expr><name>NORMAL</name></expr>:
	<expr_stmt><expr>(<name>void</name>) <call><name>SendMousePosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>LEFTEXTENSION</name></expr>:
    </case><case>case <expr><name>RIGHTEXTENSION</name></expr>:
	<expr_stmt><expr><call><name>EndExtend</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr>*<name>num_params</name></expr></argument>, <argument><expr><name>use_cursor_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>isClick1_clean</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>click1_moves</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>rowOnCurrentLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>eventRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>ldelta1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ReadLineMovePoint</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>eventColBetween</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ldelta1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>isDoubleClick3</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dclick3_deletes</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>rowOnCurrentLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name></expr></argument>, <argument><expr>&amp;<name>ldelta1</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>rowOnCurrentLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name></expr></argument>, <argument><expr>&amp;<name>ldelta2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ReadLineMovePoint</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name></expr></argument>, <argument><expr><name>ldelta2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ReadLineDelete</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name>startSel</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>
	<break>break;</break>
    </case>}</block></switch>
}</block></function>

<function><type><name>void</name></type>
<name>HandleSelectEnd</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		<param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent */</comment>
		<param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* selections */</comment>
		<param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>do_select_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>HandleKeyboardSelectEnd</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
			<param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,		<comment type="block">/* must be XButtonEvent */</comment>
			<param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* selections */</comment>
			<param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>do_select_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<struct>struct <name>_SelectionList</name> <block>{
    <decl_stmt><decl><type><name>String</name> *</type><name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name> *</type><name>targets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Time</name></type> <name>time</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><name>static</name> <name>unsigned</name></type>
<name>DECtoASCII</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>ch</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>xtermIsDecGraphic</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr>"###########+++++##-##++++|######"<index>[<expr><name>ch</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*           01234567890123456789012345678901 */</comment>
    }</block></then></if>
    <return>return <expr><name>ch</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<function><type><name>static</name> <name>Cardinal</name></type>
<name>addXtermChar</name><parameter_list>(<param><decl><type><name>Char</name> **</type> <name>buffer</name></decl></param>, <param><decl><type><name>Cardinal</name> *</type><name>used</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>offset</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>offset</name> + 1 &gt;= *<name>used</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>used</name> = 1 + (2 * (<name>offset</name> + 1))</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>allocXtermChars</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>*<name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>(*<name>buffer</name>)<index>[<expr><name>offset</name>++</expr>]</index> = (<name>Char</name>) <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>AddChar</name>(buffer, used, offset, value) \
	offset = addXtermChar(buffer, used, offset, (unsigned) value)</cpp:define>

<comment type="block">/*
 * Convert a UTF-8 string to Latin-1, replacing non Latin-1 characters by `#',
 * or ASCII/Latin-1 equivalents for special cases.
 */</comment>
<function><type><name>static</name> <name>Char</name> *</type>
<name>UTF8toLatin1</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>s</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>Char</name> *</type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>Cardinal</name></type> <name>used</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Cardinal</name></type> <name>offset</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Char</name> *</type><name>p</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>PtyData</name></type> <name>data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fakePtyData</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name> + <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>decodeUtf8</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	    <decl_stmt><decl><type><name>Bool</name></type> <name>fails</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Bool</name></type> <name>extra</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>IChar</name></type> <name>value</name> =<init> <expr><call><name>skipPtyData</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>value</name> == <name>UCS_REPL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>fails</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr><name>value</name> &lt; 256</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>AddChar</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>used</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<decl_stmt><decl><type><name>unsigned</name></type> <name>eqv</name> =<init> <expr><call><name>ucs2dec</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>xtermIsDecGraphic</name><argument_list>(<argument><expr><name>eqv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>AddChar</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>used</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>DECtoASCII</name><argument_list>(<argument><expr><name>eqv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><name>eqv</name> = <call><name>AsciiEquivs</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>eqv</name> == <name>value</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>fails</name> = <name>True</name></expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>AddChar</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>used</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>eqv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></else></if>
		    <if>if <condition>(<expr><call><name>isWide</name><argument_list>(<argument><expr>(<name>wchar_t</name>) <name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>extra</name> = <name>True</name></expr>;</expr_stmt></then></if>
		}</block></else></if>
	    }</block></else></if></else></if>

	    <comment type="block">/*
	     * If we're not able to plug in a single-byte result, insert the
	     * defaultString (which normally is a single "#", but could be
	     * whatever the user wants).
	     */</comment>
	    <if>if <condition>(<expr><name>fails</name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>p</name> = (<name>Char</name> *) <name>screen</name>-&gt;<name>default_string</name></expr>;</init> <condition><expr>*<name>p</name> != '\0'</expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
		    <expr_stmt><expr><call><name>AddChar</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>used</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>extra</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>AddChar</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>used</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></while>
	<expr_stmt><expr><call><name>AddChar</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>used</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>result</name> = (<name>unsigned</name> <name>long</name>) (<name>offset</name> - 1)</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>buffer</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>xtermUtf8ToTextList</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		    <param><decl><type><name>XTextProperty</name> *</type> <name>text_prop</name></decl></param>,
		    <param><decl><type><name>char</name> ***</type><name>text_list</name></decl></param>,
		    <param><decl><type><name>int</name> *</type><name>text_list_count</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><name>screen</name>-&gt;<name>display</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>text_prop</name>-&gt;<name>format</name> == 8
	&amp;&amp; (<name>rc</name> = <call><name>Xutf8TextPropertyToTextList</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>text_prop</name></expr></argument>,
					     <argument><expr><name>text_list</name></expr></argument>,
					     <argument><expr><name>text_list_count</name></expr></argument>)</argument_list></call>) &gt;= 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>*<name>text_list</name> != <name>NULL</name> &amp;&amp; *<name>text_list_count</name> != 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Char</name> *</type><name>data</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>char</name> **</type><name>new_text_list</name>, *<name>tmp</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name>, <name>new_size</name></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermUtf8ToTextList size %d\n", *<name>text_list_count</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/*
	     * XLib StringList actually uses only two pointers, one for the
	     * list itself, and one for the data.  Pointer to the data is the
	     * first element of the list, the rest (if any) list elements point
	     * to the same memory block as the first element
	     */</comment>
	    <expr_stmt><expr><name>new_size</name> = 0</expr>;</expr_stmt>
	    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; *<name>text_list_count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>data</name> = (<name>Char</name> *) (*<name>text_list</name>)<index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> = <call><name>strlen</name><argument_list>(<argument><expr>(*<name>text_list</name>)<index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>) <call><name>UTF8toLatin1</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_size</name> += <name>size</name> + 1</expr>;</expr_stmt>
	    }</block></for>
	    <expr_stmt><expr><name>new_text_list</name> =
		(<name>char</name> **) <call><name>XtMalloc</name><argument_list>(<argument><expr>(<name>Cardinal</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call> * (<name>unsigned</name>) *<name>text_list_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>new_text_list</name><index>[<expr>0</expr>]</index></name> = <name>tmp</name> = <call><name>XtMalloc</name><argument_list>(<argument><expr>(<name>Cardinal</name>) <name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (*<name>text_list_count</name>)</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>data</name> = (<name>Char</name> *) (*<name>text_list</name>)<index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> = <call><name>strlen</name><argument_list>(<argument><expr>(*<name>text_list</name>)<index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> = <call><name>UTF8toLatin1</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_text_list</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> += <name>size</name> + 1</expr>;</expr_stmt>
	    }</block></for>
	    <expr_stmt><expr><call><name>XFreeStringList</name><argument_list>(<argument><expr>(*<name>text_list</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>text_list</name> = <name>new_text_list</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if>
    <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_WIDE_CHARS */</comment>

<function><type><name>static</name> <name>char</name> *</type>
<name>parseItem</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>char</name> *</type><name>nextc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>nextp</name> =<init> <expr><name>value</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr>*<name>nextp</name> != '\0' &amp;&amp; *<name>nextp</name> != ','</expr>)</condition> <block>{
	<expr_stmt><expr>*<name>nextp</name> = <call><name>x_toupper</name><argument_list>(<argument><expr>*<name>nextp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>++<name>nextp</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>nextc</name> = *<name>nextp</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>nextp</name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>x_strtrim</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>nextp</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * All of the wanted strings are unique in the first character, so we can
 * use simple abbreviations.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>sameItem</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>actual</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>wanted</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>have</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>need</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>wanted</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>have</name> != 0 &amp;&amp; <name>have</name> &lt;= <name>need</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>actual</name></expr></argument>, <argument><expr><name>wanted</name></expr></argument>, <argument><expr><name>have</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...matched \"%s\"\n", <name>wanted</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Handle the eightBitSelectTypes or utf8SelectTypes resource values.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>overrideTargets</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>, <param><decl><type><name>String</name></type> <name>value</name></decl></param>, <param><decl><type><name>Atom</name> **</type> <name>resultp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>override</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>IsEmpty</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>String</name></type> <name>copied</name> =<init> <expr><call><name>x_strdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>copied</name> != 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Atom</name> *</type><name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cardinal</name></type> <name>count</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("decoding SelectTypes \"%s\"\n", <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>copied</name><index>[<expr><name>n</name></expr>]</index></name> != '\0'</expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		    <if>if <condition>(<expr><name><name>copied</name><index>[<expr><name>n</name></expr>]</index></name> == ','</expr>)</condition><then>
			<expr_stmt><expr>++<name>count</name></expr>;</expr_stmt></then></if>
		}</block></for>
		<expr_stmt><expr><name>result</name> = (<name>Atom</name> *) <call><name>XtMalloc</name><argument_list>(<argument><expr>((2 * <name>count</name>) + 1)
					   * (<name>Cardinal</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>Atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Couldn't allocate selection types\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <decl_stmt><decl><type><name>char</name></type> <name>nextc</name> =<init> <expr>'?'</expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>char</name> *</type><name>listp</name> =<init> <expr>(<name>char</name> *) <name>copied</name></expr></init></decl>;</decl_stmt>
		    <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
		    <do>do <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>nextp</name> =<init> <expr><call><name>parseItem</name><argument_list>(<argument><expr><name>listp</name></expr></argument>, <argument><expr>&amp;<name>nextc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>listp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
			    <empty_stmt>;</empty_stmt>
			}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
			<else>else <if>if <condition>(<expr><call><name>sameItem</name><argument_list>(<argument><expr><name>listp</name></expr></argument>, <argument><expr>"UTF8"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name><name>result</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else <if>if <condition>(<expr><call><name>sameItem</name><argument_list>(<argument><expr><name>listp</name></expr></argument>, <argument><expr>"I18N"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <if>if <condition>(<expr><name>screen</name>-&gt;<name>i18nSelections</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>result</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>XA_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    }</block></then></if>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>sameItem</name><argument_list>(<argument><expr><name>listp</name></expr></argument>, <argument><expr>"TEXT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name><name>result</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>XA_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>sameItem</name><argument_list>(<argument><expr><name>listp</name></expr></argument>, <argument><expr>"COMPOUND_TEXT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name><name>result</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>sameItem</name><argument_list>(<argument><expr><name>listp</name></expr></argument>, <argument><expr>"STRING"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name><name>result</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>XA_STRING</name></expr>;</expr_stmt>
			}</block></then></if></else></if></else></if></else></if></else></if></else></if>
			<expr_stmt><expr>*<name>nextp</name>++ = <name>nextc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>listp</name> = <name>nextp</name></expr>;</expr_stmt>
		    }</block> while <condition>(<expr><name>nextc</name> != '\0'</expr>)</condition>;</do>
		    <if>if <condition>(<expr><name>count</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>result</name><index>[<expr><name>count</name></expr>]</index></name> = <name>None</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>override</name> = <name>True</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>resultp</name> = <name>result</name></expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></else></if>
		}</block></else></if>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Couldn't allocate copy of selection types\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>override</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<function><type><name>static</name> <name>Atom</name> *</type>
<name>allocUtf8Targets</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>, <param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Atom</name> **</type><name>resultp</name> =<init> <expr>&amp;(<name>screen</name>-&gt;<name>selection_targets_utf8</name>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>resultp</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Atom</name> *</type><name>result</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>overrideTargets</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>utf8_select_types</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = (<name>Atom</name> *) <call><name>XtMalloc</name><argument_list>(<argument><expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr>5 * <call><name>sizeof</name><argument_list>(<argument><expr><name>Atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Couldn't allocate utf-8 selection targets\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>X_HAVE_UTF8_STRING</name></cpp:ifdef>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>i18nSelections</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <call><name>XA_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>XA_STRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name></expr>]</index></name> = <name>None</name></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then></if>

	<expr_stmt><expr>*<name>resultp</name> = <name>result</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>*<name>resultp</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>Atom</name> *</type>
<name>alloc8bitTargets</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>, <param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Atom</name> **</type><name>resultp</name> =<init> <expr>&amp;(<name>screen</name>-&gt;<name>selection_targets_8bit</name>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>resultp</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Atom</name> *</type><name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>overrideTargets</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>eightbit_select_types</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = (<name>Atom</name> *) <call><name>XtMalloc</name><argument_list>(<argument><expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr>5 * <call><name>sizeof</name><argument_list>(<argument><expr><name>Atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Couldn't allocate 8bit selection targets\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>X_HAVE_UTF8_STRING</name></cpp:ifdef>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>i18nSelections</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <call><name>XA_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>XA_STRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name></expr>]</index></name> = <name>None</name></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then></if>

	<expr_stmt><expr>*<name>resultp</name> = <name>result</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>*<name>resultp</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Atom</name> *</type>
<name>_SelectionTargets</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Atom</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>screen</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <call><name>allocUtf8Targets</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
	    <comment type="block">/* not screen-&gt;wide_chars */</comment>
	    <expr_stmt><expr><name>result</name> = <call><name>alloc8bitTargets</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></else></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>isSELECT</name>(value) (!strcmp(value, "SELECT"))</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>UnmapSelections</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>mappedSelect</name></expr>)</condition><then> <block>{
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>screen</name>-&gt;<name><name>mappedSelect</name><index>[<expr><name>n</name></expr>]</index></name> != 0</expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr>(<name>void</name> *) <name>screen</name>-&gt;<name><name>mappedSelect</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>mappedSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>mappedSelect</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * xterm generally uses the primary selection.  Some applications prefer
 * (or are limited to) the clipboard.  Since the translations resource is
 * complicated, users seldom change the way it affects selection.  But it
 * is simple to remap the choice between primary and clipboard before the
 * call to XmuInternStrings().
 */</comment>
<function><type><name>static</name> <name>String</name> *</type>
<name>MapSelections</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>num_params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>String</name> *</type><name>result</name> =<init> <expr><name>params</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>num_params</name> &gt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Cardinal</name></type> <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Boolean</name></type> <name>map</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>num_params</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("param[%d]:%s\n", <name>j</name>, <name><name>params</name><index>[<expr><name>j</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>isSELECT</name><argument_list>(<argument><expr><name><name>params</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>map</name> = <name>True</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>map</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>mapTo</name> =<init> <expr>(<name>screen</name>-&gt;<name>selectToClipboard</name>
				 ? "CLIPBOARD"
				 : "PRIMARY")</expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>UnmapSelections</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>result</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>String</name></expr></argument>, <argument><expr><name>num_params</name> + 1</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>num_params</name></expr>]</index></name> = 0</expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>num_params</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
		    <expr_stmt><expr><name><name>result</name><index>[<expr><name>j</name></expr>]</index></name> = <call><name>x_strdup</name><argument_list>(<argument><expr>(<call><name>isSELECT</name><argument_list>(<argument><expr><name><name>params</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call>
					  ? <name>mapTo</name>
					  : <name><name>params</name><index>[<expr><name>j</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name><name>result</name><index>[<expr><name>j</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>UnmapSelections</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
			<break>break;</break>
		    }</block></then></if>
		}</block></for>
		<expr_stmt><expr><name>screen</name>-&gt;<name>mappedSelect</name> = <name>result</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Lookup the cut-buffer number, which will be in the range 0-7.
 * If it is not a cut-buffer, it is the primary selection (-1).
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>CutBuffer</name><parameter_list>(<param><decl><type><name>Atom</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>cutbuffer</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr>(<name>unsigned</name>) <name>code</name></expr>)</condition> <block>{
    <case>case <expr><name>XA_CUT_BUFFER0</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 0</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>XA_CUT_BUFFER1</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 1</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>XA_CUT_BUFFER2</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 2</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>XA_CUT_BUFFER3</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 3</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>XA_CUT_BUFFER4</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 4</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>XA_CUT_BUFFER5</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 5</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>XA_CUT_BUFFER6</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 6</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>XA_CUT_BUFFER7</name></expr>:
	<expr_stmt><expr><name>cutbuffer</name> = 7</expr>;</expr_stmt>
	<break>break;</break>
    </case><default>default:
	<expr_stmt><expr><name>cutbuffer</name> = -1</expr>;</expr_stmt>
	<break>break;</break>
    </default>}</block></switch>
    <return>return <expr><name>cutbuffer</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>FinishPaste64</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("FinishPaste64(%d)\n", <name>screen</name>-&gt;<name>base64_paste</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>base64_paste</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_paste</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>base64_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_PASTE64</name></expr></cpp:if>
<function><type><name>static</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>void</name></type>
<name>xtermGetSelection</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		  <param><decl><type><name>Time</name></type> <name>ev_time</name></decl></param>,
		  <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* selections in precedence order */</comment>
		  <param><decl><type><name>Cardinal</name></type> <name>num_params</name></decl></param>,
		  <param><decl><type><name>Atom</name> *</type> <name>targets</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Atom</name></type> <name>selection</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cutbuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name></type> <name>target</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>num_params</name> == 0</expr>)</condition><then>
	<return>return;</return></then></if>
    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermGetSelection num_params %d\n", <name>num_params</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>params</name> = <call><name>MapSelections</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XmuInternStrings</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr>(<name>Cardinal</name>) 1</expr></argument>, <argument><expr>&amp;<name>selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cutbuffer</name> = <call><name>CutBuffer</name><argument_list>(<argument><expr><name>selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Cutbuffer: %d, target: %s\n", <name>cutbuffer</name>,
	   (<name>targets</name>
	    ? <call><name>visibleSelectionTarget</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>targets</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>
	    : "None"))</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>cutbuffer</name> &gt;= 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>inbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fmt8</name> =<init> <expr>8</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Atom</name></type> <name>type</name> =<init> <expr><name>XA_STRING</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>line</name></decl>;</decl_stmt>

	<comment type="block">/* 'line' is freed in SelectionReceived */</comment>
	<expr_stmt><expr><name>line</name> = <call><name>XFetchBuffer</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>inbytes</name></expr></argument>, <argument><expr><name>cutbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> = (<name>unsigned</name> <name>long</name>) <name>inbytes</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>nbytes</name> &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>SelectionReceived</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>selection</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>(<name>XtPointer</name>) <name>line</name></expr></argument>,
			      <argument><expr>&amp;<name>nbytes</name></expr></argument>, <argument><expr>&amp;<name>fmt8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>num_params</name> &gt; 1</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>xtermGetSelection</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ev_time</name></expr></argument>, <argument><expr><name>params</name> + 1</expr></argument>, <argument><expr><name>num_params</name> - 1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
	<else>else <block>{
	    <expr_stmt><expr><call><name>FinishPaste64</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return;</return>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type>struct <name>_SelectionList</name> *</type><name>list</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>targets</name> == <name>NULL</name> || <name><name>targets</name><index>[<expr>0</expr>]</index></name> == <name>None</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>targets</name> = <call><name>_SelectionTargets</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>targets</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>target</name> = <name><name>targets</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name><name>targets</name><index>[<expr>1</expr>]</index></name> == <name>None</name></expr>)</condition><then> <block>{	<comment type="block">/* last target in list */</comment>
		<expr_stmt><expr><name>params</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>num_params</name>--</expr>;</expr_stmt>
		<expr_stmt><expr><name>targets</name> = <call><name>_SelectionTargets</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>targets</name> = &amp;(<name><name>targets</name><index>[<expr>1</expr>]</index></name>)</expr>;</expr_stmt>
	    }</block></else></if>

	    <if>if <condition>(<expr><name>num_params</name></expr>)</condition><then> <block>{
		<comment type="block">/* 'list' is freed in SelectionReceived */</comment>
		<expr_stmt><expr><name>list</name> = <call><name>XtNew</name><argument_list>(<argument>struct <expr><name>_SelectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>list</name> != 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>list</name>-&gt;<name>params</name> = <name>params</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>list</name>-&gt;<name>count</name> = <name>num_params</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>list</name>-&gt;<name>targets</name> = <name>targets</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>list</name>-&gt;<name>time</name> = <name>ev_time</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>
	    }</block></else></if>

	    <expr_stmt><expr><call><name>XtGetSelectionValue</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>selection</name></expr></argument>,
				<argument><expr><name>target</name></expr></argument>,
				<argument><expr><name>SelectionReceived</name></expr></argument>,
				<argument><expr>(<name>XtPointer</name>) <name>list</name></expr></argument>, <argument><expr><name>ev_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name> &amp;&amp; <name>OPT_WIDE_CHARS</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>GettingSelection</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>dpy</name></decl></param>, <param><decl><type><name>Atom</name></type> <name>type</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>line</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Char</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>name</name> = <call><name>XGetAtomName</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>TRACE</name><argument_list>(<argument>("Getting %s (%ld)\n", name, (long int) type)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <for>for (<init><expr><name>cp</name> = <name>line</name></expr>;</init> <condition><expr><name>cp</name> &lt; <name>line</name> + <name>len</name></expr>;</condition> <incr><expr><name>cp</name>++</expr></incr>) <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("[%d:%lu]", <call>(<name>int</name>) <argument_list>(<argument><expr><name>cp</name> + 1 - <name>line</name></expr></argument>)</argument_list></call>, <name>len</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>isprint</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%c\n", *<name>cp</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("\\x%02x\n", *<name>cp</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></for>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>GettingSelection</name>(dpy,type,line,len)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <name>tty_vwrite</name>(pty,lag,l)		tt_write(lag,l)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !( VMS ) */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <name>tty_vwrite</name>(pty,lag,l)		v_write(pty,lag,l)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined VMS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
<comment type="block">/* Return base64 code character given 6-bit number */</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>base64_code</name><index>[]</index></name> =<init> <expr>"\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz\
0123456789+/"</expr></init></decl>;</decl_stmt>
<function><type><name>static</name> <name>void</name></type>
<name>base64_flush</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Char</name></type> <name>x</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>base64_count</name></expr>)</condition> <block>{
    <case>case <expr>0</expr>:
	<break>break;</break>
    </case><case>case <expr>2</expr>:
	<expr_stmt><expr><name>x</name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>base64_code</name><index>[<expr><name>screen</name>-&gt;<name>base64_accu</name> &lt;&lt; 4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>4</expr>:
	<expr_stmt><expr><name>x</name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>base64_code</name><index>[<expr><name>screen</name>-&gt;<name>base64_accu</name> &lt;&lt; 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>base64_pad</name> &amp; 3</expr>)</condition><then>
	<expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>,
		   <argument><expr>(<name>Char</name> *) "==="</expr></argument>,
		   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>4 - (<name>screen</name>-&gt;<name>base64_pad</name> &amp; 3)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>base64_pad</name> = 0</expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_PASTE64 */</comment>

<function><type><name>static</name> <name>void</name></type>
<name>_qWriteSelectionData</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>lag</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>base64_paste</name></expr>)</condition><then> <block>{
	<comment type="block">/* Send data as base64 */</comment>
	<decl_stmt><decl><type><name>Char</name> *</type><name>p</name> =<init> <expr><name>lag</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name></type> <name><name>buf</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>x</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>length</name>--</expr>)</condition> <block>{
	    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>base64_count</name></expr>)</condition> <block>{
	    <case>case <expr>0</expr>:
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>x</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>base64_code</name><index>[<expr>*<name>p</name> &gt;&gt; 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr>*<name>p</name> &amp; 0x3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 2</expr>;</expr_stmt>
		<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr>2</expr>:
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>x</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>base64_code</name><index>[<expr>(<name>screen</name>-&gt;<name>base64_accu</name> &lt;&lt; 4) +
					      (*<name>p</name> &gt;&gt; 4)</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr>*<name>p</name> &amp; 0xF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 4</expr>;</expr_stmt>
		<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr>4</expr>:
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>x</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>base64_code</name><index>[<expr>(<name>screen</name>-&gt;<name>base64_accu</name> &lt;&lt; 2) +
					      (*<name>p</name> &gt;&gt; 6)</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>x</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>base64_code</name><index>[<expr>*<name>p</name> &amp; 0x3F</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case>}</block></switch>
	    <if>if <condition>(<expr><name>x</name> &gt;= 63</expr>)</condition><then> <block>{
		<comment type="block">/* Write 63 or 64 characters */</comment>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_pad</name> += <name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>
	}</block></while>
	<if>if <condition>(<expr><name>x</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>base64_pad</name> += <name>x</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_PASTE64 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_quotes</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<while>while <condition>(<expr><name>length</name>--</expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>(<name>Char</name> *) "\026"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Control-V */</comment>
	    <expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>lag</name>++</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>_WriteSelectionData</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>line</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Write data to pty a line at a time. */</comment>
    <comment type="block">/* Doing this one line at a time may no longer be necessary
       because v_write has been re-written. */</comment>

    <decl_stmt><decl><type><name>Char</name> *</type><name>lag</name>, *<name>end</name></decl>;</decl_stmt>

    <comment type="block">/* in the VMS version, if tt_pasting isn't set to True then qio
       reads aren't blocked and an infinite loop is entered, where the
       pasted text shows up as new input, goes in again, shows up
       again, ad nauseum. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
    <expr_stmt><expr><name>tt_pasting</name> = <name>True</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>end</name> = &amp;<name><name>line</name><index>[<expr><name>length</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lag</name> = <name>line</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>base64_paste</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>_qWriteSelectionData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>, <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>end</name> - <name>lag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>base64_flush</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
	<if>if <condition>(<expr>!<call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_literal_nl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Char</name> *</type><name>cp</name></decl>;</decl_stmt>
	    <for>for (<init><expr><name>cp</name> = <name>line</name></expr>;</init> <condition><expr><name>cp</name> != <name>end</name></expr>;</condition> <incr><expr><name>cp</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>cp</name> == '\n'</expr>)</condition><then> <block>{
		    <expr_stmt><expr>*<name>cp</name> = '\r'</expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>_qWriteSelectionData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>, <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>cp</name> - <name>lag</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>lag</name> = <name>cp</name> + 1</expr>;</expr_stmt>
		}</block></then></if>
	    }</block></for>
	}</block></then></if>

	<if>if <condition>(<expr><name>lag</name> != <name>end</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>_qWriteSelectionData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>, <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>end</name> - <name>lag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
    <expr_stmt><expr><name>tt_pasting</name> = <name>False</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tt_start_read</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* reenable reads or a character may be lost */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>_WriteKey</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>in</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Char</name></type> <name><name>line</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr>(<name>char</name> *) <name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>control_eight_bits</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = '['</expr>;</expr_stmt>
    }</block></else></if>
    <while>while <condition>(<expr><name>length</name>--</expr>)</condition>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = *<name>in</name>++</expr>;</expr_stmt></while>
    <expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = '~'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tty_vwrite</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>

<comment type="block">/* SelectionReceived: stuff received selection text into pty */</comment>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>SelectionReceived</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		  <param><decl><type><name>XtPointer</name></type> <name>client_data</name></decl></param>,
		  <param><decl><type><name>Atom</name> * <name>selection</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>Atom</name> *</type> <name>type</name></decl></param>,
		  <param><decl><type><name>XtPointer</name></type> <name>value</name></decl></param>,
		  <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>length</name></decl></param>,
		  <param><decl><type><name>int</name> *</type><name>format</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> **</type><name>text_list</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>text_list_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XTextProperty</name></type> <name>text_prop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name> &amp;&amp; <name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Char</name> *</type><name>line</name> =<init> <expr>(<name>Char</name> *) <name>value</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>screen</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dpy</name> = <call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>*<name>type</name> == 0		<comment type="block">/*XT_CONVERT_FAIL */</comment>
	|| *<name>length</name> == 0
	|| <name>value</name> == <name>NULL</name></expr>)</condition><then>
	<goto>goto <name>fail</name>;</goto></then></if>

    <expr_stmt><expr><name>text_prop</name>.<name>value</name> = (<name>unsigned</name> <name>char</name> *) <name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>text_prop</name>.<name>encoding</name> = *<name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>text_prop</name>.<name>format</name> = *<name>format</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>text_prop</name>.<name>nitems</name> = *<name>length</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("SelectionReceived %s format %d, nitems %ld\n",
	   <call><name>visibleSelectionTarget</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>text_prop</name>.<name>encoding</name></expr></argument>)</argument_list></call>,
	   <name>text_prop</name>.<name>format</name>,
	   <name>text_prop</name>.<name>nitems</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>*<name>type</name> == <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call> ||
	    *<name>type</name> == <name>XA_STRING</name> ||
	    *<name>type</name> == <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>GettingSelection</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>*<name>type</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>*<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>Xutf8TextPropertyToTextList</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>&amp;<name>text_prop</name></expr></argument>,
					    <argument><expr>&amp;<name>text_list</name></expr></argument>,
					    <argument><expr>&amp;<name>text_list_count</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Conversion failed\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>text_list</name> = <name>NULL</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_WIDE_CHARS */</comment>
    <block>{
	<comment type="block">/* Convert the selection to locale's multibyte encoding. */</comment>

	<if>if <condition>(<expr>*<name>type</name> == <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call> ||
	    *<name>type</name> == <name>XA_STRING</name> ||
	    *<name>type</name> == <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Status</name></type> <name>rc</name></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>GettingSelection</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>*<name>type</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>*<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <if>if <condition>(<expr>*<name>type</name> == <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call> &amp;&amp;
		!(<name>screen</name>-&gt;<name>wide_chars</name> || <name>screen</name>-&gt;<name>c1_printable</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>rc</name> = <call><name>xtermUtf8ToTextList</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>text_prop</name></expr></argument>,
					 <argument><expr>&amp;<name>text_list</name></expr></argument>, <argument><expr>&amp;<name>text_list_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr>*<name>type</name> == <name>XA_STRING</name> &amp;&amp; <name>screen</name>-&gt;<name>brokenSelections</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>rc</name> = <call><name>XTextPropertyToStringList</name><argument_list>(<argument><expr>&amp;<name>text_prop</name></expr></argument>,
					       <argument><expr>&amp;<name>text_list</name></expr></argument>, <argument><expr>&amp;<name>text_list_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>rc</name> = <call><name>XmbTextPropertyToTextList</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>&amp;<name>text_prop</name></expr></argument>,
					       <argument><expr>&amp;<name>text_list</name></expr></argument>,
					       <argument><expr>&amp;<name>text_list_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if></else></if>
	    <if>if <condition>(<expr><name>rc</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Conversion failed\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>text_list</name> = <name>NULL</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><name>text_list</name> != <name>NULL</name> &amp;&amp; <name>text_list_count</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>base64_paste</name></expr>)</condition><then> <block>{
	    <empty_stmt>;</empty_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_brackets</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>_WriteKey</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>Char</name> *) "200"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>text_list_count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>text_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>_WriteSelectionData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>Char</name> *) <name><name>text_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>base64_paste</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>FinishPaste64</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_brackets</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>_WriteKey</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>Char</name> *) "201"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>XFreeStringList</name><argument_list>(<argument><expr><name>text_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else
	<goto>goto <name>fail</name>;</goto></else></if>

    <expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>client_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>

  <label><name>fail</name>:</label>
    <if>if <condition>(<expr><name>client_data</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type>struct <name>_SelectionList</name> *</type><name>list</name> =<init> <expr>(struct <name>_SelectionList</name> *) <name>client_data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("SelectionReceived -&gt;xtermGetSelection\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermGetSelection</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>list</name>-&gt;<name>time</name></expr></argument>,
			  <argument><expr><name>list</name>-&gt;<name>params</name></expr></argument>, <argument><expr><name>list</name>-&gt;<name>count</name></expr></argument>, <argument><expr><name>list</name>-&gt;<name>targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>client_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>FinishPaste64</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>HandleInsertSelection</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		      <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* assumed to be XButtonEvent* */</comment>
		      <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* selections in precedence order */</comment>
		      <param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>!<call><name>SendMousePosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	    <decl_stmt><decl><type><name>int</name></type> <name>ldelta</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr>(<name>event</name>-&gt;<name>type</name> == <name>ButtonPress</name> || <name>event</name>-&gt;<name>type</name> == <name>ButtonRelease</name>)
	    <comment type="block">/* Disable on Shift-mouse, including the application-mouse modes */</comment>
		&amp;&amp; !(<name>KeyModifiers</name> &amp; <name>ShiftMask</name>)
		&amp;&amp; (<name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>MOUSE_OFF</name>)
		&amp;&amp; <call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_moves</name></expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>rowOnCurrentLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>eventRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>ldelta</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>ReadLineMovePoint</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>eventColBetween</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ldelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>

	    <expr_stmt><expr><call><name>xtermGetSelection</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr>*<name>num_params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>SelectUnit</name></type>
<name>EvalSelectUnit</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	       <param><decl><type><name>Time</name></type> <name>buttonDownTime</name></decl></param>,
	       <param><decl><type><name>SelectUnit</name></type> <name>defaultUnit</name></decl></param>,
	       <param><decl><type><name>unsigned</name> <name>int</name></type> <name>button</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SelectUnit</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>button</name> != <name>screen</name>-&gt;<name>lastButton</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>delta</name> = <name>screen</name>-&gt;<name>multiClickTime</name> + 1</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>lastButtonUpTime</name> == (<name>Time</name>) 0</expr>)</condition><then> <block>{
	<comment type="block">/* first time and once in a blue moon */</comment>
	<expr_stmt><expr><name>delta</name> = <name>screen</name>-&gt;<name>multiClickTime</name> + 1</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>buttonDownTime</name> &gt; <name>screen</name>-&gt;<name>lastButtonUpTime</name></expr>)</condition><then> <block>{
	<comment type="block">/* most of the time */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>buttonDownTime</name> - <name>screen</name>-&gt;<name>lastButtonUpTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* time has rolled over since lastButtonUpTime */</comment>
	<expr_stmt><expr><name>delta</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>(((<name>Time</name>) ~ 0) - <name>screen</name>-&gt;<name>lastButtonUpTime</name>) + <name>buttonDownTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <if>if <condition>(<expr><name>delta</name> &gt; <name>screen</name>-&gt;<name>multiClickTime</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>numberOfClicks</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <name>defaultUnit</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>result</name> = <name>screen</name>-&gt;<name><name>selectMap</name><index>[<expr><name>screen</name>-&gt;<name>numberOfClicks</name> % <name>screen</name>-&gt;<name>maxClicks</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>numberOfClicks</name> += 1</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("EvalSelectUnit(%d) = %d\n", <name>screen</name>-&gt;<name>numberOfClicks</name>, <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>do_select_start</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		<param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent* */</comment>
		<param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>SendMousePosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>selectUnit</name> = <call><name>EvalSelectUnit</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
					<argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr></argument>,
					<argument><expr><name>Select_CHAR</name></expr></argument>,
					<argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>button</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>replyToEmacs</name> = <name>False</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <expr_stmt><expr><name>lastButtonDownTime</name> = <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>StartSelect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleSelectStart</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		  <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent* */</comment>
		  <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>screen</name>-&gt;<name>firstValidRow</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>lastValidRow</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	<expr_stmt><expr><name>ExtendingSelection</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>do_select_start</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleKeyboardSelectStart</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
			  <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent* */</comment>
			  <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
			  <param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>do_select_start</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name>cursorp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>TrackDown</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XButtonEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>selectUnit</name> = <call><name>EvalSelectUnit</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
					<argument><expr><name>event</name>-&gt;<name>time</name></expr></argument>,
					<argument><expr><name>Select_CHAR</name></expr></argument>,
					<argument><expr><name>event</name>-&gt;<name>button</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>numberOfClicks</name> &gt; 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>x</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>replyToEmacs</name> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartSelect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>waitingForTrackInfo</name> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EditorButton</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>XButtonEvent</name> *) <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>boundsCheck</name>(x)	if (x &lt; 0) \
			    x = 0; \
			else if (x &gt;= screen-&gt;max_row) \
			    x = screen-&gt;max_row</cpp:define>

<function><type><name>void</name></type>
<name>TrackMouse</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>func</name></decl></param>,
	   <param><decl><type><name>CELL</name> *</type> <name>start</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>firstrow</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>lastrow</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>waitingForTrackInfo</name></expr>)</condition><then> <block>{	<comment type="block">/* if Timed, ignore */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>waitingForTrackInfo</name> = <name>False</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>func</name> != 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>CELL</name></type> <name>first</name> =<init> <expr>*<name>start</name></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>boundsCheck</name><argument_list>(<argument><expr><name>first</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>boundsCheck</name><argument_list>(<argument><expr><name>firstrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>boundsCheck</name><argument_list>(<argument><expr><name>lastrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>firstValidRow</name> = <name>firstrow</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>lastValidRow</name> = <name>lastrow</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>replyToEmacs</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>StartSelect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>StartSelect</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("StartSelect row=%d, col=%d\n", <name>cell</name>-&gt;<name>row</name>, <name>cell</name>-&gt;<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>numberOfClicks</name> == 1</expr>)</condition><then> <block>{
	<comment type="block">/* set start of selection */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>rawPos</name> = *<name>cell</name></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* else use old values in rawPos */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>saveStartR</name> = <name>screen</name>-&gt;<name>startExt</name> = <name>screen</name>-&gt;<name>rawPos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>saveEndR</name> = <name>screen</name>-&gt;<name>endExt</name> = <name>screen</name>-&gt;<name>rawPos</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call> &lt; <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>rawPos</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>LEFTEXTENSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startExt</name> = *<name>cell</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>RIGHTEXTENSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endExt</name> = *<name>cell</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>ComputeSelect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startExt</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endExt</name>)</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>EndExtend</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	  <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent */</comment>
	  <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* selections */</comment>
	  <param><decl><type><name>Cardinal</name></type> <name>num_params</name></decl></param>,
	  <param><decl><type><name>Bool</name></type> <name>use_cursor_loc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name></type> <name><name>line</name><index>[<expr>9</expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>use_cursor_loc</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>cell</name> = <name>screen</name>-&gt;<name>cursorp</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>ExtendExtend</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>lastButtonUpTime</name> = <name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>lastButton</name> = <name>event</name>-&gt;<name>xbutton</name>.<name>button</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>replyToEmacs</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>control_eight_bits</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = '['</expr>;</expr_stmt>
	    }</block></else></if>
	    <if>if <condition>(<expr><call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>rawPos</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call>
		&amp;&amp; <call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;<name>cell</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* Use short-form emacs select */</comment>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = 't'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>screen</name>-&gt;<name>endSel</name>.<name>col</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>screen</name>-&gt;<name>endSel</name>.<name>row</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<comment type="block">/* long-form, specify everything */</comment>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = 'T'</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>screen</name>-&gt;<name>startSel</name>.<name>col</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>screen</name>-&gt;<name>startSel</name>.<name>row</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>screen</name>-&gt;<name>endSel</name>.<name>col</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>screen</name>-&gt;<name>endSel</name>.<name>row</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>cell</name>.<name>col</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>cell</name>.<name>row</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TrackText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>zeroCELL</name></expr></argument>, <argument><expr>&amp;<name>zeroCELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>SelectSet</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>NORMAL</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>HandleSelectSet</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		<param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,
		<param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,
		<param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SelectSet</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr>*<name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>SelectSet</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	  <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
	  <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,
	  <param><decl><type><name>Cardinal</name></type> <name>num_params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("SelectSet\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Only do select stuff if non-null select */</comment>
    <if>if <condition>(<expr>!<call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SaltTextAway</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>DisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>Abs</name>(x)		((x) &lt; 0 ? -(x) : (x))</cpp:define>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>do_start_extend</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		<param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent* */</comment>
		<param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		<param><decl><type><name>Cardinal</name> *<name>num_params</name></type> <name>GCC_UNUSED</name></decl></param>,
		<param><decl><type><name>Bool</name></type> <name>use_cursor_loc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>coord</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>SendMousePosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>firstValidRow</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>lastValidRow</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <if>if <condition>(<expr>(<name>KeyModifiers</name> &amp; <name>ShiftMask</name>)
	|| <name>event</name>-&gt;<name>xbutton</name>.<name>button</name> != <name>Button3</name>
	|| !(<call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dclick3_deletes</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>screen</name>-&gt;<name>selectUnit</name> = <call><name>EvalSelectUnit</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
					    <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>time</name></expr></argument>,
					    <argument><expr><name>screen</name>-&gt;<name>selectUnit</name></expr></argument>,
					    <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>button</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>replyToEmacs</name> = <name>False</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <expr_stmt><expr><call><name>CheckSecondPress3</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>numberOfClicks</name> == 1
	|| (<call><name>SCREEN_FLAG</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dclick3_deletes</name></expr></argument>)</argument_list></call>	<comment type="block">/* Dclick special */</comment>
	    &amp;&amp;!(<name>KeyModifiers</name> &amp; <name>ShiftMask</name>))</expr>)</condition><then> <block>{
	<comment type="block">/* Save existing selection so we can reestablish it if the guy
	   extends past the other end of the selection */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>saveStartR</name> = <name>screen</name>-&gt;<name>startExt</name> = <name>screen</name>-&gt;<name>startRaw</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>saveEndR</name> = <name>screen</name>-&gt;<name>endExt</name> = <name>screen</name>-&gt;<name>endRaw</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* He just needed the selection mode changed, use old values. */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startExt</name> = <name>screen</name>-&gt;<name>startRaw</name> = <name>screen</name>-&gt;<name>saveStartR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endExt</name> = <name>screen</name>-&gt;<name>endRaw</name> = <name>screen</name>-&gt;<name>saveEndR</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name>use_cursor_loc</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>cell</name> = <name>screen</name>-&gt;<name>cursorp</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>PointToCELL</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>y</name></expr></argument>, <argument><expr><name>event</name>-&gt;<name>xbutton</name>.<name>x</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>coord</name> = <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>coord</name> - <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	&lt; <call><name>Abs</name><argument_list>(<argument><expr><name>coord</name> - <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
	|| <name>coord</name> &lt; <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* point is close to left side of selection */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>LEFTEXTENSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startExt</name> = <name>cell</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* point is close to left side of selection */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>RIGHTEXTENSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endExt</name> = <name>cell</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>ComputeSelect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startExt</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endExt</name>)</expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <if>if <condition>(<expr>!<call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>ExtendingSelection</name> = 1</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>ExtendExtend</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>coord</name> =<init> <expr><call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ExtendExtend row=%d, col=%d\n", <name>cell</name>-&gt;<name>row</name>, <name>cell</name>-&gt;<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> == <name>LEFTEXTENSION</name>
	&amp;&amp; ((<name>coord</name> + (<name>screen</name>-&gt;<name>selectUnit</name> != <name>Select_CHAR</name>))
	    &gt; <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<comment type="block">/* Whoops, he's changed his mind.  Do RIGHTEXTENSION */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>RIGHTEXTENSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startExt</name> = <name>screen</name>-&gt;<name>saveStartR</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> == <name>RIGHTEXTENSION</name>
	       &amp;&amp; <name>coord</name> &lt; <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* Whoops, he's changed his mind.  Do LEFTEXTENSION */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>LEFTEXTENSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endExt</name> = <name>screen</name>-&gt;<name>saveEndR</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> == <name>LEFTEXTENSION</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>startExt</name> = *<name>cell</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>endExt</name> = *<name>cell</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>ComputeSelect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startExt</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endExt</name>)</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <if>if <condition>(<expr>!<call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>ExtendingSelection</name> = 1</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name>HandleStartExtend</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		  <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent* */</comment>
		  <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* unused */</comment>
		  <param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>)</parameter_list>		<comment type="block">/* unused */</comment>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>do_start_extend</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>HandleKeyboardStartExtend</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
			  <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,	<comment type="block">/* must be XButtonEvent* */</comment>
			  <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* unused */</comment>
			  <param><decl><type><name>Cardinal</name> *</type><name>num_params</name></decl></param>)</parameter_list>		<comment type="block">/* unused */</comment>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>do_start_extend</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>ScrollSelection</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>amount</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>always</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>minrow</name> =<init> <expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>-<name>screen</name>-&gt;<name>savedlines</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxrow</name> =<init> <expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxcol</name> =<init> <expr><name>screen</name>-&gt;<name>max_col</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>scroll_update_one</name>(cell) \
	(cell)-&gt;row += amount; \
	if ((cell)-&gt;row &lt; minrow) { \
	    (cell)-&gt;row = minrow; \
	    (cell)-&gt;col = 0; \
	} \
	if ((cell)-&gt;row &gt; maxrow) { \
	    (cell)-&gt;row = maxrow; \
	    (cell)-&gt;col = maxcol; \
	}</cpp:define>

    <expr_stmt><expr><call><name>scroll_update_one</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>startRaw</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scroll_update_one</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>endRaw</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scroll_update_one</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scroll_update_one</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>scroll_update_one</name><argument_list>(<argument><expr>&amp;(<name>screen</name>-&gt;<name>rawPos</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are told to scroll the selection but it lies outside the scrolling
     * margins, then that could cause the selection to move (bad).  It is not
     * simple to fix, because this function is called both for the scrollbar
     * actions as well as application scrolling.  The 'always' flag is set in
     * the former case.  The rest of the logic handles the latter.
     */</comment>
    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>adjust</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>adjust</name> = <call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>startH</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>always</name>
	    || !<call><name>ScrnHaveLineMargins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	    || <call><name>ScrnIsLineInMargins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>adjust</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>scroll_update_one</name><argument_list>(<argument><expr>&amp;<name>screen</name>-&gt;<name>startH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>adjust</name> = <call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>endH</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>always</name>
	    || !<call><name>ScrnHaveLineMargins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	    || <call><name>ScrnIsLineInMargins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>adjust</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>scroll_update_one</name><argument_list>(<argument><expr>&amp;<name>screen</name>-&gt;<name>endH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>startHCoord</name> = <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name>startH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>endHCoord</name> = <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name>endH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>ResizeSelection</name><parameter_list>(<param><decl><type><name>TScreen</name> * <name>screen</name></type> <name>GCC_UNUSED</name></decl></param>, <param><decl><type><name>int</name></type> <name>rows</name></decl></param>, <param><decl><type><name>int</name></type> <name>cols</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>rows</name>--</expr>;</expr_stmt>			<comment type="block">/* decr to get 0-max */</comment>
    <expr_stmt><expr><name>cols</name>--</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>startRaw</name>.<name>row</name> &gt; <name>rows</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startRaw</name>.<name>row</name> = <name>rows</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name> &gt; <name>rows</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name> = <name>rows</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>endRaw</name>.<name>row</name> &gt; <name>rows</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endRaw</name>.<name>row</name> = <name>rows</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name> &gt; <name>rows</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name> = <name>rows</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>rawPos</name>.<name>row</name> &gt; <name>rows</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>rawPos</name>.<name>row</name> = <name>rows</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>startRaw</name>.<name>col</name> &gt; <name>cols</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startRaw</name>.<name>col</name> = <name>cols</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> &gt; <name>cols</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> = <name>cols</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>endRaw</name>.<name>col</name> &gt; <name>cols</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endRaw</name>.<name>col</name> = <name>cols</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> &gt; <name>cols</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> = <name>cols</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>rawPos</name>.<name>col</name> &gt; <name>cols</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>rawPos</name>.<name>col</name> = <name>cols</name></expr>;</expr_stmt></then></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<function><type><name>Bool</name></type>
<name>iswide</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<name>i</name> == <name>HIDDEN_CHAR</name>) || (<call><name>WideCells</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> == 2)</expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>isWideCell</name>(row, col) iswide((int)XTERM_CELL(row, col))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>void</name></type>
<name>PointToCELL</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>y</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>x</name></decl></param>,
	    <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<comment type="block">/* Convert pixel coordinates to character coordinates.
   Rows are clipped between firstValidRow and lastValidRow.
   Columns are clipped between to be 0 or greater, but are not clipped to some
       maximum value. */</comment>
<block>{
    <expr_stmt><expr><name>cell</name>-&gt;<name>row</name> = (<name>y</name> - <name>screen</name>-&gt;<name>border</name>) / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cell</name>-&gt;<name>row</name> &lt; <name>screen</name>-&gt;<name>firstValidRow</name></expr>)</condition><then>
	<expr_stmt><expr><name>cell</name>-&gt;<name>row</name> = <name>screen</name>-&gt;<name>firstValidRow</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>cell</name>-&gt;<name>row</name> &gt; <name>screen</name>-&gt;<name>lastValidRow</name></expr>)</condition><then>
	<expr_stmt><expr><name>cell</name>-&gt;<name>row</name> = <name>screen</name>-&gt;<name>lastValidRow</name></expr>;</expr_stmt></then></if></else></if>
    <expr_stmt><expr><name>cell</name>-&gt;<name>col</name> = (<name>x</name> - <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>) / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cell</name>-&gt;<name>col</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>cell</name>-&gt;<name>col</name> = 0</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>cell</name>-&gt;<name>col</name> &gt; <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>cell</name>-&gt;<name>col</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <comment type="block">/*
     * If we got a click on the right half of a doublewidth character,
     * pretend it happened on the left half.
     */</comment>
    <if>if <condition>(<expr><name>cell</name>-&gt;<name>col</name> &gt; 0
	&amp;&amp; <call><name>isWideCell</name><argument_list>(<argument><expr><name>cell</name>-&gt;<name>row</name></expr></argument>, <argument><expr><name>cell</name>-&gt;<name>col</name> - 1</expr></argument>)</argument_list></call>
	&amp;&amp; (<call><name>XTERM_CELL</name><argument_list>(<argument><expr><name>cell</name>-&gt;<name>row</name></expr></argument>, <argument><expr><name>cell</name>-&gt;<name>col</name></expr></argument>)</argument_list></call> == <name>HIDDEN_CHAR</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>cell</name>-&gt;<name>col</name> -= 1</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
 * Find the last column at which text was drawn on the given row.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>LastTextCol</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>LineData</name> *</type> <name>ld</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>ch</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ld</name> != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>okScrnRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <for>for (<init><expr><name>i</name> = <name>screen</name>-&gt;<name>max_col</name></expr>,
		 <expr><name>ch</name> = <name>ld</name>-&gt;<name>attribs</name> + <name>i</name></expr>;</init>
		 <condition><expr><name>i</name> &gt;= 0 &amp;&amp; !(*<name>ch</name> &amp; <name>CHARDRAWN</name>)</expr>;</condition>
		 <incr><expr><name>ch</name>--</expr>, <expr><name>i</name>--</expr></incr>) <block>{
		<empty_stmt>;</empty_stmt>
	    }</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name> *= 2</expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr>(<name>i</name>)</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
** double click table for cut and paste in 8 bits
**
** This table is divided in four parts :
**
**	- control characters	[0,0x1f] U [0x80,0x9f]
**	- separators		[0x20,0x3f] U [0xa0,0xb9]
**	- binding characters	[0x40,0x7f] U [0xc0,0xff]
**	- exceptions
*/</comment>
<comment type="block">/* *INDENT-OFF* */</comment>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name><name>charClass</name><index>[<expr>256</expr>]</index></name> =<init>
<expr><block>{
<comment type="block">/* NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL */</comment>
    <expr>32</expr>,  <expr>1</expr>,    <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/*  BS   HT   NL   VT   NP   CR   SO   SI */</comment>
     <expr>1</expr>,  <expr>32</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/* DLE  DC1  DC2  DC3  DC4  NAK  SYN  ETB */</comment>
     <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/* CAN   EM  SUB  ESC   FS   GS   RS   US */</comment>
     <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/*  SP    !    "    #    $    %    &amp;    ' */</comment>
    <expr>32</expr>,  <expr>33</expr>,  <expr>34</expr>,  <expr>35</expr>,  <expr>36</expr>,  <expr>37</expr>,  <expr>38</expr>,  <expr>39</expr>,
<comment type="block">/*   (    )    *    +    ,    -    .    / */</comment>
    <expr>40</expr>,  <expr>41</expr>,  <expr>42</expr>,  <expr>43</expr>,  <expr>44</expr>,  <expr>45</expr>,  <expr>46</expr>,  <expr>47</expr>,
<comment type="block">/*   0    1    2    3    4    5    6    7 */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   8    9    :    ;    &lt;    =    &gt;    ? */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>58</expr>,  <expr>59</expr>,  <expr>60</expr>,  <expr>61</expr>,  <expr>62</expr>,  <expr>63</expr>,
<comment type="block">/*   @    A    B    C    D    E    F    G */</comment>
    <expr>64</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   H    I    J    K    L    M    N    O */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   P    Q    R    S    T    U    V    W */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   X    Y    Z    [    \    ]    ^    _ */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>91</expr>,  <expr>92</expr>,  <expr>93</expr>,  <expr>94</expr>,  <expr>48</expr>,
<comment type="block">/*   `    a    b    c    d    e    f    g */</comment>
    <expr>96</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   h    i    j    k    l    m    n    o */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   p    q    r    s    t    u    v    w */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   x    y    z    {    |    }    ~  DEL */</comment>
    <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>, <expr>123</expr>, <expr>124</expr>, <expr>125</expr>, <expr>126</expr>,   <expr>1</expr>,
<comment type="block">/* x80  x81  x82  x83  IND  NEL  SSA  ESA */</comment>
    <expr>1</expr>,    <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/* HTS  HTJ  VTS  PLD  PLU   RI  SS2  SS3 */</comment>
    <expr>1</expr>,    <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/* DCS  PU1  PU2  STS  CCH   MW  SPA  EPA */</comment>
    <expr>1</expr>,    <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/* x98  x99  x9A  CSI   ST  OSC   PM  APC */</comment>
    <expr>1</expr>,    <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,
<comment type="block">/*   -    i   c/    L   ox   Y-    |   So */</comment>
    <expr>160</expr>, <expr>161</expr>, <expr>162</expr>, <expr>163</expr>, <expr>164</expr>, <expr>165</expr>, <expr>166</expr>, <expr>167</expr>,
<comment type="block">/*  ..   c0   ip   &lt;&lt;    _        R0    - */</comment>
    <expr>168</expr>, <expr>169</expr>, <expr>170</expr>, <expr>171</expr>, <expr>172</expr>, <expr>173</expr>, <expr>174</expr>, <expr>175</expr>,
<comment type="block">/*   o   +-    2    3    '    u   q|    . */</comment>
    <expr>176</expr>, <expr>177</expr>, <expr>178</expr>, <expr>179</expr>, <expr>180</expr>, <expr>181</expr>, <expr>182</expr>, <expr>183</expr>,
<comment type="block">/*   ,    1    2   &gt;&gt;  1/4  1/2  3/4    ? */</comment>
    <expr>184</expr>, <expr>185</expr>, <expr>186</expr>, <expr>187</expr>, <expr>188</expr>, <expr>189</expr>, <expr>190</expr>, <expr>191</expr>,
<comment type="block">/*  A`   A'   A^   A~   A:   Ao   AE   C, */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*  E`   E'   E^   E:   I`   I'   I^   I: */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*  D-   N~   O`   O'   O^   O~   O:    X */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>, <expr>215</expr>,
<comment type="block">/*  O/   U`   U'   U^   U:   Y'    P    B */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*  a`   a'   a^   a~   a:   ao   ae   c, */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*  e`   e'   e^   e:    i`  i'   i^   i: */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,
<comment type="block">/*   d   n~   o`   o'   o^   o~   o:   -: */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>, <expr>247</expr>,
<comment type="block">/*  o/   u`   u'   u^   u:   y'    P   y: */</comment>
     <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>,  <expr>48</expr>}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* *INDENT-ON* */</comment>

<function><type><name>int</name></type>
<name>SetCharacterClassRange</name><parameter_list>(<param><decl><type><name>int</name></type> <name>low</name></decl></param>,	<comment type="block">/* in range of [0..255] */</comment>
		       <param><decl><type><name>int</name></type> <name>high</name></decl></param>,
		       <param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>	<comment type="block">/* arbitrary */</comment>
<block>{

    <if>if <condition>(<expr><name>low</name> &lt; 0 || <name>high</name> &gt; 255 || <name>high</name> &lt; <name>low</name></expr>)</condition><then>
	<return>return <expr>(-1)</expr>;</return></then></if>

    <for>for (<init>;</init> <condition><expr><name>low</name> &lt;= <name>high</name></expr>;</condition> <incr><expr><name>low</name>++</expr></incr>)
	<expr_stmt><expr><name><name>charClass</name><index>[<expr><name>low</name></expr>]</index></name> = <name>value</name></expr>;</expr_stmt></for>

    <return>return <expr>(0)</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>int</name></type>
<name>class_of</name><parameter_list>(<param><decl><type><name>LineData</name> *</type> <name>ld</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>CELL</name></type> <name>temp</name> =<init> <expr>*<name>cell</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>temp</name>.<name>col</name> /= 2</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>temp</name>.<name>col</name> &lt; <name>ld</name>-&gt;<name>lineSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>CharacterClass</name><argument_list>(<argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>temp</name>.<name>col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CClassSelects</name>(name, cclass) \
	 (CClassOf(name) == cclass \
	 || XTERM_CELL(screen-&gt;name.row, screen-&gt;name.col) == HIDDEN_CHAR)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CClassSelects</name>(name, cclass) \
	 (class_of(ld.name, &amp;((screen-&gt;name))) == cclass)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>CClassOf</name>(name) class_of(ld.name, &amp;((screen-&gt;name)))</cpp:define>

<comment type="block">/*
 * If the given column is past the end of text on the given row, bump to the
 * beginning of the next line.
 */</comment>
<function><type><name>static</name> <name>Boolean</name></type>
<name>okPosition</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
	   <param><decl><type><name>LineData</name> **</type> <name>ld</name></decl></param>,
	   <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Boolean</name></type> <name>result</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>cell</name>-&gt;<name>row</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>cell</name>-&gt;<name>col</name> &gt; (<call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>*<name>ld</name></expr></argument>, <argument><expr><name>cell</name>-&gt;<name>row</name></expr></argument>)</argument_list></call> + 1)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>cell</name>-&gt;<name>row</name> &lt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>cell</name>-&gt;<name>col</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>++<name>cell</name>-&gt;<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if></else></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>trimLastLine</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
	     <param><decl><type><name>LineData</name> **</type> <name>ld</name></decl></param>,
	     <param><decl><type><name>CELL</name> *</type> <name>last</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cutNewline</name> &amp;&amp; <name>last</name>-&gt;<name>row</name> &lt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>last</name>-&gt;<name>col</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>++<name>last</name>-&gt;<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>last</name>-&gt;<name>col</name> = <call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>*<name>ld</name></expr></argument>, <argument><expr><name>last</name>-&gt;<name>row</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SELECT_REGEX</name></expr></cpp:if>
<comment type="block">/*
 * Returns the first row of a wrapped line.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>firstRowOfLine</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>visible</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>limit</name> =<init> <expr><name>visible</name> ? 0 : -<name>screen</name>-&gt;<name>savedlines</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>row</name> &gt; <name>limit</name> &amp;&amp;
	   (<name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name> - 1</expr></argument>)</argument_list></call>) != 0 &amp;&amp;
	   <call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<expr_stmt><expr>--<name>row</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>row</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Returns the last row of a wrapped line.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>lastRowOfLine</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>row</name> &lt; <name>screen</name>-&gt;<name>max_row</name> &amp;&amp;
	   (<name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp;
	   <call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<expr_stmt><expr>++<name>row</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>row</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Returns the number of cells on the range of rows.
 */</comment>
<function><type><name>static</name> <name>unsigned</name></type>
<name>lengthOfLines</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>firstRow</name></decl></param>, <param><decl><type><name>int</name></type> <name>lastRow</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>length</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>n</name> = <name>firstRow</name></expr>;</init> <condition><expr><name>n</name> &lt;= <name>lastRow</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>value</name> =<init> <expr><call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>value</name> &gt;= 0</expr>)</condition><then>
	    <expr_stmt><expr><name>length</name> += <call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>value</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <return>return <expr><name>length</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Make a copy of the wrapped-line which corresponds to the given row as a
 * string of bytes.  Construct an index for the columns from the beginning of
 * the line.
 */</comment>
<function><type><name>static</name> <name>char</name> *</type>
<name>make_indexed_text</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>length</name></decl></param>, <param><decl><type><name>int</name> *</type><name>indexed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Char</name> *</type><name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>need</name> =<init> <expr>(<name>length</name> + 1)</expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Get a quick upper bound to the number of bytes needed, if the whole
     * string were UTF-8.
     */</comment>
    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	need *= ((screen-&gt;lineExtra + 1) * 6);
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr>(<name>result</name> = <call><name>TypeCallocN</name><argument_list>(<argument><expr><name>Char</name></expr></argument>, <argument><expr><name>need</name> + 1</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>used</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name> *</type><name>last</name> =<init> <expr><name>result</name></expr></init></decl>;</decl_stmt>

	<do>do <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>limit</name> =<init> <expr><call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <while>while <condition>(<expr><name>col</name> &lt;= <name>limit</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>Char</name> *</type><name>next</name> =<init> <expr><name>last</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>data</name> =<init> <expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>col</name> &lt; <name>ld</name>-&gt;<name>lineSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* some internal points may not be drawn */</comment>
		<if>if <condition>(<expr><name>data</name> == 0</expr>)</condition><then>
		    <expr_stmt><expr><name>data</name> = ' '</expr>;</expr_stmt></then></if>

		<macro><name>if_WIDE_OR_NARROW</name><argument_list>(<argument>screen</argument>, <argument>{
		    next = convertToUTF8(last, data);
		}</argument>
		, <argument>{
		    *next++ = CharOf(data);
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		    size_t off;
		    for_each_combData(off, ld) {
			data = ld-&gt;combData[off][col];
			if (data == 0)
			    break;
			next = convertToUTF8(next, data);
		    }
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<expr_stmt><expr><name><name>indexed</name><index>[<expr><name>used</name></expr>]</index></name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>last</name> - <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>next</name> = 0</expr>;</expr_stmt>
		<comment type="block">/* TRACE(("index[%d.%d] %d:%s\n", row, used, indexed[used], last)); */</comment>
		<expr_stmt><expr><name>last</name> = <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr>++<name>used</name></expr>;</expr_stmt>
		<expr_stmt><expr>++<name>col</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexed</name><index>[<expr><name>used</name></expr>]</index></name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>next</name> - <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></while>
	}</block> while <condition>(<expr><name>used</name> &lt; <name>length</name> &amp;&amp;
		 <call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call> &amp;&amp;
		 (<name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>++<name>row</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp;
		 <name>row</name> &lt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition>;</do>
    }</block></then></if>
    <comment type="block">/* TRACE(("result:%s\n", result)); */</comment>
    <return>return <expr>(<name>char</name> *) <name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Find the column given an offset into the character string by using the
 * index constructed in make_indexed_text().
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>indexToCol</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>indexed</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>off</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name><name>indexed</name><index>[<expr><name>col</name></expr>]</index></name> &lt; <name>len</name></expr>)</condition> <block>{
	<if>if <condition>(<expr><name><name>indexed</name><index>[<expr><name>col</name></expr>]</index></name> &gt;= <name>off</name></expr>)</condition><then>
	    <break>break;</break></then></if>
	<expr_stmt><expr>++<name>col</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>col</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Given a row number, and a column offset from that (which may be wrapped),
 * set the cell to the actual row/column values.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>columnToCell</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name>row</name> &lt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>last</name> =<init> <expr><call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* TRACE(("last(%d) = %d, have %d\n", row, last, col)); */</comment>
	<if>if <condition>(<expr><name>col</name> &lt;= <name>last</name></expr>)</condition><then> <block>{
	    <break>break;</break>
	}</block></then></if>
	<comment type="block">/*
	 * Stop if the current row does not wrap (does not continue the current
	 * line).
	 */</comment>
	<if>if <condition>(<expr>!<call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>col</name> = <name>last</name> + 1</expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
	<expr_stmt><expr><name>col</name> -= (<name>last</name> + 1)</expr>;</expr_stmt>
	<expr_stmt><expr>++<name>row</name></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name>col</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>col</name> = 0</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>cell</name>-&gt;<name>row</name> = <name>row</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cell</name>-&gt;<name>col</name> = <name>col</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Given a cell, find the corresponding column offset.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>cellToColumn</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr><name>cell</name>-&gt;<name>col</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr><call><name>firstRowOfLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cell</name>-&gt;<name>row</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>row</name> &lt; <name>cell</name>-&gt;<name>row</name></expr>)</condition> <block>{
	<expr_stmt><expr><name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>col</name> += <call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>row</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <if>if <condition>(<expr><name>ld</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>col</name> /= 2</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>col</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>do_select_regex</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>startc</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>endc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>startc</name>-&gt;<name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>inx</name> =<init> <expr>((<name>screen</name>-&gt;<name>numberOfClicks</name> - 1) % <name>screen</name>-&gt;<name>maxClicks</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>expr</name> =<init> <expr><name>screen</name>-&gt;<name><name>selectExpr</name><index>[<expr><name>inx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regex_t</name></type> <name>preg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>regmatch_t</name></type> <name>match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>search</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> *</type><name>indexed</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Select_REGEX:%s\n", <call><name>NonNull</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>okPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>ld</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>)</argument_list></call> &amp;&amp; <name>expr</name> != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>regcomp</name><argument_list>(<argument><expr>&amp;<name>preg</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>REG_EXTENDED</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>firstRow</name> =<init> <expr><call><name>firstRowOfLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>startc</name>-&gt;<name>row</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>lastRow</name> =<init> <expr><call><name>lastRowOfLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>firstRow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name> =<init> <expr><call><name>lengthOfLines</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>firstRow</name></expr></argument>, <argument><expr><name>lastRow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>actual</name> =<init> <expr><call><name>cellToColumn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("regcomp ok rows %d..%d bytes %d\n",
		   <name>firstRow</name>, <name>lastRow</name>, <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr>(<name>indexed</name> = <call><name>TypeCallocN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>search</name> = <call><name>make_indexed_text</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
						<argument><expr><name>firstRow</name></expr></argument>,
						<argument><expr><name>size</name></expr></argument>,
						<argument><expr><name>indexed</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		    <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>(<name>int</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>search</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>best_col</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>best_len</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>

		    <for>for (<init><expr><name>col</name> = 0</expr>;</init> <condition><expr><name><name>indexed</name><index>[<expr><name>col</name></expr>]</index></name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>regexec</name><argument_list>(<argument><expr>&amp;<name>preg</name></expr></argument>,
				    <argument><expr><name>search</name> + <name><name>indexed</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
				    <argument><expr>(<name>size_t</name>) 1</expr></argument>, <argument><expr>&amp;<name>match</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			    <decl_stmt><decl><type><name>int</name></type> <name>start_inx</name> =<init> <expr><name>match</name>.<name>rm_so</name> + <name><name>indexed</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			    <decl_stmt><decl><type><name>int</name></type> <name>finis_inx</name> =<init> <expr><name>match</name>.<name>rm_eo</name> + <name><name>indexed</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			    <decl_stmt><decl><type><name>int</name></type> <name>start_col</name> =<init> <expr><call><name>indexToCol</name><argument_list>(<argument><expr><name>indexed</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>start_inx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			    <decl_stmt><decl><type><name>int</name></type> <name>finis_col</name> =<init> <expr><call><name>indexToCol</name><argument_list>(<argument><expr><name>indexed</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>finis_inx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			    <if>if <condition>(<expr><name>start_col</name> &lt;= <name>actual</name> &amp;&amp;
				<name>actual</name> &lt; <name>finis_col</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>test</name> =<init> <expr><name>finis_col</name> - <name>start_col</name></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>best_len</name> &lt; <name>test</name></expr>)</condition><then> <block>{
				    <expr_stmt><expr><name>best_len</name> = <name>test</name></expr>;</expr_stmt>
				    <expr_stmt><expr><name>best_col</name> = <name>start_col</name></expr>;</expr_stmt>
				    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("match column %d len %d\n",
					   <name>best_col</name>,
					   <name>best_len</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			    }</block></then></if>
			}</block></then></if>
		    }</block></for>
		    <if>if <condition>(<expr><name>best_col</name> &gt;= 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>best_nxt</name> =<init> <expr><name>best_col</name> + <name>best_len</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>columnToCell</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>firstRow</name></expr></argument>, <argument><expr><name>best_col</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>columnToCell</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>firstRow</name></expr></argument>, <argument><expr><name>best_nxt</name></expr></argument>, <argument><expr><name>endc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("search::%s\n", <name>search</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("indexed:%d..%d -&gt; %d..%d\n",
			       <name>best_col</name>, <name>best_nxt</name>,
			       <name><name>indexed</name><index>[<expr><name>best_col</name></expr>]</index></name>,
			       <name><name>indexed</name><index>[<expr><name>best_nxt</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("matched:%d:%s\n",
			       <name><name>indexed</name><index>[<expr><name>best_nxt</name></expr>]</index></name> + 1 -
			       <name><name>indexed</name><index>[<expr><name>best_col</name></expr>]</index></name>,
			       <call><name>visibleChars</name><argument_list>(<argument><expr>(<name>Char</name> *) (<name>search</name> + <name><name>indexed</name><index>[<expr><name>best_col</name></expr>]</index></name>)</expr></argument>,
					    <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name><name>indexed</name><index>[<expr><name>best_nxt</name></expr>]</index></name> +
							1 -
							<name><name>indexed</name><index>[<expr><name>best_col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
		    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>search</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>indexed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
		<if>if <condition>(<expr>(<name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>startc</name>-&gt;<name>row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>startc</name>-&gt;<name>col</name> *= 2</expr>;</expr_stmt></then></if>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>endc</name>-&gt;<name>row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>endc</name>-&gt;<name>col</name> *= 2</expr>;</expr_stmt></then></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr>&amp;<name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SELECT_REGEX */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>InitRow</name>(name) \
	ld.name = GET_LINEDATA(screen, screen-&gt;name.row)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>NextRow</name>(name) \
	ld.name = GET_LINEDATA(screen, ++screen-&gt;name.row)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>PrevRow</name>(name) \
	ld.name = GET_LINEDATA(screen, --screen-&gt;name.row)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>MoreRows</name>(name) \
	(screen-&gt;name.row &lt; screen-&gt;max_row)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>isPrevWrapped</name>(name) \
	(screen-&gt;name.row &gt; 0 \
	   &amp;&amp; (ltmp = GET_LINEDATA(screen, screen-&gt;name.row - 1)) != 0 \
	   &amp;&amp; LineTstWrapped(ltmp))</cpp:define>

<comment type="block">/*
 * sets startSel endSel
 * ensuring that they have legal values
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ComputeSelect</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	      <param><decl><type><name>CELL</name> *</type> <name>startc</name></decl></param>,
	      <param><decl><type><name>CELL</name> *</type> <name>endc</name></decl></param>,
	      <param><decl><type><name>Bool</name></type> <name>extend</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cclass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>first</name> =<init> <expr>*<name>startc</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>last</name> =<init> <expr>*<name>endc</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>ignored</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    struct <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>startSel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>endSel</name></decl>;</decl_stmt>
    }</block> <expr_stmt><expr><name>ld</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ltmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ComputeSelect(startRow=%d, startCol=%d, endRow=%d, endCol=%d, %sextend)\n",
	   <name>first</name>.<name>row</name>, <name>first</name>.<name>col</name>,
	   <name>last</name>.<name>row</name>, <name>last</name>.<name>col</name>,
	   <name>extend</name> ? "" : "no")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>first</name>.<name>col</name> &gt; 1
	&amp;&amp; <call><name>isWideCell</name><argument_list>(<argument><expr><name>first</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name> - 1</expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>XTERM_CELL</name><argument_list>(<argument><expr><name>first</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name> - 0</expr></argument>)</argument_list></call> == <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Adjusting start. Changing downwards from %i.\n", <name>first</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>first</name>.<name>col</name> -= 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>last</name>.<name>col</name> == (<name>first</name>.<name>col</name> + 1)</expr>)</condition><then>
	    <expr_stmt><expr><name>last</name>.<name>col</name>--</expr>;</expr_stmt></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>last</name>.<name>col</name> &gt; 1
	&amp;&amp; <call><name>isWideCell</name><argument_list>(<argument><expr><name>last</name>.<name>row</name></expr></argument>, <argument><expr><name>last</name>.<name>col</name> - 1</expr></argument>)</argument_list></call>
	&amp;&amp; <call><name>XTERM_CELL</name><argument_list>(<argument><expr><name>last</name>.<name>row</name></expr></argument>, <argument><expr><name>last</name>.<name>col</name></expr></argument>)</argument_list></call> == <name>HIDDEN_CHAR</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>last</name>.<name>col</name> += 1</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>)</argument_list></call> &lt;= <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name> = <name>screen</name>-&gt;<name>startRaw</name> = <name>first</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name> = <name>screen</name>-&gt;<name>endRaw</name> = <name>last</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{			<comment type="block">/* Swap them */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name> = <name>screen</name>-&gt;<name>startRaw</name> = <name>last</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name> = <name>screen</name>-&gt;<name>endRaw</name> = <name>first</name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>InitRow</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitRow</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>selectUnit</name></expr>)</condition> <block>{
    <case>case <expr><name>Select_CHAR</name></expr>:
	<expr_stmt><expr>(<name>void</name>) <call><name>okPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>ld</name>.<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>) <call><name>okPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>ld</name>.<name>endSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr><name>Select_WORD</name></expr>:
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Select_WORD\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>okPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>ld</name>.<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>cclass</name> = <call><name>CClassOf</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <do>do <block>{
		<expr_stmt><expr>--<name>screen</name>-&gt;<name>startSel</name>.<name>col</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> &lt; 0
		    &amp;&amp; <call><name>isPrevWrapped</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>PrevRow</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> = <call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name>.<name>startSel</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block> while <condition>(<expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> &gt;= 0
		     &amp;&amp; <call><name>CClassSelects</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>, <argument><expr><name>cclass</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
	    <expr_stmt><expr>++<name>screen</name>-&gt;<name>startSel</name>.<name>col</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name>
	    &amp;&amp; <call><name>XTERM_CELL</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name></expr></argument>,
			  <argument><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name></expr></argument>)</argument_list></call> == <name>HIDDEN_CHAR</name></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name>++</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><call><name>okPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>ld</name>.<name>endSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>length</name> = <call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name>.<name>endSel</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>cclass</name> = <call><name>CClassOf</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <do>do <block>{
		<expr_stmt><expr>++<name>screen</name>-&gt;<name>endSel</name>.<name>col</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> &gt; <name>length</name>
		    &amp;&amp; <call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name>.<name>endSel</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr>!<call><name>MoreRows</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<break>break;</break></then></if>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>NextRow</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>length</name> = <call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name>.<name>endSel</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block> while <condition>(<expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> &lt;= <name>length</name>
		     &amp;&amp; <call><name>CClassSelects</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>, <argument><expr><name>cclass</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
	    <comment type="block">/* Word-select selects if pointing to any char in "word",
	     * especially note that it includes the last character in a word.
	     * So we do no --endSel.col and do special eol handling.
	     */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> &gt; <name>length</name> + 1
		&amp;&amp; <call><name>MoreRows</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NextRow</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name>
	    &amp;&amp; <call><name>XTERM_CELL</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name></expr></argument>,
			  <argument><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name></expr></argument>)</argument_list></call> == <name>HIDDEN_CHAR</name></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name>++</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>screen</name>-&gt;<name>saveStartW</name> = <name>screen</name>-&gt;<name>startSel</name></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr><name>Select_LINE</name></expr>:
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Select_LINE\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name>.<name>endSel</name></expr></argument>)</argument_list></call>
	       &amp;&amp; <call><name>MoreRows</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>NextRow</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cutToBeginningOfLine</name>
	    || <name>screen</name>-&gt;<name>startSel</name>.<name>row</name> &lt; <name>screen</name>-&gt;<name>saveStartW</name>.<name>row</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
	    <while>while <condition>(<expr><call><name>isPrevWrapped</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<expr_stmt><expr><call><name>PrevRow</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></while>
	}</block></then> <else>else <if>if <condition>(<expr>!<name>extend</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>(<name>first</name>.<name>row</name> &lt; <name>screen</name>-&gt;<name>saveStartW</name>.<name>row</name>)
		|| (<call><name>isSameRow</name><argument_list>(<argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>saveStartW</name>)</expr></argument>)</argument_list></call>
		    &amp;&amp; <name>first</name>.<name>col</name> &lt; <name>screen</name>-&gt;<name>saveStartW</name>.<name>col</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>isPrevWrapped</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		    <expr_stmt><expr><call><name>PrevRow</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name> = <name>screen</name>-&gt;<name>saveStartW</name></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then></if></else></if>
	<expr_stmt><expr><call><name>trimLastLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>ld</name>.<name>endSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr><name>Select_GROUP</name></expr>:		<comment type="block">/* paragraph */</comment>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Select_GROUP\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>okPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>ld</name>.<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* scan backward for beginning of group */</comment>
	    <while>while <condition>(<expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name> &gt; 0 &amp;&amp;
		   (<call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name>.<name>startSel</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name> -
				1</expr></argument>)</argument_list></call> &gt; 0 ||
		    <call><name>isPrevWrapped</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>PrevRow</name><argument_list>(<argument><expr><name>startSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></while>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
	    <comment type="block">/* scan forward for end of group */</comment>
	    <while>while <condition>(<expr><call><name>MoreRows</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call> &amp;&amp;
		   (<call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name>.<name>endSel</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name> + 1</expr></argument>)</argument_list></call> &gt;
		    0 ||
		    <call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name>.<name>endSel</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
		<expr_stmt><expr><call><name>NextRow</name><argument_list>(<argument><expr><name>endSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></while>
	    <expr_stmt><expr><call><name>trimLastLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>ld</name>.<name>endSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>Select_PAGE</name></expr>:		<comment type="block">/* everything one can see */</comment>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Select_PAGE\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name> = <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr><name>Select_ALL</name></expr>:		<comment type="block">/* counts scrollback if in normal screen */</comment>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Select_ALL\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>row</name> = -<name>screen</name>-&gt;<name>savedlines</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>startSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>row</name> = <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endSel</name>.<name>col</name> = 0</expr>;</expr_stmt>
	<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SELECT_REGEX</name></expr></cpp:if>
    </case><case>case <expr><name>Select_REGEX</name></expr>:
	<expr_stmt><expr><call><name>do_select_regex</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>NSELECTUNITS</name></expr>:		<comment type="block">/* always ignore */</comment>
	<expr_stmt><expr><name>ignored</name> = <name>True</name></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>

    <if>if <condition>(<expr>!<name>ignored</name></expr>)</condition><then> <block>{
	<comment type="block">/* check boundaries */</comment>
	<expr_stmt><expr><call><name>ScrollSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TrackText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>startSel</name>)</expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>endSel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return;</return>
}</block></function>

<comment type="block">/* Guaranteed (first.row, first.col) &lt;= (last.row, last.col) */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>TrackText</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	  <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>firstp</name></decl></param>,
	  <param><decl><type><name>const</name> <name>CELL</name> *</type> <name>lastp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>from</name>, <name>to</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>old_start</name>, <name>old_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>first</name> =<init> <expr>*<name>firstp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>last</name> =<init> <expr>*<name>lastp</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("TrackText(first=%d,%d, last=%d,%d)\n",
	   <name>first</name>.<name>row</name>, <name>first</name>.<name>col</name>, <name>last</name>.<name>row</name>, <name>last</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>old_start</name> = <name>screen</name>-&gt;<name>startH</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>old_end</name> = <name>screen</name>-&gt;<name>endH</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>old_start</name></expr></argument>)</argument_list></call> &amp;&amp;
	<call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;<name>last</name></expr></argument>, <argument><expr>&amp;<name>old_end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>startH</name> = <name>first</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>endH</name> = <name>last</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>from</name> = <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name>startH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>to</name> = <call><name>Coordinate</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name>endH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>to</name> &lt;= <name>screen</name>-&gt;<name>startHCoord</name> || <name>from</name> &gt; <name>screen</name>-&gt;<name>endHCoord</name></expr>)</condition><then> <block>{
	<comment type="block">/* No overlap whatsoever between old and new hilite */</comment>
	<expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>old_start</name></expr></argument>, <argument><expr>&amp;<name>old_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><name>from</name> &lt; <name>screen</name>-&gt;<name>startHCoord</name></expr>)</condition><then> <block>{
	    <comment type="block">/* Extend left end */</comment>
	    <expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>old_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>from</name> &gt; <name>screen</name>-&gt;<name>startHCoord</name></expr>)</condition><then> <block>{
	    <comment type="block">/* Shorten left end */</comment>
	    <expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>old_start</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
	<if>if <condition>(<expr><name>to</name> &gt; <name>screen</name>-&gt;<name>endHCoord</name></expr>)</condition><then> <block>{
	    <comment type="block">/* Extend right end */</comment>
	    <expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>old_end</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>to</name> &lt; <name>screen</name>-&gt;<name>endHCoord</name></expr>)</condition><then> <block>{
	    <comment type="block">/* Shorten right end */</comment>
	    <expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>, <argument><expr>&amp;<name>old_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
    }</block></else></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>startHCoord</name> = <name>from</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>endHCoord</name> = <name>to</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Guaranteed that (first-&gt;row, first-&gt;col) &lt;= (last-&gt;row, last-&gt;col) */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ReHiliteText</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	     <param><decl><type><name>CELL</name> *</type> <name>firstp</name></decl></param>,
	     <param><decl><type><name>CELL</name> *</type> <name>lastp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>first</name> =<init> <expr>*<name>firstp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>last</name> =<init> <expr>*<name>lastp</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ReHiliteText from %d.%d to %d.%d\n",
	   <name>first</name>.<name>row</name>, <name>first</name>.<name>col</name>, <name>last</name>.<name>row</name>, <name>last</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>first</name>.<name>row</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>first</name>.<name>row</name> = <name>first</name>.<name>col</name> = 0</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>first</name>.<name>row</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	<return>return;</return></then></if></else></if>			<comment type="block">/* nothing to do, since last.row &gt;= first.row */</comment>

    <if>if <condition>(<expr><name>last</name>.<name>row</name> &lt; 0</expr>)</condition><then>
	<return>return;</return></then>			<comment type="block">/* nothing to do, since first.row &lt;= last.row */</comment>
    <else>else <if>if <condition>(<expr><name>last</name>.<name>row</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>last</name>.<name>row</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>last</name>.<name>col</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <if>if <condition>(<expr><call><name>isSameCELL</name><argument_list>(<argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>

    <if>if <condition>(<expr>!<call><name>isSameRow</name><argument_list>(<argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* do multiple rows */</comment>
	<if>if <condition>(<expr>(<name>i</name> = <name>screen</name>-&gt;<name>max_col</name> - <name>first</name>.<name>col</name> + 1) &gt; 0</expr>)</condition><then> <block>{	<comment type="block">/* first row */</comment>
	    <expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>first</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>i</name> = <name>last</name>.<name>row</name> - <name>first</name>.<name>row</name> - 1) &gt; 0</expr>)</condition><then> <block>{	<comment type="block">/* middle rows */</comment>
	    <expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>first</name>.<name>row</name> + 1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>last</name>.<name>col</name> &gt; 0 &amp;&amp; <name>last</name>.<name>row</name> &lt;= <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then> <block>{	<comment type="block">/* last row */</comment>
	    <expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>last</name>.<name>row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>last</name>.<name>col</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else <block>{			<comment type="block">/* do single row */</comment>
	<expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>first</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>last</name>.<name>col</name> - <name>first</name>.<name>col</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * Guaranteed that (cellc-&gt;row, cellc-&gt;col) &lt;= (cell-&gt;row, cell-&gt;col), and that both points are valid
 * (may have cell-&gt;row = screen-&gt;max_row+1, cell-&gt;col = 0).
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>SaltTextAway</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	     <param><decl><type><name>CELL</name> *</type> <name>cellc</name></decl></param>,
	     <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>,
	     <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* selections */</comment>
	     <param><decl><type><name>Cardinal</name></type> <name>num_params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>lp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>first</name> =<init> <expr>*<name>cellc</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CELL</name></type> <name>last</name> =<init> <expr>*<name>cell</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>isSameRow</name><argument_list>(<argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call> &amp;&amp; <name>first</name>.<name>col</name> &gt; <name>last</name>.<name>col</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>first</name>.<name>col</name></expr></argument>, <argument><expr><name>last</name>.<name>col</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr>--<name>last</name>.<name>col</name></expr>;</expr_stmt>
    <comment type="block">/* first we need to know how long the string is before we can save it */</comment>

    <if>if <condition>(<expr><call><name>isSameRow</name><argument_list>(<argument><expr>&amp;<name>last</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>j</name> = <call><name>Length</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>first</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name></expr></argument>, <argument><expr><name>last</name>.<name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{			<comment type="block">/* two cases, cut is on same line, cut spans multiple lines */</comment>
	<expr_stmt><expr><name>j</name> += <call><name>Length</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>first</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_col</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name>first</name>.<name>row</name> + 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>last</name>.<name>row</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
	    <expr_stmt><expr><name>j</name> += <call><name>Length</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_col</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></for>
	<if>if <condition>(<expr><name>last</name>.<name>col</name> &gt;= 0</expr>)</condition><then>
	    <expr_stmt><expr><name>j</name> += <call><name>Length</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>last</name>.<name>row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>last</name>.<name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

    <comment type="block">/* UTF-8 may require more space */</comment>
    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	j *= 4;
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <comment type="block">/* now get some memory to save it in */</comment>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_size</name> &lt;= <name>j</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>line</name> = (<name>Char</name> *) <call><name>malloc</name><argument_list>(<argument><expr>(<name>size_t</name>) <name>j</name> + 1</expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_BMALLOC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>screen</name>-&gt;<name>selection_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>selection_data</name> = <name>line</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>selection_size</name> = <name>j</name> + 1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>line</name> = <name>screen</name>-&gt;<name>selection_data</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>(<name>line</name> == 0)
	|| (<name>j</name> &lt; 0)</expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>		<comment type="block">/* make sure it is null terminated */</comment>
    <expr_stmt><expr><name>lp</name> = <name>line</name></expr>;</expr_stmt>			<comment type="block">/* lp points to where to save the text */</comment>
    <if>if <condition>(<expr><call><name>isSameRow</name><argument_list>(<argument><expr>&amp;<name>last</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>lp</name> = <call><name>SaveText</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>last</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name></expr></argument>, <argument><expr><name>last</name>.<name>col</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>lp</name> = <call><name>SaveText</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>first</name>.<name>row</name></expr></argument>, <argument><expr><name>first</name>.<name>col</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_col</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>eol</name></expr>)</condition><then>
	    <expr_stmt><expr>*<name>lp</name>++ = '\n'</expr>;</expr_stmt></then></if>	<comment type="block">/* put in newline at end of line */</comment>
	<for>for (<init><expr><name>i</name> = <name>first</name>.<name>row</name> + 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>last</name>.<name>row</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	    <expr_stmt><expr><name>lp</name> = <call><name>SaveText</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_col</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>eol</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>lp</name>++ = '\n'</expr>;</expr_stmt></then></if>
	}</block></for>
	<if>if <condition>(<expr><name>last</name>.<name>col</name> &gt;= 0</expr>)</condition><then>
	    <expr_stmt><expr><name>lp</name> = <call><name>SaveText</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>last</name>.<name>row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>last</name>.<name>col</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
    <expr_stmt><expr>*<name>lp</name> = '\0'</expr>;</expr_stmt>			<comment type="block">/* make sure we have end marked */</comment>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Salted TEXT:%d:%s\n", <call>(<name>int</name>) <argument_list>(<argument><expr><name>lp</name> - <name>line</name></expr></argument>)</argument_list></call>,
	   <call><name>visibleChars</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>lp</name> - <name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>selection_length</name> = (<name>unsigned</name> <name>long</name>) (<name>lp</name> - <name>line</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_OwnSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ClearSelectionBuffer</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>screen</name>-&gt;<name>selection_length</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 0</expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>AppendStrToSelectionBuffer</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>text</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>len</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>selection_length</name> + <name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>		<comment type="block">/* New length */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><name>j</name> + (<name>j</name> &gt;&gt; 2) + 80</expr></init></decl>;</decl_stmt>	<comment type="block">/* New size if we grow buffer: grow by ~50% */</comment>
	<if>if <condition>(<expr><name>j</name> + 1 &gt;= <name>screen</name>-&gt;<name>selection_size</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>selection_length</name></expr>)</condition><then> <block>{
		<comment type="block">/* New buffer */</comment>
		<decl_stmt><decl><type><name>Char</name> *</type><name>line</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>(<name>line</name> = (<name>Char</name> *) <call><name>malloc</name><argument_list>(<argument><expr>(<name>size_t</name>) <name>k</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
		    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_BMALLOC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>screen</name>-&gt;<name>selection_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>selection_data</name> = <name>line</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<comment type="block">/* Realloc buffer */</comment>
		<expr_stmt><expr><name>screen</name>-&gt;<name>selection_data</name> = (<name>Char</name> *)
		    <call><name>realloc</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>selection_data</name></expr></argument>,
			    <argument><expr>(<name>size_t</name>) <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_data</name> == 0</expr>)</condition><then>
		    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_BMALLOC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    }</block></else></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>selection_size</name> = <name>k</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_data</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>selection_data</name> + <name>screen</name>-&gt;<name>selection_length</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>selection_length</name> += <name>len</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name><name>selection_data</name><index>[<expr><name>screen</name>-&gt;<name>selection_length</name></expr>]</index></name> = 0</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>AppendToSelectionBuffer</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>six</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name></type> <name>ch</name></decl>;</decl_stmt>

    <comment type="block">/* Decode base64 character */</comment>
    <if>if <condition>(<expr><name>c</name> &gt;= 'A' &amp;&amp; <name>c</name> &lt;= 'Z'</expr>)</condition><then>
	<expr_stmt><expr><name>six</name> = <name>c</name> - 'A'</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'z'</expr>)</condition><then>
	<expr_stmt><expr><name>six</name> = <name>c</name> - 'a' + 26</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then>
	<expr_stmt><expr><name>six</name> = <name>c</name> - '0' + 52</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>c</name> == '+'</expr>)</condition><then>
	<expr_stmt><expr><name>six</name> = 62</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>c</name> == '/'</expr>)</condition><then>
	<expr_stmt><expr><name>six</name> = 63</expr>;</expr_stmt></then>
    <else>else
	<return>return;</return></else></if></else></if></else></if></else></if></else></if>

    <comment type="block">/* Accumulate bytes */</comment>
    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>base64_count</name></expr>)</condition> <block>{
    <case>case <expr>0</expr>:
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = <name>six</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 6</expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr>2</expr>:
	<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr>(<name>screen</name>-&gt;<name>base64_accu</name> &lt;&lt; 6) + <name>six</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendStrToSelectionBuffer</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>, <argument><expr>(<name>size_t</name>) 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr>4</expr>:
	<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr>(<name>screen</name>-&gt;<name>base64_accu</name> &lt;&lt; 4) + (<name>six</name> &gt;&gt; 2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = (<name>six</name> &amp; 0x3)</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 2</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendStrToSelectionBuffer</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>, <argument><expr>(<name>size_t</name>) 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr>6</expr>:
	<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr>(<name>screen</name>-&gt;<name>base64_accu</name> &lt;&lt; 2) + (<name>six</name> &gt;&gt; 4)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = (<name>six</name> &amp; 0xF)</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 4</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendStrToSelectionBuffer</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>, <argument><expr>(<name>size_t</name>) 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>
}</block></function>

<function><type><name>void</name></type>
<name>CompleteSelection</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>String</name> *</type> <name>args</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>base64_count</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>base64_accu</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_OwnSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_PASTE64 */</comment>

<function><type><name>static</name> <name>Bool</name></type>
<name>_ConvertSelectionHelper</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
			<param><decl><type><name>Atom</name> *</type> <name>type</name></decl></param>,
			<param><decl><type><name>XtPointer</name> *</type><name>value</name></decl></param>,
			<param><decl><type><name>unsigned</name> <name>long</name> *</type><name>length</name></decl></param>,
			<param><decl><type><name>int</name> *</type><name>format</name></decl></param>,
			<param><function_decl><type><name>int</name></type> (*<name>conversion_function</name>) <parameter_list>(<param><decl><type><name>Display</name> *</type></decl></param>,
						    <param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>,
						    <param><decl><type><name>XICCEncodingStyle</name></type></decl></param>,
						    <param><decl><type><name>XTextProperty</name> *</type></decl></param>)</parameter_list>,
			<param><decl><type><name>XICCEncodingStyle</name></type> <name>conversion_style</name></decl></param></function_decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XTextProperty</name></type> <name>textprop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>the_data</name> =<init> <expr>(<name>char</name> *) <name>screen</name>-&gt;<name>selection_data</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>conversion_function</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>&amp;<name>the_data</name></expr></argument>, <argument><expr>1</expr></argument>,
				<argument><expr><name>conversion_style</name></expr></argument>,
				<argument><expr>&amp;<name>textprop</name></expr></argument>)</argument_list></call> &gt;= <name>Success</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>value</name> = (<name>XtPointer</name>) <name>textprop</name>.<name>value</name></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>length</name> = <name>textprop</name>.<name>nitems</name></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>type</name> = <name>textprop</name>.<name>encoding</name></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>format</name> = <name>textprop</name>.<name>format</name></expr>;</expr_stmt>
	    <return>return <expr><name>True</name></expr>;</return>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>False</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Boolean</name></type>
<name>SaveConvertedLength</name><parameter_list>(<param><decl><type><name>XtPointer</name> *</type><name>target</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>source</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Boolean</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>target</name> = <call><name>XtMalloc</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>target</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	<if>if <condition>(<macro><name>sizeof</name><argument_list>(<argument>unsigned long</argument>)</argument_list></macro> <expr>== 4</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*(<name>unsigned</name> <name>long</name> *) *<name>target</name> = <name>source</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></call> == 4</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*(<name>unsigned</name> *) *<name>target</name> = (<name>unsigned</name>) <name>source</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<macro><name>sizeof</name><argument_list>(<argument>unsigned short</argument>)</argument_list></macro> <expr>== 4</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*(<name>unsigned</name> <name>short</name> *) *<name>target</name> = (<name>unsigned</name> <name>short</name>) <name>source</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <comment type="block">/* FIXME - does this depend on byte-order? */</comment>
	    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>temp</name> =<init> <expr><name>source</name></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) *<name>target</name></expr></argument>,
		   <argument><expr>((<name>char</name> *) &amp;<name>temp</name>) + <call><name>sizeof</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call> - 4</expr></argument>,
		   <argument><expr>(<name>size_t</name>) 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if></else></if></else></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Boolean</name></type>
<name>ConvertSelection</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		 <param><decl><type><name>Atom</name> *</type> <name>selection</name></decl></param>,
		 <param><decl><type><name>Atom</name> *</type> <name>target</name></decl></param>,
		 <param><decl><type><name>Atom</name> *</type> <name>type</name></decl></param>,
		 <param><decl><type><name>XtPointer</name> *</type><name>value</name></decl></param>,
		 <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>length</name></decl></param>,
		 <param><decl><type><name>int</name> *</type><name>format</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	<return>return <expr><name>False</name></expr>;</return></then></if>

    <expr_stmt><expr><name>screen</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_data</name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><name>False</name></expr>;</return></then></if>		<comment type="block">/* can this happen? */</comment>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ConvertSelection %s\n",
	   <call><name>visibleSelectionTarget</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>*<name>target</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>*<name>target</name> == <call><name>XA_TARGETS</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Atom</name> *</type><name>allocP</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Atom</name> *</type><name>targetP</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Atom</name> *</type><name>std_targets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XPointer</name></type> <name>std_return</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>std_length</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>XmuConvertStandardSelection</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>selection_time</name></expr></argument>, <argument><expr><name>selection</name></expr></argument>,
					<argument><expr><name>target</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>std_return</name></expr></argument>,
					<argument><expr>&amp;<name>std_length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Atom</name> *</type><name>my_targets</name> =<init> <expr><call><name>_SelectionTargets</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("XmuConvertStandardSelection - success\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>std_targets</name> = (<name>Atom</name> *) (<name>std_return</name>)</expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>length</name> = <name>std_length</name> + 6</expr>;</expr_stmt>

	    <expr_stmt><expr><name>targetP</name> = (<name>Atom</name> *) <call><name>XtMalloc</name><argument_list>(<argument><expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Atom</name></expr></argument>)</argument_list></call> * (*<name>length</name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>allocP</name> = <name>targetP</name></expr>;</expr_stmt>

	    <expr_stmt><expr>*<name>value</name> = (<name>XtPointer</name>) <name>targetP</name></expr>;</expr_stmt>

	    <while>while <condition>(<expr>*<name>my_targets</name> != <name>None</name></expr>)</condition> <block>{
		<expr_stmt><expr>*<name>targetP</name>++ = *<name>my_targets</name>++</expr>;</expr_stmt>
	    }</block></while>
	    <expr_stmt><expr>*<name>targetP</name>++ = <call><name>XA_LENGTH</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>targetP</name>++ = <call><name>XA_LIST_LENGTH</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr>*<name>length</name> = <name>std_length</name> + (<name>unsigned</name> <name>long</name>) (<name>targetP</name> - <name>allocP</name>)</expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>targetP</name></expr></argument>, <argument><expr><name>std_targets</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Atom</name></expr></argument>)</argument_list></call> * <name>std_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>std_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>type</name> = <name>XA_ATOM</name></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>format</name> = 32</expr>;</expr_stmt>
	    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("XmuConvertStandardSelection - failed\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name> &amp;&amp; *<name>target</name> == <name>XA_STRING</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> =
	    <call><name>_ConvertSelectionHelper</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
				    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
				    <argument><expr><name>Xutf8TextListToTextProperty</name></expr></argument>,
				    <argument><expr><name>XStringStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Xutf8TextListToTextProperty:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name> &amp;&amp; *<name>target</name> == <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> =
	    <call><name>_ConvertSelectionHelper</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
				    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
				    <argument><expr><name>Xutf8TextListToTextProperty</name></expr></argument>,
				    <argument><expr><name>XUTF8StringStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Xutf8TextListToTextProperty:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name> &amp;&amp; *<name>target</name> == <call><name>XA_TEXT</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> =
	    <call><name>_ConvertSelectionHelper</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
				    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
				    <argument><expr><name>Xutf8TextListToTextProperty</name></expr></argument>,
				    <argument><expr><name>XStdICCTextStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Xutf8TextListToTextProperty:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name> &amp;&amp; *<name>target</name> == <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> =
	    <call><name>_ConvertSelectionHelper</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
				    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
				    <argument><expr><name>Xutf8TextListToTextProperty</name></expr></argument>,
				    <argument><expr><name>XCompoundTextStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Xutf8TextListToTextProperty:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <else>else <if>if <condition>(<expr>*<name>target</name> == <name>XA_STRING</name></expr>)</condition><then> <block>{	<comment type="block">/* not wide_chars */</comment>
	<comment type="block">/* We can only reach this point if the selection requestor
	   requested STRING before any of TEXT, COMPOUND_TEXT or
	   UTF8_STRING.  We therefore assume that the requestor is not
	   properly internationalised, and dump raw eight-bit data
	   with no conversion into the selection.  Yes, this breaks
	   the ICCCM in non-Latin-1 locales. */</comment>
	<expr_stmt><expr>*<name>type</name> = <name>XA_STRING</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>value</name> = (<name>XtPointer</name>) <name>screen</name>-&gt;<name>selection_data</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>length</name> = <name>screen</name>-&gt;<name>selection_length</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>format</name> = 8</expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...raw 8-bit data:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>*<name>target</name> == <call><name>XA_TEXT</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* not wide_chars */</comment>
	<expr_stmt><expr><name>result</name> =
	    <call><name>_ConvertSelectionHelper</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
				    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
				    <argument><expr><name>XmbTextListToTextProperty</name></expr></argument>,
				    <argument><expr><name>XStdICCTextStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...XmbTextListToTextProperty(StdICC):%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>*<name>target</name> == <call><name>XA_COMPOUND_TEXT</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* not wide_chars */</comment>
	<expr_stmt><expr><name>result</name> =
	    <call><name>_ConvertSelectionHelper</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
				    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
				    <argument><expr><name>XmbTextListToTextProperty</name></expr></argument>,
				    <argument><expr><name>XCompoundTextStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...XmbTextListToTextProperty(Compound):%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>X_HAVE_UTF8_STRING</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr>*<name>target</name> == <call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* not wide_chars */</comment>
	<expr_stmt><expr><name>result</name> =
	    <call><name>_ConvertSelectionHelper</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
				    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>,
				    <argument><expr><name>XmbTextListToTextProperty</name></expr></argument>,
				    <argument><expr><name>XUTF8StringStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...XmbTextListToTextProperty(UTF8):%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else <if>if <condition>(<expr>*<name>target</name> == <call><name>XA_LIST_LENGTH</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <macro><name>SaveConvertedLength</name><argument_list>(<argument>value</argument>, <argument>(unsigned long) 1</argument>)</argument_list></macro></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>type</name> = <name>XA_INTEGER</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>length</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>format</name> = 32</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...list of values:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>*<name>target</name> == <call><name>XA_LENGTH</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* This value is wrong if we have UTF-8 text */</comment>
	<expr_stmt><expr><name>result</name> = <call><name>SaveConvertedLength</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>selection_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>type</name> = <name>XA_INTEGER</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>length</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>format</name> = 32</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...list of values:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>XmuConvertStandardSelection</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
					   <argument><expr><name>screen</name>-&gt;<name>selection_time</name></expr></argument>, <argument><expr><name>selection</name></expr></argument>,
					   <argument><expr><name>target</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>(<name>XPointer</name> *) <name>value</name></expr></argument>,
					   <argument><expr><name>length</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...XmuConvertStandardSelection:%d\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>

    <comment type="block">/* else */</comment>
    <return>return <expr>(<name>Boolean</name>) <name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>LoseSelection</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>, <param><decl><type><name>Atom</name> *</type> <name>selection</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name> *</type><name>atomP</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>i</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>screen</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>atomP</name> = <name>screen</name>-&gt;<name>selection_atoms</name></expr>;</init>
	 <condition><expr><name>i</name> &lt; <name>screen</name>-&gt;<name>selection_count</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>atomP</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>*<name>selection</name> == *<name>atomP</name></expr>)</condition><then>
	    <expr_stmt><expr>*<name>atomP</name> = (<name>Atom</name>) 0</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>CutBuffer</name><argument_list>(<argument><expr>*<name>atomP</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>atomP</name> = (<name>Atom</name>) 0</expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>

    <for>for (<init><expr><name>i</name> = <name>screen</name>-&gt;<name>selection_count</name></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name><name>selection_atoms</name><index>[<expr><name>i</name> - 1</expr>]</index></name> != 0</expr>)</condition><then>
	    <break>break;</break></then></if>
    }</block></for>
    <expr_stmt><expr><name>screen</name>-&gt;<name>selection_count</name> = <name>i</name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>atomP</name> = <name>screen</name>-&gt;<name>selection_atoms</name></expr>;</init>
	 <condition><expr><name>i</name> &lt; <name>screen</name>-&gt;<name>selection_count</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>atomP</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>*<name>atomP</name> == (<name>Atom</name>) 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>atomP</name> = <name>screen</name>-&gt;<name><name>selection_atoms</name><index>[<expr>--<name>screen</name>-&gt;<name>selection_count</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_count</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>TrackText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>zeroCELL</name></expr></argument>, <argument><expr>&amp;<name>zeroCELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>SelectionDone</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
	      <param><decl><type><name>Atom</name> * <name>selection</name></type> <name>GCC_UNUSED</name></decl></param>,
	      <param><decl><type><name>Atom</name> * <name>target</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* empty proc so Intrinsics know we want to keep storage */</comment>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>_OwnSelection</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	      <param><decl><type><name>String</name> *</type> <name>selections</name></decl></param>,
	      <param><decl><type><name>Cardinal</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name> *</type><name>atoms</name> =<init> <expr><name>screen</name>-&gt;<name>selection_atoms</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>have_selection</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then>
	<return>return;</return></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_length</name> == 0</expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("_OwnSelection count %d\n", <name>count</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>selections</name> = <call><name>MapSelections</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>selections</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>count</name> &gt; <name>screen</name>-&gt;<name>sel_atoms_size</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>atoms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>atoms</name> = (<name>Atom</name> *) <call><name>XtMalloc</name><argument_list>(<argument><expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>count</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>Atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>selection_atoms</name> = <name>atoms</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>sel_atoms_size</name> = <name>count</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>XmuInternStrings</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>selections</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>atoms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>cutbuffer</name> =<init> <expr><call><name>CutBuffer</name><argument_list>(<argument><expr><name><name>atoms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>cutbuffer</name> &gt;= 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>limit</name> =<init>
	    <expr>(<name>unsigned</name> <name>long</name>) (4 * <call><name>XMaxRequestSize</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> - 32)</expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_length</name> &gt; <name>limit</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("selection too big (%lu bytes), not storing in CUT_BUFFER%d\n",
		       <name>screen</name>-&gt;<name>selection_length</name>, <name>cutbuffer</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
			<argument><expr>"%s: selection too big (%lu bytes), not storing in CUT_BUFFER%d\n"</expr></argument>,
			<argument><expr><name>xterm_name</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>selection_length</name></expr></argument>, <argument><expr><name>cutbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<comment type="block">/* This used to just use the UTF-8 data, which was totally
		 * broken as not even the corresponding paste code in Xterm
		 * understood this!  So now it converts to Latin1 first.
		 *   Robert Brady, 2000-09-05
		 */</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>length</name> =<init> <expr><name>screen</name>-&gt;<name>selection_length</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Char</name> *</type><name>data</name> =<init> <expr><name>screen</name>-&gt;<name>selection_data</name></expr></init></decl>;</decl_stmt>
		<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>(screen)</argument>, <argument>{
		    data = UTF8toLatin1(screen, data, length, &amp;length);
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("XStoreBuffer(%d)\n", <name>cutbuffer</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XStoreBuffer</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr>(<name>char</name> *) <name>data</name></expr></argument>,
			     <argument><expr>(<name>int</name>) <name>length</name></expr></argument>,
			     <argument><expr><name>cutbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then> <else>else <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>replyToEmacs</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>have_selection</name> |=
		<call><name>XtOwnSelection</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>, <argument><expr><name><name>atoms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
			       <argument><expr><name>screen</name>-&gt;<name>selection_time</name></expr></argument>,
			       <argument><expr><name>ConvertSelection</name></expr></argument>, <argument><expr><name>LoseSelection</name></expr></argument>, <argument><expr><name>SelectionDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
    }</block></for>
    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>replyToEmacs</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>selection_count</name> = <name>count</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<name>have_selection</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>TrackText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>zeroCELL</name></expr></argument>, <argument><expr>&amp;<name>zeroCELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>ResetSelectionState</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>screen</name>-&gt;<name>selection_count</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>startH</name> = <name>zeroCELL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>endH</name> = <name>zeroCELL</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>DisownSelection</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name> *</type><name>atoms</name> =<init> <expr><name>screen</name>-&gt;<name>selection_atoms</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>count</name> =<init> <expr><name>screen</name>-&gt;<name>selection_count</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DisownSelection count %d, start %d.%d, end %d.%d\n",
	   <name>count</name>,
	   <name>screen</name>-&gt;<name>startH</name>.<name>row</name>,
	   <name>screen</name>-&gt;<name>startH</name>.<name>col</name>,
	   <name>screen</name>-&gt;<name>endH</name>.<name>row</name>,
	   <name>screen</name>-&gt;<name>endH</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>cutbuffer</name> =<init> <expr><call><name>CutBuffer</name><argument_list>(<argument><expr><name><name>atoms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>cutbuffer</name> &lt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XtDisownSelection</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>, <argument><expr><name><name>atoms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
			      <argument><expr><name>screen</name>-&gt;<name>selection_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
    <comment type="block">/*
     * If none of the callbacks via XtDisownSelection() reset highlighting
     * do it now.
     */</comment>
    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/* save data which will be reset */</comment>
	<decl_stmt><decl><type><name>CELL</name></type> <name>first</name> =<init> <expr><name>screen</name>-&gt;<name>startH</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CELL</name></type> <name>last</name> =<init> <expr><name>screen</name>-&gt;<name>endH</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetSelectionState</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>ResetSelectionState</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>UnhiliteSelection</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>CELL</name></type> <name>first</name> =<init> <expr><name>screen</name>-&gt;<name>startH</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CELL</name></type> <name>last</name> =<init> <expr><name>screen</name>-&gt;<name>endH</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>screen</name>-&gt;<name>startH</name> = <name>zeroCELL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>endH</name> = <name>zeroCELL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReHiliteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* returns number of chars in line from scol to ecol out */</comment>
<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>Length</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
       <param><decl><type><name>int</name></type> <name>row</name></decl></param>,
       <param><decl><type><name>int</name></type> <name>scol</name></decl></param>,
       <param><decl><type><name>int</name></type> <name>ecol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lastcol</name> =<init> <expr><call><name>LastTextCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ecol</name> &gt; <name>lastcol</name></expr>)</condition><then>
	<expr_stmt><expr><name>ecol</name> = <name>lastcol</name></expr>;</expr_stmt></then></if>
    <return>return <expr>(<name>ecol</name> - <name>scol</name> + 1)</expr>;</return>
}</block></function>

<comment type="block">/* copies text into line, preallocated */</comment>
<function><type><name>static</name> <name>Char</name> *</type>
<name>SaveText</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
	 <param><decl><type><name>int</name></type> <name>row</name></decl></param>,
	 <param><decl><type><name>int</name></type> <name>scol</name></decl></param>,
	 <param><decl><type><name>int</name></type> <name>ecol</name></decl></param>,
	 <param><decl><type><name>Char</name> *</type> <name>lp</name></decl></param>,		<comment type="block">/* pointer to where to put the text */</comment>
	 <param><decl><type><name>int</name> *</type><name>eol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>result</name> =<init> <expr><name>lp</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>previous</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>ld</name> = <call><name>GET_LINEDATA</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> = <call><name>Length</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>scol</name></expr></argument>, <argument><expr><name>ecol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ecol</name> = <name>scol</name> + <name>i</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>scol</name> = (<name>scol</name> + 0) / 2</expr>;</expr_stmt>
	<expr_stmt><expr><name>ecol</name> = (<name>ecol</name> + 1) / 2</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr>*<name>eol</name> = !<call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name>scol</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>ecol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &lt; <name>ld</name>-&gt;<name>lineSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> = <call><name>E2A</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<comment type="block">/* We want to strip out every occurrence of HIDDEN_CHAR AFTER a
	 * wide character.
	 */</comment>
	<if>if <condition>(<expr><name>c</name> == <name>HIDDEN_CHAR</name> &amp;&amp; <call><name>isWide</name><argument_list>(<argument><expr>(<name>int</name>) <name>previous</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>previous</name> = <name>c</name></expr>;</expr_stmt>
	    <comment type="block">/* Combining characters attached to double-width characters
	       are in memory attached to the HIDDEN_CHAR */</comment>
	    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		if (screen-&gt;utf8_mode != uFalse) {
		    unsigned ch;
		    size_t off;
		    for_each_combData(off, ld) {
			ch = ld-&gt;combData[off][i];
			if (ch == 0)
			    break;
			lp = convertToUTF8(lp, ch);
		    }
		}
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
	<expr_stmt><expr><name>previous</name> = <name>c</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> != <name>uFalse</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>lp</name> = <call><name>convertToUTF8</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr>(<name>c</name> != 0) ? <name>c</name> : ' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		unsigned ch;
		size_t off;
		for_each_combData(off, ld) {
		    ch = ld-&gt;combData[off][i];
		    if (ch == 0)
			break;
		    lp = convertToUTF8(lp, ch);
		}
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
	    <if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>E2A</name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr><name>c</name> &lt; <call><name>E2A</name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>DECtoASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr><name>c</name> == 0x7f</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = 0x5f</expr>;</expr_stmt>
	    }</block></then></if></else></if></else></if>
	    <expr_stmt><expr>*<name>lp</name>++ = <call><name>CharOf</name><argument_list>(<argument><expr><call><name>A2E</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>c</name> != <call><name>E2A</name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>result</name> = <name>lp</name></expr>;</expr_stmt></then></if>
    }</block></for>

    <comment type="block">/*
     * If requested, trim trailing blanks from selected lines.  Do not do this
     * if the line is wrapped.
     */</comment>
    <if>if <condition>(<expr>!*<name>eol</name> || !<name>screen</name>-&gt;<name>trim_selection</name></expr>)</condition><then>
	<expr_stmt><expr><name>result</name> = <name>lp</name></expr>;</expr_stmt></then></if>

    <return>return <expr>(<name>result</name>)</expr>;</return>
}</block></function>

<comment type="block">/* 32 + following 7-bit word:

   1:0  Button no: 0, 1, 2.  3=release.
     2  shift
     3  meta
     4  ctrl
     5  set for motion notify
     6  set for wheel
*/</comment>

<comment type="block">/* Position: 32 - 255. */</comment>

<function><type><name>static</name> <name>Char</name></type>
<name>BtnCode</name><parameter_list>(<param><decl><type><name>XButtonEvent</name> *</type> <name>event</name></decl></param>, <param><decl><type><name>int</name></type> <name>button</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr>32 + (<call><name>KeyState</name><argument_list>(<argument><expr><name>event</name>-&gt;<name>state</name></expr></argument>)</argument_list></call> &lt;&lt; 2)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>button</name> &lt; 0 || <name>button</name> &gt; 5</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> += 3</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><name>button</name> &gt; 3</expr>)</condition><then>
	    <expr_stmt><expr><name>result</name> += (64 - 4)</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>MotionNotify</name></expr>)</condition><then>
	    <expr_stmt><expr><name>result</name> += 32</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>result</name> += <name>button</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><call><name>CharOf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>MOUSE_LIMIT</name> (255 - 32)</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>EditorButton</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XButtonEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pty</name> =<init> <expr><name>screen</name>-&gt;<name>respond</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name></type> <name><name>line</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name>, <name>col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>button</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>changed</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If button event, get button # adjusted for DEC compatibility */</comment>
    <expr_stmt><expr><name>button</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>event</name>-&gt;<name>button</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>button</name> &gt;= 3</expr>)</condition><then>
	<expr_stmt><expr><name>button</name>++</expr>;</expr_stmt></then></if>

    <comment type="block">/* Compute character position of mouse pointer */</comment>
    <expr_stmt><expr><name>row</name> = (<name>event</name>-&gt;<name>y</name> - <name>screen</name>-&gt;<name>border</name>) / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>col</name> = (<name>event</name>-&gt;<name>x</name> - <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>) / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Limit to screen dimensions */</comment>
    <if>if <condition>(<expr><name>row</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>row</name> = 0</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>row</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	<expr_stmt><expr><name>row</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>row</name> &gt; <name>MOUSE_LIMIT</name></expr>)</condition><then>
	<expr_stmt><expr><name>row</name> = <name>MOUSE_LIMIT</name></expr>;</expr_stmt></then></if></else></if></else></if>

    <if>if <condition>(<expr><name>col</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>col</name> = 0</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>col</name> &gt; <name>screen</name>-&gt;<name>max_col</name></expr>)</condition><then>
	<expr_stmt><expr><name>col</name> = <name>screen</name>-&gt;<name>max_col</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>col</name> &gt; <name>MOUSE_LIMIT</name></expr>)</condition><then>
	<expr_stmt><expr><name>col</name> = <name>MOUSE_LIMIT</name></expr>;</expr_stmt></then></if></else></if></else></if>

    <comment type="block">/* Build key sequence starting with \E[M */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>control_eight_bits</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = '['</expr>;</expr_stmt>
    }</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCO_FUNC_KEYS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> == <name>keyboardIsSCO</name></expr>)</condition><then> <block>{
	<comment type="block">/*
	 * SCO function key F1 is \E[M, which would conflict with xterm's
	 * normal kmous.
	 */</comment>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = '&gt;'</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = 'M'</expr>;</expr_stmt>

    <comment type="block">/* Add event code to key sequence */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>X10_MOUSE</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>button</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* Button-Motion events */</comment>
	<switch>switch <condition>(<expr><name>event</name>-&gt;<name>type</name></expr>)</condition> <block>{
	<case>case <expr><name>ButtonPress</name></expr>:
	    <expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>BtnCode</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>mouse_button</name> = <name>button</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>ButtonRelease</name></expr>:
	    <comment type="block">/*
	     * Wheel mouse interface generates release-events for buttons
	     * 4 and 5, coded here as 3 and 4 respectively.  We change the
	     * release for buttons 1..3 to a -1.
	     */</comment>
	    <if>if <condition>(<expr><name>button</name> &lt; 3</expr>)</condition><then>
		<expr_stmt><expr><name>button</name> = -1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>BtnCode</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>mouse_button</name> = <name>button</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>MotionNotify</name></expr>:
	    <comment type="block">/* BTN_EVENT_MOUSE and ANY_EVENT_MOUSE modes send motion
	     * events only if character cell has changed.
	     */</comment>
	    <if>if <condition>(<expr>(<name>row</name> == <name>screen</name>-&gt;<name>mouse_row</name>)
		&amp;&amp; (<name>col</name> == <name>screen</name>-&gt;<name>mouse_col</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>changed</name> = <name>False</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>BtnCode</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>mouse_button</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>
	</case><default>default:
	    <expr_stmt><expr><name>changed</name> = <name>False</name></expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></else></if>

    <if>if <condition>(<expr><name>changed</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>mouse_row</name> = <name>row</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>mouse_col</name> = <name>col</name></expr>;</expr_stmt>

	<comment type="block">/* Add pointer position to key sequence */</comment>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>col</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>line</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>' ' + <name>row</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("mouse at %d,%d button+mask = %#x\n", <name>row</name>, <name>col</name>,
	       (<name>screen</name>-&gt;<name>control_eight_bits</name>) ? <name><name>line</name><index>[<expr>2</expr>]</index></name> : <name><name>line</name><index>[<expr>3</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transmit key sequence to process running under xterm */</comment>
	<expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>pty</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FOCUS_EVENT</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>SendFocusButton</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XFocusChangeEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_focus_pos</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>ANSI</name></type> <name>reply</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCO_FUNC_KEYS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> == <name>keyboardIsSCO</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = '&gt;'</expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>reply</name>.<name>a_final</name> = <call><name>CharOf</name><argument_list>(<argument><expr>(<name>event</name>-&gt;<name>type</name> == <name>FocusIn</name>) ? 'I' : 'O'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_FOCUS_EVENT */</comment>
</unit>
