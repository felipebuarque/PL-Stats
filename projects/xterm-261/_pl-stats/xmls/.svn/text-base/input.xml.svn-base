<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" dir="" filename="input.c"><comment type="block">/* $XTermId: input.c,v 1.326 2010/06/15 22:41:09 tom Exp $ */</comment>

<comment type="block">/*
 * Copyright 1999-2009,2010 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */</comment>

<comment type="block">/* input.c */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/keysym.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/keysymdef.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_X11_DECKEYSYM_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/DECkeysym.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_X11_SUNKEYSYM_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Sunkeysym.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_X11_XF86KEYSYM_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/XF86keysym.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xutil.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xutf8.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;data.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fontutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xstrings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xtermcap.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
 * Xutil.h has no macro to check for the complete set of function- and
 * modifier-keys that might be returned.  Fake it.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Lock</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsPredefinedKey</name>(n) ((n) &gt;= XK_ISO_Lock &amp;&amp; (n) &lt;= XK_Delete)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsPredefinedKey</name>(n) ((n) &gt;= XK_BackSpace &amp;&amp; (n) &lt;= XK_Delete)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Left_Tab</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsTabKey</name>(n) ((n) == XK_Tab || (n) == XK_ISO_Left_Tab)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsTabKey</name>(n) ((n) == XK_Tab)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>IsPrivateKeypadKey</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsPrivateKeypadKey</name>(k) (0)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsBackarrowToggle</name>(keyboard, keysym, state) \
	((((keyboard-&gt;flags &amp; MODE_DECBKM) == 0) \
	    ^ ((state &amp; ControlMask) != 0)) \
	&amp;&amp; (keysym == XK_BackSpace))</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAP</name>(from, to) case from: result = to; break</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>Masked</name>(value,mask) ((value) &amp; (unsigned) (~(mask)))</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>KEYSYM_FMT</name> "0x%04lX"</cpp:define>	<comment type="block">/* simplify matching &lt;X11/keysymdef.h&gt; */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>TEK4014_GIN</name>(tw) (tw != 0 &amp;&amp; TekScreenOf(tw)-&gt;TekGIN)</cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>KeySym</name></type> <name>keysym</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>is_fkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nbytes</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>STRBUFSIZE</name> 500</cpp:define>
    <decl_stmt><decl><type><name>char</name></type> <name><name>strbuf</name><index>[<expr><name>STRBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>KEY_DATA</name>;</typedef>

<decl_stmt><decl><type><name>static</name>
<name>const</name> <name>char</name> *</type><name>kypd_num</name> =<init> <expr>" XXXXXXXX\tXXX\rXXXxxxxXXXXXXXXXXXXXXXXXXXXX*+,-./0123456789XXX="</expr></init></decl>;</decl_stmt>
<comment type="block">/*                      0123456789 abc def0123456789abcdef0123456789abcdef0123456789abcd */</comment>
<decl_stmt><decl><type><name>static</name>
<name>const</name> <name>char</name> *</type><name>kypd_apl</name> =<init> <expr>" ABCDEFGHIJKLMNOPQRSTUVWXYZ??????abcdefghijklmnopqrstuvwxyzXXX"</expr></init></decl>;</decl_stmt>
<comment type="block">/*                      0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd */</comment>
<decl_stmt><decl><type><name>static</name>
<name>const</name> <name>char</name> *</type><name>curfinal</name> =<init> <expr>"HDACB  FE"</expr></init></decl>;</decl_stmt>

<function_decl><type><name>static</name> <name>int</name></type> <name>decfuncvalue</name><parameter_list>(<param><decl><type><name>KEY_DATA</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>sunfuncvalue</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>hpfuncvalue</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>scofuncvalue</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type></decl></param>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
<function><type><name>static</name> <name>const</name> <name>char</name> *</type>
<name>ModifierName</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>modifier</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>s</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>modifier</name> &amp; <name>ShiftMask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Shift"</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>modifier</name> &amp; <name>LockMask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Lock"</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>modifier</name> &amp; <name>ControlMask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Control"</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>modifier</name> &amp; <name>Mod1Mask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Mod1"</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>modifier</name> &amp; <name>Mod2Mask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Mod2"</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>modifier</name> &amp; <name>Mod3Mask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Mod3"</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>modifier</name> &amp; <name>Mod4Mask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Mod4"</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>modifier</name> &amp; <name>Mod5Mask</name></expr>)</condition><then>
	<expr_stmt><expr><name>s</name> = " Mod5"</expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
    <return>return <expr><name>s</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>FMT_MODIFIER_NAMES</name> "%s%s%s%s%s%s%s%s"</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ARG_MODIFIER_NAMES</name>(state) \
	   ModifierName(state &amp; ShiftMask), \
	   ModifierName(state &amp; LockMask), \
	   ModifierName(state &amp; ControlMask), \
	   ModifierName(state &amp; Mod1Mask), \
	   ModifierName(state &amp; Mod2Mask), \
	   ModifierName(state &amp; Mod3Mask), \
	   ModifierName(state &amp; Mod4Mask), \
	   ModifierName(state &amp; Mod5Mask)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>void</name></type>
<name>AdjustAfterInput</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scrollkey</name> &amp;&amp; <name>screen</name>-&gt;<name>topline</name> != 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>WindowScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>marginbell</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr><name>screen</name>-&gt;<name>max_col</name> - <name>screen</name>-&gt;<name>nmarginbell</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>bellArmed</name> &gt;= 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>bellArmed</name> == <name>screen</name>-&gt;<name>cur_row</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>cur_col</name> &gt;= <name>col</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MarginBell</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>bellArmed</name> = -1</expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>bellArmed</name> =
		    <name>screen</name>-&gt;<name>cur_col</name> &lt; <name>col</name> ? <name>screen</name>-&gt;<name>cur_row</name> : -1</expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>cur_col</name> &lt; <name>col</name></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>bellArmed</name> = <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Return true if the key is on the editing keypad.  This overlaps with
 * IsCursorKey() and IsKeypadKey() and must be tested before those macro to
 * distinguish it from them.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>IsEditFunctionKey</name><parameter_list>(<param><decl><type><name>KeySym</name></type> <name>keysym</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>keysym</name></expr>)</condition> <block>{
    <case>case <expr><name>XK_Prior</name></expr>:		<comment type="block">/* editing keypad */</comment>
    </case><case>case <expr><name>XK_Next</name></expr>:		<comment type="block">/* editing keypad */</comment>
    </case><case>case <expr><name>XK_Insert</name></expr>:		<comment type="block">/* editing keypad */</comment>
    </case><case>case <expr><name>XK_Find</name></expr>:		<comment type="block">/* editing keypad */</comment>
    </case><case>case <expr><name>XK_Select</name></expr>:		<comment type="block">/* editing keypad */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXK_Remove</name></cpp:ifdef>
    </case><case>case <expr><name>DXK_Remove</name></expr>:		<comment type="block">/* editing keypad */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_KP_Delete</name></cpp:ifdef>
    </case><case>case <expr><name>XK_KP_Delete</name></expr>:		<comment type="block">/* editing key on numeric keypad */</comment>
    </case><case>case <expr><name>XK_KP_Insert</name></expr>:		<comment type="block">/* editing key on numeric keypad */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Left_Tab</name></cpp:ifdef>
    </case><case>case <expr><name>XK_ISO_Left_Tab</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>True</name></expr>;</return>
    </case><default>default:
	<return>return <expr><name>False</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IS_CTRL</name>(n) ((n) &lt; ANSI_SPA || ((n) &gt;= 0x7f &amp;&amp; (n) &lt;= 0x9f))</cpp:define>

<comment type="block">/*
 * Return true if the keysym corresponds to one of the control characters,
 * or one of the common ASCII characters that is combined with control to
 * make a control character.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>IsControlInput</name><parameter_list>(<param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>((<name>kd</name>-&gt;<name>keysym</name>) &gt;= 0x40 &amp;&amp; (<name>kd</name>-&gt;<name>keysym</name>) &lt;= 0x7f)</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Bool</name></type>
<name>IsControlOutput</name><parameter_list>(<param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>IS_CTRL</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * X "normally" has some built-in translations, which the user may want to
 * suppress when processing the modifyOtherKeys resource.  In particular, the
 * control modifier applied to some of the keyboard digits gives results for
 * control characters.
 *
 * control 2   0    NUL
 * control SPC 0    NUL
 * control @   0    NUL
 * control `   0    NUL
 * control 3   0x1b ESC
 * control 4   0x1c FS
 * control \   0x1c FS
 * control 5   0x1d GS
 * control 6   0x1e RS
 * control ^   0x1e RS
 * control ~   0x1e RS
 * control 7   0x1f US
 * control /   0x1f US
 * control _   0x1f US
 * control 8   0x7f DEL
 *
 * It is possible that some other keyboards do not work for these combinations,
 * but they do work with modifyOtherKeys=2 for the US keyboard:
 *
 * control `   0    NUL
 * control [   0x1b ESC
 * control \   0x1c FS
 * control ]   0x1d GS
 * control ?   0x7f DEL
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>IsControlAlias</name><parameter_list>(<param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>kd</name>-&gt;<name>nbytes</name> == 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <call><name>IS_CTRL</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * If we are in the non-VT220/VT52 keyboard state, allow modifiers to add a
 * parameter to the function-key control sequences.
 *
 * Note that we generally cannot capture the Shift-modifier for the numeric
 * keypad since this is commonly used to act as a type of NumLock, e.g.,
 * making the keypad send "7" (actually XK_KP_7) where the unshifted code
 * would be Home (XK_KP_Home).  The other modifiers work, subject to the
 * usual window-manager assignments.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>allowModifierParm</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TKeyboard</name> *</type><name>keyboard</name> =<init> <expr>&amp;(<name>xw</name>-&gt;<name>keyboard</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keypad_mode</name> =<init> <expr>((<name>keyboard</name>-&gt;<name>flags</name> &amp; <name>MODE_DECKPAM</name>) != 0)</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>) <name>screen</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!(<call><name>IsKeypadKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call> &amp;&amp; <name>keypad_mode</name>)
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
	&amp;&amp; <name>keyboard</name>-&gt;<name>type</name> != <name>keyboardIsVT220</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	&amp;&amp; <name>screen</name>-&gt;<name>vtXX_level</name> != 0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
* Modifier codes:
*       None                  1
*       Shift                 2 = 1(None)+1(Shift)
*       Alt                   3 = 1(None)+2(Alt)
*       Alt+Shift             4 = 1(None)+1(Shift)+2(Alt)
*       Ctrl                  5 = 1(None)+4(Ctrl)
*       Ctrl+Shift            6 = 1(None)+1(Shift)+4(Ctrl)
*       Ctrl+Alt              7 = 1(None)+2(Alt)+4(Ctrl)
*       Ctrl+Alt+Shift        8 = 1(None)+1(Shift)+2(Alt)+4(Ctrl)
*       Meta                  9 = 1(None)+8(Meta)
*       Meta+Shift           10 = 1(None)+8(Meta)+1(Shift)
*       Meta+Alt             11 = 1(None)+8(Meta)+2(Alt)
*       Meta+Alt+Shift       12 = 1(None)+8(Meta)+1(Shift)+2(Alt)
*       Meta+Ctrl            13 = 1(None)+8(Meta)+4(Ctrl)
*       Meta+Ctrl+Shift      14 = 1(None)+8(Meta)+1(Shift)+4(Ctrl)
*       Meta+Ctrl+Alt        15 = 1(None)+8(Meta)+2(Alt)+4(Ctrl)
*       Meta+Ctrl+Alt+Shift  16 = 1(None)+8(Meta)+1(Shift)+2(Alt)+4(Ctrl)
*/</comment>

<function><type><name>unsigned</name></type>
<name>xtermParamToState</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>param</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <if>if <condition>(<expr><name>param</name> &gt; <name>MOD_NONE</name>
	&amp;&amp; ((<name>ShiftMask</name>
	     | <name>ControlMask</name>
	     | <name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name>
	     | <name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name>) &amp; <name>xw</name>-&gt;<name>misc</name>.<name>other_mods</name>) == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>param</name> - <name>MOD_NONE</name>) &amp; <name>MOD_SHIFT</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>UIntSet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>param</name> - <name>MOD_NONE</name>) &amp; <name>MOD_CTRL</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>UIntSet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>param</name> - <name>MOD_NONE</name>) &amp; <name>MOD_ALT</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>UIntSet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>param</name> - <name>MOD_NONE</name>) &amp; <name>MOD_META</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>UIntSet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr>(<name>void</name>) <name>xw</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>param</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermParamToState(%d) %s%s%s%s -&gt; %#x\n", <name>param</name>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>MOD_SHIFT</name></expr></argument>)</argument_list></call>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>MOD_ALT</name></expr></argument>)</argument_list></call>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>MOD_CTRL</name></expr></argument>)</argument_list></call>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>MOD_META</name></expr></argument>)</argument_list></call>,
	   <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>unsigned</name></type>
<name>xtermStateToParam</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>modify_parm</name> =<init> <expr><name>MOD_NONE</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermStateToParam %#x\n", <name>state</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <if>if <condition>(<expr>(<name>state</name> &amp; <name>xw</name>-&gt;<name>misc</name>.<name>other_mods</name>) == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>state</name> &amp; <name>ShiftMask</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>modify_parm</name> += <name>MOD_SHIFT</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>state</name> &amp; <name>ControlMask</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>modify_parm</name> += <name>MOD_CTRL</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>state</name> &amp; <name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name>) != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>modify_parm</name> += <name>MOD_ALT</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>state</name> &amp; <name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name>) != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>modify_parm</name> += <name>MOD_META</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>modify_parm</name> == <name>MOD_NONE</name></expr>)</condition><then>
	<expr_stmt><expr><name>modify_parm</name> = 0</expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr>(<name>void</name>) <name>xw</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>state</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...xtermStateToParam %d%s%s%s%s\n", <name>modify_parm</name>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>modify_parm</name></expr></argument>, <argument><expr><name>MOD_SHIFT</name></expr></argument>)</argument_list></call>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>modify_parm</name></expr></argument>, <argument><expr><name>MOD_ALT</name></expr></argument>)</argument_list></call>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>modify_parm</name></expr></argument>, <argument><expr><name>MOD_CTRL</name></expr></argument>)</argument_list></call>,
	   <call><name>MODIFIER_NAME</name><argument_list>(<argument><expr><name>modify_parm</name></expr></argument>, <argument><expr><name>MOD_META</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>modify_parm</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>computeMaskedModifier</name>(xw, state, mask) \
	xtermStateToParam(xw, Masked(state, mask))</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
<function><type><name>static</name> <name>unsigned</name></type>
<name>filterAltMeta</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>result</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>mask</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>enable</name></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>(<name>result</name> &amp; <name>mask</name>) != 0</expr>)</condition><then> <block>{
	<comment type="block">/*
	 * metaSendsEscape makes the meta key independent of
	 * modifyOtherKeys.
	 */</comment>
	<if>if <condition>(<expr><name>enable</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> &amp;= ~<name>mask</name></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/*
	 * A bare meta-modifier is independent of modifyOtherKeys.  If it
	 * is combined with other modifiers, make it depend.
	 */</comment>
	<if>if <condition>(<expr>(<name>result</name> &amp; ~(<name>mask</name>)) == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> &amp;= ~<name>mask</name></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/*
	 * Check for special cases of control+meta which are used by some
	 * applications, e.g., emacs.
	 */</comment>
	<if>if <condition>(<expr>(<call><name>IsControlInput</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call>
	     || <call><name>IsControlOutput</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call>)
	    &amp;&amp; (<name>result</name> &amp; <name>ControlMask</name>) != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> &amp;= ~(<name>mask</name> | <name>ControlMask</name>)</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>kd</name>-&gt;<name>keysym</name> == <name>XK_Return</name> || <name>kd</name>-&gt;<name>keysym</name> == <name>XK_Tab</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> &amp;= ~(<name>mask</name> | <name>ControlMask</name>)</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_NUM_LOCK */</comment>

<comment type="block">/*
 * Single characters (not function-keys) are allowed fewer modifiers when
 * interpreting modifyOtherKeys due to pre-existing associations with some
 * modifiers.
 */</comment>
<function><type><name>static</name> <name>unsigned</name></type>
<name>allowedCharModifiers</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>state</name></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>a_or_m</name> =<init> <expr>(<name>state</name> &amp; (<name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name> | <name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name>))</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>a_or_m</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Start by limiting the result to the modifiers we might want to use.
     */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>result</name> =<init> <expr>(<name>state</name> &amp; (<name>ControlMask</name>
				| <name>ShiftMask</name>
				| <name>a_or_m</name>))</expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If modifyOtherKeys is off or medium (0 or 1), moderate its effects by
     * excluding the common cases for modifiers.
     */</comment>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>modify_now</name>.<name>other_keys</name> &lt;= 1</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>IsControlInput</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>Masked</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	    <comment type="block">/* These keys are already associated with the control-key */</comment>
	    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>modify_now</name>.<name>other_keys</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>kd</name>-&gt;<name>keysym</name> == <name>XK_Tab</name> || <name>kd</name>-&gt;<name>keysym</name> == <name>XK_Return</name></expr>)</condition><then> <block>{
	    <empty_stmt>;</empty_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>IsControlAlias</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* Things like "^_" work here... */</comment>
	    <if>if <condition>(<expr><call><name>Masked</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>(<name>ControlMask</name> | <name>ShiftMask</name>)</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <if>if <condition>(<expr>!<call><name>IsControlOutput</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>IsPredefinedKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* Printable keys are already associated with the shift-key */</comment>
	    <if>if <condition>(<expr>!(<name>result</name> &amp; <name>ControlMask</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if></else></if></else></if></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
	<expr_stmt><expr><name>result</name> = <call><name>filterAltMeta</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
			       <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name></expr></argument>,
			       <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>meta_sends_esc</name></expr></argument>, <argument><expr><name>kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>alt_is_not_meta</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <call><name>filterAltMeta</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
				   <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name></expr></argument>,
				   <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>alt_sends_esc</name></expr></argument>, <argument><expr><name>kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...allowedCharModifiers(state=%u" <name>FMT_MODIFIER_NAMES</name>
	   ", ch=" <name>KEYSYM_FMT</name> ") -&gt;"
	   "%u" <name>FMT_MODIFIER_NAMES</name> "\n",
	   <name>state</name>, <call><name>ARG_MODIFIER_NAMES</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call>, <name>kd</name>-&gt;<name>keysym</name>,
	   <name>result</name>, <call><name>ARG_MODIFIER_NAMES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Decide if we should generate a special escape sequence for "other" keys
 * than cursor-, function-keys, etc., as per the modifyOtherKeys resource.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>ModifyOtherKeys</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		<param><decl><type><name>unsigned</name></type> <name>state</name></decl></param>,
		<param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>,
		<param><decl><type><name>unsigned</name></type> <name>modify_parm</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TKeyboard</name> *</type><name>keyboard</name> =<init> <expr>&amp;(<name>xw</name>-&gt;<name>keyboard</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Exclude the keys already covered by a modifier.
     */</comment>
    <if>if <condition>(<expr><name>kd</name>-&gt;<name>is_fkey</name>
	|| <call><name>IsEditFunctionKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call>
	|| <call><name>IsKeypadKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call>
	|| <call><name>IsCursorKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call>
	|| <call><name>IsPFKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call>
	|| <call><name>IsMiscFunctionKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call>
	|| <call><name>IsPrivateKeypadKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
	|| (<name>state</name> &amp; <name>xw</name>-&gt;<name>misc</name>.<name>other_mods</name>) != 0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>modify_parm</name> != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>IsBackarrowToggle</name><argument_list>(<argument><expr><name>keyboard</name></expr></argument>, <argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>kd</name>-&gt;<name>keysym</name> = <name>XK_Delete</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>IsPredefinedKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>state</name> = <call><name>allowedCharModifiers</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>state</name> != 0</expr>)</condition><then> <block>{
	    <switch>switch <condition>(<expr><name>keyboard</name>-&gt;<name>modify_now</name>.<name>other_keys</name></expr>)</condition> <block>{
	    <default>default:
		<break>break;</break>
	    </default><case>case <expr>1</expr>:
		<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
		<case>case <expr><name>XK_BackSpace</name></expr>:
		</case><case>case <expr><name>XK_Delete</name></expr>:
		    <expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
		    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Left_Tab</name></cpp:ifdef>
		</case><case>case <expr><name>XK_ISO_Left_Tab</name></expr>:
		    <if>if <condition>(<expr><call><name>computeMaskedModifier</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt></then></if>
		    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><case>case <expr><name>XK_Return</name></expr>:
		</case><case>case <expr><name>XK_Tab</name></expr>:
		    <expr_stmt><expr><name>result</name> = (<name>modify_parm</name> != 0)</expr>;</expr_stmt>
		    <break>break;</break>
		</case><default>default:
		    <if>if <condition>(<expr><call><name>IsControlInput</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>state</name> == <name>ControlMask</name> || <name>state</name> == <name>ShiftMask</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
			    <expr_stmt><expr><name>result</name> = (<name>modify_parm</name> != 0)</expr>;</expr_stmt>
			}</block></else></if>
		    }</block></then> <else>else <if>if <condition>(<expr><call><name>IsControlAlias</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>state</name> == <name>ShiftMask</name></expr>)</condition><then>
			    <expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><call><name>computeMaskedModifier</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
			}</block></then></if></else></if>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
		    }</block></else></if></else></if>
		    <break>break;</break>
		</default>}</block></switch>
		<break>break;</break>
	    </case><case>case <expr>2</expr>:
		<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
		<case>case <expr><name>XK_BackSpace</name></expr>:
		    <comment type="block">/* strip ControlMask as per IsBackarrowToggle() */</comment>
		    <if>if <condition>(<expr><call><name>computeMaskedModifier</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt></then></if>
		    <break>break;</break>
		</case><case>case <expr><name>XK_Delete</name></expr>:
		    <expr_stmt><expr><name>result</name> = (<call><name>xtermStateToParam</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call> != 0)</expr>;</expr_stmt>
		    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Left_Tab</name></cpp:ifdef>
		</case><case>case <expr><name>XK_ISO_Left_Tab</name></expr>:
		    <if>if <condition>(<expr><call><name>computeMaskedModifier</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt></then></if>
		    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><case>case <expr><name>XK_Return</name></expr>:
		</case><case>case <expr><name>XK_Tab</name></expr>:
		    <expr_stmt><expr><name>result</name> = (<name>modify_parm</name> != 0)</expr>;</expr_stmt>
		    <break>break;</break>
		</case><default>default:
		    <if>if <condition>(<expr><call><name>IsControlInput</name><argument_list>(<argument><expr><name>kd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
		    }</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>ShiftMask</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = (<name>kd</name>-&gt;<name>keysym</name> == ' ' || <name>kd</name>-&gt;<name>keysym</name> == <name>XK_Return</name>)</expr>;</expr_stmt>
		    }</block></then> <else>else <if>if <condition>(<expr><call><name>computeMaskedModifier</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
		    }</block></then></if></else></if></else></if>
		    <break>break;</break>
		</default>}</block></switch>
		<break>break;</break>
	    </case>}</block></switch>
	}</block></then></if>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...ModifyOtherKeys(%d,%d) %s\n",
	   <name>keyboard</name>-&gt;<name>modify_now</name>.<name>other_keys</name>,
	   <name>modify_parm</name>,
	   <call><name>BtoS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>APPEND_PARM</name>(number) \
	    reply-&gt;a_param[reply-&gt;a_nparam] = (ParmType) number; \
	    reply-&gt;a_nparam++</cpp:define>

<comment type="block">/*
 * Function-key code 27 happens to not be used in the vt220-style encoding.
 * xterm uses this to represent modified non-function-keys such as control/+ in
 * the Sun/PC keyboard layout.  See the modifyOtherKeys resource in the manpage
 * for more information.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>modifyOtherKey</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type> <name>reply</name></decl></param>, <param><decl><type><name>int</name></type> <name>input_char</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>modify_parm</name></decl></param>, <param><decl><type><name>int</name></type> <name>format_keys</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>input_char</name> &gt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>format_keys</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>APPEND_PARM</name><argument_list>(<argument><expr><name>input_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>APPEND_PARM</name><argument_list>(<argument><expr><name>modify_parm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>-&gt;<name>a_final</name> = 'u'</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>APPEND_PARM</name><argument_list>(<argument><expr>27</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>APPEND_PARM</name><argument_list>(<argument><expr><name>modify_parm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>APPEND_PARM</name><argument_list>(<argument><expr><name>input_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>-&gt;<name>a_final</name> = '~'</expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>modifyCursorKey</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type> <name>reply</name></decl></param>, <param><decl><type><name>int</name></type> <name>modify</name></decl></param>, <param><decl><type><name>unsigned</name> *</type><name>modify_parm</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>*<name>modify_parm</name> != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>modify</name> &lt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>modify_parm</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>modify</name> &gt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>reply</name>-&gt;<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>	<comment type="block">/* SS3 should not have params */</comment>
	}</block></then></if>
	<if>if <condition>(<expr><name>modify</name> &gt; 1 &amp;&amp; <name>reply</name>-&gt;<name>a_nparam</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>APPEND_PARM</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* force modifier to 2nd param */</comment>
	}</block></then></if>
	<if>if <condition>(<expr><name>modify</name> &gt; 2</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>reply</name>-&gt;<name>a_pintro</name> = '&gt;'</expr>;</expr_stmt>	<comment type="block">/* mark this as "private" */</comment>
	}</block></then></if>
    }</block></then></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>modifyCursorKey</name>(reply, modify, parm)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MOD_FKEYS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
<comment type="block">/*
 * If we have told xterm that our keyboard is really a Sun/PC keyboard, this is
 * enough to make a reasonable approximation to DEC vt220 numeric and editing
 * keypads.
 */</comment>
<function><type><name>static</name> <name>KeySym</name></type>
<name>TranslateFromSUNPC</name><parameter_list>(<param><decl><type><name>KeySym</name></type> <name>keysym</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* *INDENT-OFF* */</comment>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	    <decl_stmt><decl><type><name>KeySym</name></type> <name>before</name>, <name>after</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>table</name><index>[]</index></name> = <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXK_Remove</name></cpp:ifdef>
	<expr><block>{ <expr><name>XK_Delete</name></expr>,       <expr><name>DXK_Remove</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{ <expr><name>XK_Home</name></expr>,         <expr><name>XK_Find</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_End</name></expr>,          <expr><name>XK_Select</name></expr> }</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_KP_Home</name></cpp:ifdef>
	<expr><block>{ <expr><name>XK_Delete</name></expr>,       <expr><name>XK_KP_Decimal</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Delete</name></expr>,    <expr><name>XK_KP_Decimal</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Insert</name></expr>,    <expr><name>XK_KP_0</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_End</name></expr>,       <expr><name>XK_KP_1</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Down</name></expr>,      <expr><name>XK_KP_2</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Next</name></expr>,      <expr><name>XK_KP_3</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Left</name></expr>,      <expr><name>XK_KP_4</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Begin</name></expr>,     <expr><name>XK_KP_5</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Right</name></expr>,     <expr><name>XK_KP_6</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Home</name></expr>,      <expr><name>XK_KP_7</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Up</name></expr>,        <expr><name>XK_KP_8</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>XK_KP_Prior</name></expr>,     <expr><name>XK_KP_9</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr>;</expr_stmt>
    <comment type="block">/* *INDENT-ON* */</comment>

    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>sizeof</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> / <call><name>sizeof</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>before</name> == <name>keysym</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input keypad before was " <name>KEYSYM_FMT</name> "\n", <name>keysym</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>keysym</name> = <name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>after</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input keypad changed to " <name>KEYSYM_FMT</name> "\n", <name>keysym</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
    }</block></for>
    <return>return <expr><name>keysym</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SUNPC_KBD */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>VT52_KEYPAD</name> \
	<name>if_OPT_VT52_MODE</name>(screen,{ \
		reply.a_type = ANSI_ESC; \
		reply.a_pintro = '?'; \
		})</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>VT52_CURSOR_KEYS</name> \
	<name>if_OPT_VT52_MODE</name>(screen,{ \
		reply.a_type = ANSI_ESC; \
		})</cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>APPEND_PARM</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>APPEND_PARM</name>(number) \
	    reply.a_param[reply.a_nparam] = (ParmType) number, \
	    reply.a_nparam++</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODIFIER_PARM</name> \
	if (modify_parm != 0) APPEND_PARM(modify_parm)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODIFIER_PARM</name></cpp:define>		<comment type="block">/*nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Determine if we use the \E[3~ sequence for Delete, or the legacy ^?.  We
 * maintain the delete_is_del value as 3 states:  unspecified(2), true and
 * false.  If unspecified, it is handled differently according to whether the
 * legacy keyboard support is enabled, or if xterm emulates a VT220.
 *
 * Once the user (or application) has specified delete_is_del via resource
 * setting, popup menu or escape sequence, it overrides the keyboard type
 * rather than the reverse.
 */</comment>
<function><type><name>Bool</name></type>
<name>xtermDeleteIsDEL</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> == <name>keyboardIsDefault</name>
	|| <name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> == <name>keyboardIsVT220</name></expr>)</condition><then>
	<expr_stmt><expr><name>result</name> = (<call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>delete_is_del</name> == <name>True</name>)</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> == <name>keyboardIsLegacy</name></expr>)</condition><then>
	<expr_stmt><expr><name>result</name> = (<call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>delete_is_del</name> != <name>False</name>)</expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermDeleteIsDEL(%d/%d) = %d\n",
	   <name>xw</name>-&gt;<name>keyboard</name>.<name>type</name>,
	   <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>delete_is_del</name>,
	   <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>Input</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
      <param><decl><type><name>XKeyEvent</name> *</type> <name>event</name></decl></param>,
      <param><decl><type><name>Bool</name></type> <name>eightbit</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Char</name> *</type><name>string</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TKeyboard</name> *</type><name>keyboard</name> =<init> <expr>&amp;(<name>xw</name>-&gt;<name>keyboard</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>key</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ANSI</name></type> <name>reply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dec_code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>modify_parm</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keypad_mode</name> =<init> <expr>((<name>keyboard</name>-&gt;<name>flags</name> &amp; <name>MODE_DECKPAM</name>) != 0)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>evt_state</name> =<init> <expr><name>event</name>-&gt;<name>state</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>mod_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KEY_DATA</name></type> <name>kd</name></decl>;</decl_stmt>

    <comment type="block">/* Ignore characters typed at the keyboard */</comment>
    <if>if <condition>(<expr><name>keyboard</name>-&gt;<name>flags</name> &amp; <name>MODE_KAM</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>kd</name>.<name>keysym</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>kd</name>.<name>is_fkey</name> = <name>False</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TCAP_QUERY</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>tc_query_code</name> &gt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>kd</name>.<name>keysym</name> = (<name>KeySym</name>) <name>screen</name>-&gt;<name>tc_query_code</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>kd</name>.<name>is_fkey</name> = <name>screen</name>-&gt;<name>tc_query_fkey</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>kd</name>.<name>keysym</name> != <name>XK_BackSpace</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>kd</name>.<name>nbytes</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>kd</name>.<name>nbytes</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = 8</expr>;</expr_stmt>
	}</block></else></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_I18N_SUPPORT</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>xic</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Status</name></type> <name>status_return</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kd</name>.<name>nbytes</name> = <call><name>Xutf8LookupString</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xic</name></expr></argument>, <argument><expr><name>event</name></expr></argument>,
					      <argument><expr><name>kd</name>.<name>strbuf</name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>kd</name>.<name>strbuf</name></expr></argument>)</argument_list></call></expr></argument>,
					      <argument><expr>&amp;<name>kd</name>.<name>keysym</name></expr></argument>, <argument><expr>&amp;<name>status_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <block>{
		<expr_stmt><expr><name>kd</name>.<name>nbytes</name> = <call><name>XmbLookupString</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xic</name></expr></argument>, <argument><expr><name>event</name></expr></argument>,
					    <argument><expr><name>kd</name>.<name>strbuf</name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>kd</name>.<name>strbuf</name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr>&amp;<name>kd</name>.<name>keysym</name></expr></argument>, <argument><expr>&amp;<name>status_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
	    <comment type="block">/*
	     * Fill-in some code useful with IsControlAlias():
	     */</comment>
	    <if>if <condition>(<expr><name>status_return</name> == <name>XLookupBoth</name>
		&amp;&amp; <name>kd</name>.<name>nbytes</name> &lt;= 1
		&amp;&amp; !<call><name>IsPredefinedKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call>
		&amp;&amp; (<name>keyboard</name>-&gt;<name>modify_now</name>.<name>other_keys</name> &gt; 1)
		&amp;&amp; !<call><name>IsControlInput</name><argument_list>(<argument><expr>&amp;<name>kd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kd</name>.<name>nbytes</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = (<name>char</name>) <name>kd</name>.<name>keysym</name></expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MOD_FKEYS */</comment>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_I18N_SUPPORT */</comment>
	<block>{
	    <decl_stmt><decl><type><name>static</name> <name>XComposeStatus</name></type> <name>compose_status</name> =<init>
	    <expr><block>{<expr><name>NULL</name></expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name>kd</name>.<name>nbytes</name> = <call><name>XLookupString</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>kd</name>.<name>strbuf</name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>kd</name>.<name>strbuf</name></expr></argument>)</argument_list></call></expr></argument>,
				      <argument><expr>&amp;<name>kd</name>.<name>keysym</name></expr></argument>, <argument><expr>&amp;<name>compose_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>kd</name>.<name>is_fkey</name> = <call><name>IsFunctionKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Input keysym "
	   <name>KEYSYM_FMT</name>
	   ", %d:'%s'%s" <name>FMT_MODIFIER_NAMES</name> "%s%s%s%s%s%s\n",
	   <name>kd</name>.<name>keysym</name>,
	   <name>kd</name>.<name>nbytes</name>,
	   <call><name>visibleChars</name><argument_list>(<argument><expr>(<name>Char</name> *) <name>kd</name>.<name>strbuf</name></expr></argument>,
			<argument><expr>((<name>kd</name>.<name>nbytes</name> &gt; 0)
			 ? (<name>unsigned</name>) <name>kd</name>.<name>nbytes</name>
			 : 0)</expr></argument>)</argument_list></call>,
	   <call><name>ARG_MODIFIER_NAMES</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>)</argument_list></call>,
	   <name>eightbit</name> ? " 8bit" : " 7bit",
	   <call><name>IsKeypadKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call> ? " KeypadKey" : "",
	   <call><name>IsCursorKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call> ? " CursorKey" : "",
	   <call><name>IsPFKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call> ? " PFKey" : "",
	   <name>kd</name>.<name>is_fkey</name> ? " FKey" : "",
	   <call><name>IsMiscFunctionKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call> ? " MiscFKey" : "",
	   <call><name>IsEditFunctionKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call> ? " EditFkey" : "")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
    <comment type="block">/*
     * DEC keyboards don't have keypad(+), but do have keypad(,) instead.
     * Other (Sun, PC) keyboards commonly have keypad(+), but no keypad(,)
     * - it's a pain for users to work around.
     */</comment>
    <if>if <condition>(<expr><name>keyboard</name>-&gt;<name>type</name> == <name>keyboardIsVT220</name>
	&amp;&amp; (<name>evt_state</name> &amp; <name>ShiftMask</name>) == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>kd</name>.<name>keysym</name> == <name>XK_KP_Add</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>kd</name>.<name>keysym</name> = <name>XK_KP_Separator</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input keypad(+), change keysym to "
		   <name>KEYSYM_FMT</name>
		   "\n",
		   <name>kd</name>.<name>keysym</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>evt_state</name> &amp; <name>ControlMask</name>) != 0
	    &amp;&amp; <name>kd</name>.<name>keysym</name> == <name>XK_KP_Separator</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>kd</name>.<name>keysym</name> = <name>XK_KP_Subtract</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input control/keypad(,), change keysym to "
		   <name>KEYSYM_FMT</name>
		   "\n",
		   <name>kd</name>.<name>keysym</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * The keyboard tables may give us different keypad codes according to
     * whether NumLock is pressed.  Use this check to simplify the process
     * of determining whether we generate an escape sequence for a keypad
     * key, or force it to the value kypd_num[].  There is no fixed
     * modifier for this feature, so we assume that it is the one assigned
     * to the NumLock key.
     *
     * This check used to try to return the contents of strbuf, but that
     * does not work properly when a control modifier is given (trash is
     * returned in the buffer in some cases -- perhaps an X bug).
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <if>if <condition>(<expr><name>kd</name>.<name>nbytes</name> == 1
	&amp;&amp; <call><name>IsKeypadKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call>
	&amp;&amp; <name>xw</name>-&gt;<name>misc</name>.<name>real_NumLock</name>
	&amp;&amp; (<name>xw</name>-&gt;<name>misc</name>.<name>num_lock</name> &amp; <name>evt_state</name>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>keypad_mode</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input num_lock, force keypad_mode off\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>evt_state</name> != 0
	&amp;&amp; <call><name>allowModifierParm</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>kd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>modify_parm</name> = <call><name>xtermStateToParam</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Shift-tab is often mapped to XK_ISO_Left_Tab which is classified as
     * IsEditFunctionKey(), and the conversion does not produce any bytes.
     * Check for this special case so we have data when handling the
     * modifyOtherKeys resource.
     */</comment>
    <if>if <condition>(<expr><name>keyboard</name>-&gt;<name>modify_now</name>.<name>other_keys</name> &gt; 1</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>IsTabKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call> &amp;&amp; <name>kd</name>.<name>nbytes</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>kd</name>.<name>nbytes</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = '\t'</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MOD_FKEYS */</comment>

    <comment type="block">/* VT300 &amp; up: backarrow toggle */</comment>
    <if>if <condition>(<expr>(<name>kd</name>.<name>nbytes</name> == 1)
	&amp;&amp; <call><name>IsBackarrowToggle</name><argument_list>(<argument><expr><name>keyboard</name></expr></argument>, <argument><expr><name>kd</name>.<name>keysym</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = <name>ANSI_DEL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input backarrow changed to %d\n", <name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
    <comment type="block">/* make an DEC editing-keypad from a Sun or PC editing-keypad */</comment>
    <if>if <condition>(<expr><name>keyboard</name>-&gt;<name>type</name> == <name>keyboardIsVT220</name>
	&amp;&amp; (<name>kd</name>.<name>keysym</name> != <name>XK_Delete</name> || !<call><name>xtermDeleteIsDEL</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
	<expr_stmt><expr><name>kd</name>.<name>keysym</name> = <call><name>TranslateFromSUNPC</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_KP_Home</name></cpp:ifdef>
	<if>if <condition>(<expr><name>kd</name>.<name>keysym</name> &gt;= <name>XK_KP_Home</name> &amp;&amp; <name>kd</name>.<name>keysym</name> &lt;= <name>XK_KP_Begin</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input keypad before was " <name>KEYSYM_FMT</name> "\n", <name>kd</name>.<name>keysym</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>kd</name>.<name>keysym</name> += <call>(<name>KeySym</name>) <argument_list>(<argument><expr><name>XK_Home</name> - <name>XK_KP_Home</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Input keypad changed to " <name>KEYSYM_FMT</name> "\n", <name>kd</name>.<name>keysym</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>

    <comment type="block">/*
     * Map the Sun afterthought-keys in as F36 and F37.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SunXK_F36</name></cpp:ifdef>
    <if>if <condition>(<expr>!<name>kd</name>.<name>is_fkey</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>kd</name>.<name>keysym</name> == <name>SunXK_F36</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>kd</name>.<name>keysym</name> = <call><name>XK_Fn</name><argument_list>(<argument><expr>36</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>kd</name>.<name>is_fkey</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>kd</name>.<name>keysym</name> == <name>SunXK_F37</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>kd</name>.<name>keysym</name> = <call><name>XK_Fn</name><argument_list>(<argument><expr>37</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>kd</name>.<name>is_fkey</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Use the control- and shift-modifiers to obtain more function keys than
     * the keyboard provides.  We can do this if there is no conflicting use of
     * those modifiers:
     *
     * a) for VT220 keyboard, we use only the control-modifier.  The keyboard
     * uses shift-modifier for UDK's.
     *
     * b) for non-VT220 keyboards, we only have to check if the
     * modifyFunctionKeys resource is inactive.
     *
     * Thereafter, we note when we have a function-key and keep that
     * distinction when testing for "function-key" values.
     */</comment>
    <if>if <condition>(<expr>(<name>evt_state</name> &amp; (<name>ControlMask</name> | <name>ShiftMask</name>)) != 0
	&amp;&amp; <name>kd</name>.<name>is_fkey</name></expr>)</condition><then> <block>{

	<comment type="block">/* VT220 keyboard uses shift for UDK */</comment>
	<if>if <condition>(<expr><name>keyboard</name>-&gt;<name>type</name> == <name>keyboardIsVT220</name>
	    || <name>keyboard</name>-&gt;<name>type</name> == <name>keyboardIsLegacy</name></expr>)</condition><then> <block>{

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...map XK_F%ld", <name>kd</name>.<name>keysym</name> - <call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>evt_state</name> &amp; <name>ControlMask</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kd</name>.<name>keysym</name> += (<name>KeySym</name>) <name>xw</name>-&gt;<name>misc</name>.<name>ctrl_fkeys</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>(" to XK_F%ld\n", <name>kd</name>.<name>keysym</name> - <call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
	<else>else <if>if <condition>(<expr><name>keyboard</name>-&gt;<name>modify_now</name>.<name>function_keys</name> &lt; 0</expr>)</condition><then> <block>{

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...map XK_F%ld", <name>kd</name>.<name>keysym</name> - <call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>evt_state</name> &amp; <name>ShiftMask</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kd</name>.<name>keysym</name> += <call>(<name>KeySym</name>) <argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>ctrl_fkeys</name> * 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>evt_state</name> &amp; <name>ControlMask</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>kd</name>.<name>keysym</name> += <call>(<name>KeySym</name>) <argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>ctrl_fkeys</name> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>(" to XK_F%ld\n", <name>kd</name>.<name>keysym</name> - <call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	}</block></then></if></else></if>
	<comment type="block">/*
	 * Reevaluate the modifier parameter, stripping off the modifiers
	 * that we just used.
	 */</comment>
	<if>if <condition>(<expr><name>modify_parm</name></expr>)</condition><then>
	    <expr_stmt><expr><name>modify_parm</name> = <call><name>xtermStateToParam</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MOD_FKEYS */</comment>
    }</block></then></if>

    <comment type="block">/*
     * Test for one of the keyboard variants.
     */</comment>
    <switch>switch <condition>(<expr><name>keyboard</name>-&gt;<name>type</name></expr>)</condition> <block>{
    <case>case <expr><name>keyboardIsHP</name></expr>:
	<expr_stmt><expr><call><name>hpfuncvalue</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>&amp;<name>kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>keyboardIsSCO</name></expr>:
	<expr_stmt><expr><call><name>scofuncvalue</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>&amp;<name>kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>keyboardIsSun</name></expr>:
	<expr_stmt><expr><call><name>sunfuncvalue</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>&amp;<name>kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>keyboardIsTermcap</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TCAP_FKEYS</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>xtermcapString</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>int</name>) <name>kd</name>.<name>keysym</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<break>break;</break>
    </case><case>case <expr><name>keyboardIsDefault</name></expr>:
    </case><case>case <expr><name>keyboardIsLegacy</name></expr>:
    </case><case>case <expr><name>keyboardIsVT220</name></expr>:
	<break>break;</break>
    </case>}</block></switch>

    <if>if <condition>(<expr><name>reply</name>.<name>a_final</name></expr>)</condition><then> <block>{
	<comment type="block">/*
	 * The key symbol matches one of the variants.  Most of those are
	 * function-keys, though some cursor- and editing-keys are mixed in.
	 */</comment>
	<expr_stmt><expr><call><name>modifyCursorKey</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>,
			<argument><expr>((<name>kd</name>.<name>is_fkey</name>
			  || <call><name>IsMiscFunctionKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call>
			  || <call><name>IsEditFunctionKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call>)
			 ? <name>keyboard</name>-&gt;<name>modify_now</name>.<name>function_keys</name>
			 : <name>keyboard</name>-&gt;<name>modify_now</name>.<name>cursor_keys</name>)</expr></argument>,
			<argument><expr>&amp;<name>modify_parm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MODIFIER_PARM</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>((<name>kd</name>.<name>is_fkey</name>
		 || <call><name>IsMiscFunctionKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call>
		 || <call><name>IsEditFunctionKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call>)
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
		&amp;&amp; !<call><name>ModifyOtherKeys</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>, <argument><expr>&amp;<name>kd</name></expr></argument>, <argument><expr><name>modify_parm</name></expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	       ) || (<name>kd</name>.<name>keysym</name> == <name>XK_Delete</name>
		     &amp;&amp; ((<name>modify_parm</name> != 0)
			 || !<call><name>xtermDeleteIsDEL</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>dec_code</name> = <call><name>decfuncvalue</name><argument_list>(<argument><expr>&amp;<name>kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>evt_state</name> &amp; <name>ShiftMask</name>)
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
	    &amp;&amp; <name>keyboard</name>-&gt;<name>type</name> == <name>keyboardIsVT220</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    &amp;&amp; ((<name>string</name> = (<name>Char</name> *) <call><name>udk_lookup</name><argument_list>(<argument><expr><name>dec_code</name></expr></argument>, <argument><expr>&amp;<name>kd</name>.<name>nbytes</name></expr></argument>)</argument_list></call>) != 0)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <while>while <condition>(<expr><name>kd</name>.<name>nbytes</name>-- &gt; 0</expr>)</condition>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>string</name>++</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	}</block></then>
	<comment type="block">/*
	 * Interpret F1-F4 as PF1-PF4 for VT52, VT100
	 */</comment>
	<else>else <if>if <condition>(<expr><name>keyboard</name>-&gt;<name>type</name> != <name>keyboardIsLegacy</name>
		 &amp;&amp; (<name>dec_code</name> &gt;= 11 &amp;&amp; <name>dec_code</name> &lt;= 14)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_SS3</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>VT52_CURSOR_KEYS</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = (<name>Char</name>) <call><name>A2E</name><argument_list>(<argument><expr><name>dec_code</name> - 11 + <call><name>E2A</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>modifyCursorKey</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>,
			    <argument><expr><name>keyboard</name>-&gt;<name>modify_now</name>.<name>function_keys</name></expr></argument>,
			    <argument><expr>&amp;<name>modify_parm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>MODIFIER_PARM</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 0</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Left_Tab</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>kd</name>.<name>keysym</name> == <name>XK_ISO_Left_Tab</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'Z'</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
		<if>if <condition>(<expr><name>keyboard</name>-&gt;<name>modify_now</name>.<name>other_keys</name> &gt; 1
		    &amp;&amp; <call><name>computeMaskedModifier</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ShiftMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><call><name>modifyOtherKey</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr>'\t'</expr></argument>, <argument><expr><name>modify_parm</name></expr></argument>, <argument><expr><name>keyboard</name>-&gt;<name>format_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XK_ISO_Left_Tab */</comment>
	    <block>{
		<expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
		<if>if <condition>(<expr><name>kd</name>.<name>is_fkey</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>modifyCursorKey</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>,
				    <argument><expr><name>keyboard</name>-&gt;<name>modify_now</name>.<name>function_keys</name></expr></argument>,
				    <argument><expr>&amp;<name>modify_parm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>MODIFIER_PARM</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = (<name>ParmType</name>) <name>dec_code</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_final</name> = '~'</expr>;</expr_stmt>
	    }</block></else></if>
	    <if>if <condition>(<expr><name>reply</name>.<name>a_final</name> != 0
		&amp;&amp; (<name>reply</name>.<name>a_nparam</name> == 0 || <name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> &gt;= 0)</expr>)</condition><then>
		<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if></else></if>
	<expr_stmt><expr><name>key</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>IsPFKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_SS3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_final</name> = <call>(<name>Char</name>) <argument_list>(<argument><expr>(<name>kd</name>.<name>keysym</name> - <name>XK_KP_F1</name>) + 'P'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>VT52_CURSOR_KEYS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MODIFIER_PARM</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>IsKeypadKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>keypad_mode</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_SS3</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = <call>(<name>Char</name>) <argument_list>(<argument><expr><name><name>kypd_apl</name><index>[<expr><name>kd</name>.<name>keysym</name> - <name>XK_KP_Space</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>VT52_KEYPAD</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>MODIFIER_PARM</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>kypd_num</name><index>[<expr><name>kd</name>.<name>keysym</name> - <name>XK_KP_Space</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>key</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>IsCursorKey</name><argument_list>(<argument><expr><name>kd</name>.<name>keysym</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>keyboard</name>-&gt;<name>flags</name> &amp; <name>MODE_DECCKM</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_SS3</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>modifyCursorKey</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr><name>keyboard</name>-&gt;<name>modify_now</name>.<name>cursor_keys</name></expr></argument>, <argument><expr>&amp;<name>modify_parm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>.<name>a_final</name> = <call>(<name>Char</name>) <argument_list>(<argument><expr><name><name>curfinal</name><index>[<expr><name>kd</name>.<name>keysym</name> - <name>XK_Home</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>VT52_CURSOR_KEYS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MODIFIER_PARM</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>kd</name>.<name>nbytes</name> &gt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>prefix</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>TEK4014_GIN</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TekEnqMouse</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TekGINoff</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>kd</name>.<name>nbytes</name>--</expr>;</expr_stmt>
	    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>kd</name>.<name>nbytes</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
		<expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr><name>j</name></expr>]</index></name> = <name>kd</name>.<name><name>strbuf</name><index>[<expr><name>j</name> + 1</expr>]</index></name></expr>;</expr_stmt>
	    }</block></for>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
	<if>if <condition>(<expr>(<name>keyboard</name>-&gt;<name>modify_now</name>.<name>other_keys</name> &gt; 0)
	    &amp;&amp; <call><name>ModifyOtherKeys</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>, <argument><expr>&amp;<name>kd</name></expr></argument>, <argument><expr><name>modify_parm</name></expr></argument>)</argument_list></call>
	    &amp;&amp; (<name>mod_state</name> = <call><name>allowedCharModifiers</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>, <argument><expr>&amp;<name>kd</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>input_char</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>evt_state</name> = <name>mod_state</name></expr>;</expr_stmt>

	    <expr_stmt><expr><name>modify_parm</name> = <call><name>xtermStateToParam</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>evt_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/*
	     * We want to show a keycode that corresponds to the 8-bit value
	     * of the key.  If the keysym is less than 256, that is good
	     * enough.  Special keys such as Tab may result in a value that
	     * is usable as well.  For the latter (special cases), try to use
	     * the result from the X library lookup.
	     */</comment>
	    <expr_stmt><expr><name>input_char</name> = ((<name>kd</name>.<name>keysym</name> &lt; 256)
			  ? (<name>int</name>) <name>kd</name>.<name>keysym</name>
			  : ((<name>kd</name>.<name>nbytes</name> == 1)
			     ? <call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>
			     : -1))</expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...modifyOtherKeys %d;%d\n", <name>modify_parm</name>, <name>input_char</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>modifyOtherKey</name><argument_list>(<argument><expr>&amp;<name>reply</name></expr></argument>, <argument><expr><name>input_char</name></expr></argument>, <argument><expr><name>modify_parm</name></expr></argument>, <argument><expr><name>keyboard</name>-&gt;<name>format_keys</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MOD_FKEYS */</comment>
	<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
	    <comment type="block">/*
	     * Send ESC if we have a META modifier and metaSendsEcape is true.
	     * Like eightBitInput, except that it is not associated with
	     * terminal settings.
	     */</comment>
	    <if>if <condition>(<expr><name>kd</name>.<name>nbytes</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>meta_sends_esc</name>
		    &amp;&amp; (<name>evt_state</name> &amp; <name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name>) != 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...input-char is modified by META\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>eightbit</name> = <name>False</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>prefix</name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>eightbit</name></expr>)</condition><then> <block>{
		    <comment type="block">/* it might be overridden, but this helps for debugging */</comment>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...input-char is shifted by META\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>alt_is_not_meta</name>
		    &amp;&amp; (<name>evt_state</name> &amp; <name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name>) != 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>alt_sends_esc</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...input-char is modified by ALT\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>eightbit</name> = <name>False</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prefix</name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
		    }</block></then> <else>else <if>if <condition>(<expr>!<name>eightbit</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...input-char is shifted by ALT\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>eightbit</name> = <name>True</name></expr>;</expr_stmt>
		    }</block></then></if></else></if>
		}</block></then></if>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <comment type="block">/*
	     * If metaSendsEscape is false, fall through to this chunk, which
	     * implements the eightBitInput resource.
	     *
	     * It is normally executed when the user presses Meta plus a
	     * printable key, e.g., Meta+space.  The presence of the Meta
	     * modifier is not guaranteed since what really happens is the
	     * "insert-eight-bit" or "insert-seven-bit" action, which we
	     * distinguish by the eightbit parameter to this function.  So the
	     * eightBitInput resource really means that we use this shifting
	     * logic in the "insert-eight-bit" action.
	     */</comment>
	    <if>if <condition>(<expr><name>eightbit</name> &amp;&amp; (<name>kd</name>.<name>nbytes</name> == 1) &amp;&amp; <name>screen</name>-&gt;<name>input_eight_bits</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>IChar</name></type> <name>ch</name> =<init> <expr><call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>ch</name> &lt; 128</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> |= (<name>char</name>) 0x80</expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...input shift from %d to %d (%#x to %#x)\n",
			   <name>ch</name>, <call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>,
			   <name>ch</name>, <call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name></expr>)</condition><then> <block>{
			<comment type="block">/*
			 * We could interpret the incoming code as "in the
			 * current locale", but it's simpler to treat it as
			 * a Unicode value to translate to UTF-8.
			 */</comment>
			<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>kd</name>.<name>nbytes</name> = 2</expr>;</expr_stmt>
			<expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>0xc0 | ((<name>ch</name> &gt;&gt; 6) &amp; 0x3)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>1</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>0x80 | (<name>ch</name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...encoded %#x in UTF-8 as %#x,%#x\n",
			       <name>ch</name>, <call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>, <call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></then></if>
		<expr_stmt><expr><name>eightbit</name> = <name>False</name></expr>;</expr_stmt>
	    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>kd</name>.<name>nbytes</name> == 1</expr>)</condition><then>	<comment type="block">/* cannot do NRC on UTF-8, for instance */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <block>{
		<comment type="block">/* VT220 &amp; up: National Replacement Characters */</comment>
		<if>if <condition>(<expr>(<name>xw</name>-&gt;<name>flags</name> &amp; <name>NATIONAL</name>) != 0</expr>)</condition><then> <block>{
		    <decl_stmt><decl><type><name>unsigned</name></type> <name>cmp</name> =<init> <expr><call><name>xtermCharSetIn</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>screen</name>-&gt;<name><name>keyboard_dialect</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...input NRC %d, %s %d\n",
			   <call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>,
			   (<call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> == <name>cmp</name>)
			   ? "unchanged"
			   : "changed to",
			   <call><name>CharOf</name><argument_list>(<argument><expr><name>cmp</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = (<name>char</name>) <name>cmp</name></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>eightbit</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>prefix</name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> == '?'
			   &amp;&amp; (<name>evt_state</name> &amp; <name>ControlMask</name>) != 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr>0</expr>]</index></name> = <name>ANSI_DEL</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>evt_state</name></expr></argument>, <argument><expr><name>ControlMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if></else></if>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>prefix</name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="block">/* escape */</comment>
	    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>kd</name>.<name>nbytes</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name>kd</name>.<name><name>strbuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	}</block></else></if>
	<expr_stmt><expr><name>key</name> = ((<name>kd</name>.<name>keysym</name> != <name>ANSI_XOFF</name>) &amp;&amp; (<name>kd</name>.<name>keysym</name> != <name>ANSI_XON</name>))</expr>;</expr_stmt>
    }</block></then></if></else></if></else></if></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>key</name> &amp;&amp; !<call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>AdjustAfterInput</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>xtermShowPointer</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>StringInput</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>Char</name> *</type> <name>string</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
    <macro><name>TRACE</name><argument_list>(<argument>("InputString (%s,%lu)\n",
	   visibleChars(string, (unsigned) nbytes),
	   (unsigned long) nbytes)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><name>nbytes</name> &amp;&amp; <call><name>TEK4014_GIN</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TekEnqMouse</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr>*<name>string</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TekGINoff</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name>--</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>nbytes</name>-- != 0</expr>)</condition>
	<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>*<name>string</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <if>if <condition>(<expr>!<call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>AdjustAfterInput</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* These definitions are DEC-style (e.g., vt320) */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>decfuncvalue</name><parameter_list>(<param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>kd</name>-&gt;<name>is_fkey</name></expr>)</condition><then> <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>11</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>13</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>14</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>15</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>17</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>18</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>19</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>9</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>21</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>11</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>23</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>13</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>25</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>14</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>26</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>15</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>28</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>29</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>17</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>31</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>18</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>19</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>33</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>34</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<default>default:
	    <comment type="block">/* after F20 the codes are made up and do not correspond to any
	     * real terminal.  So they are simply numbered sequentially.
	     */</comment>
	    <expr_stmt><expr><name>result</name> = 42 + <call>(<name>int</name>) <argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name> - <call><name>XK_Fn</name><argument_list>(<argument><expr>21</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></then> <else>else <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Find</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Insert</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Delete</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_KP_Insert</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_KP_Insert</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_KP_Delete</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXK_Remove</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>DXK_Remove</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Select</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Prior</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Next</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Left_Tab</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_ISO_Left_Tab</name></expr></argument>, <argument><expr>'Z'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Help</name></expr></argument>, <argument><expr>28</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Menu</name></expr></argument>, <argument><expr>29</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<default>default:
	    <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></else></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>hpfuncvalue</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type> <name>reply</name></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HP_FUNC_KEYS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>kd</name>-&gt;<name>is_fkey</name></expr>)</condition><then> <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'p'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'q'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'r'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'s'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'t'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'u'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'v'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'w'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<default>default:
	    <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></then> <else>else <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Up</name></expr></argument>, <argument><expr>'A'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Down</name></expr></argument>, <argument><expr>'B'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Right</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Left</name></expr></argument>, <argument><expr>'D'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_End</name></expr></argument>, <argument><expr>'F'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Clear</name></expr></argument>, <argument><expr>'J'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Delete</name></expr></argument>, <argument><expr>'P'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Insert</name></expr></argument>, <argument><expr>'Q'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Next</name></expr></argument>, <argument><expr>'S'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Prior</name></expr></argument>, <argument><expr>'T'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Home</name></expr></argument>, <argument><expr>'h'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_KP_Insert</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_KP_Delete</name></expr></argument>, <argument><expr>'P'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_KP_Insert</name></expr></argument>, <argument><expr>'Q'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXK_Remove</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>DXK_Remove</name></expr></argument>, <argument><expr>'P'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Select</name></expr></argument>, <argument><expr>'F'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Find</name></expr></argument>, <argument><expr>'h'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<default>default:
	    <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></else></if>
    <if>if <condition>(<expr><name>result</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_type</name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_final</name> = (<name>Char</name>) <name>result</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr>(<name>void</name>) <name>reply</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>kd</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_HP_FUNC_KEYS */</comment>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>scofuncvalue</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type> <name>reply</name></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCO_FUNC_KEYS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>kd</name>-&gt;<name>is_fkey</name></expr>)</condition><then> <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'M'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'O'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'P'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'Q'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'R'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'S'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'T'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>9</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'U'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'V'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>11</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'W'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'X'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>13</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'Y'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>14</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'Z'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>15</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'a'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'b'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>17</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'c'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>18</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'d'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>19</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'e'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'f'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>21</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'g'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>22</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'h'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>23</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'i'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'j'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>25</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'k'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>26</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'l'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>27</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'m'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>28</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>29</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'o'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>30</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'p'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>31</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'q'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'r'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>33</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'s'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>34</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'t'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>35</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'u'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>36</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'v'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>37</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'w'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>38</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'x'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>39</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'y'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>40</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'z'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>41</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'@'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>42</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'['</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>43</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>44</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>45</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'^'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>46</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'_'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>47</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'`'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>48</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>'{'</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no matching '}' */</comment>
	<default>default:
	    <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></then> <else>else <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Up</name></expr></argument>, <argument><expr>'A'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Down</name></expr></argument>, <argument><expr>'B'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Right</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Left</name></expr></argument>, <argument><expr>'D'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Begin</name></expr></argument>, <argument><expr>'E'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_End</name></expr></argument>, <argument><expr>'F'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Insert</name></expr></argument>, <argument><expr>'L'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Next</name></expr></argument>, <argument><expr>'G'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Prior</name></expr></argument>, <argument><expr>'I'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Home</name></expr></argument>, <argument><expr>'H'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_KP_Insert</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_KP_Insert</name></expr></argument>, <argument><expr>'L'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<default>default:
	    <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></else></if>
    <if>if <condition>(<expr><name>result</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_final</name> = (<name>Char</name>) <name>result</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr>(<name>void</name>) <name>reply</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>kd</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SCO_FUNC_KEYS */</comment>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>sunfuncvalue</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type> <name>reply</name></decl></param>, <param><decl><type><name>KEY_DATA</name> *</type> <name>kd</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUN_FUNC_KEYS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>ParmType</name></type> <name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>kd</name>-&gt;<name>is_fkey</name></expr>)</condition><then> <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <comment type="block">/* kf1-kf20 are numbered sequentially */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>224</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>225</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>226</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>227</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>228</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>229</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>230</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>231</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>9</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>232</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>233</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>11</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>192</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>193</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>13</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>194</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>14</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>195</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kund */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>15</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>196</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>197</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kcpy */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>17</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>198</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>18</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>199</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>19</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>200</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kfnd */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>201</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* kf31-kf36 are numbered sequentially */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>21</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>208</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf31 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>22</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>209</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>23</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>210</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>211</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>25</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>212</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>26</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>213</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf36 */</comment>

	    <comment type="block">/* kf37-kf47 are interspersed with keypad keys */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>27</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>214</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* khome */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>28</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>215</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf38 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>29</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>216</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kpp */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>30</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>217</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf40 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>31</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>218</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kb2 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>219</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf42 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>33</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>220</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kend */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>34</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>221</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf44 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>35</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>222</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* knp */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>36</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>234</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf46 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><call><name>XK_Fn</name><argument_list>(<argument><expr>37</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>235</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf47 */</comment>
	<default>default:
	    <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></then> <else>else <block>{
	<switch>switch <condition>(<expr><name>kd</name>-&gt;<name>keysym</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Help</name></expr></argument>, <argument><expr>196</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* khlp */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Menu</name></expr></argument>, <argument><expr>197</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Find</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Insert</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kich1 */</comment>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Delete</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_KP_Insert</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_KP_Insert</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_KP_Delete</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DXK_Remove</name></cpp:ifdef>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>DXK_Remove</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Select</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Prior</name></expr></argument>, <argument><expr>216</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Next</name></expr></argument>, <argument><expr>222</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Home</name></expr></argument>, <argument><expr>214</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_End</name></expr></argument>, <argument><expr>220</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MAP</name><argument_list>(<argument><expr><name>XK_Begin</name></expr></argument>, <argument><expr>218</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* kf41=kb2 */</comment>

	<default>default:
	    <expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></else></if>
    <if>if <condition>(<expr><name>result</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_nparam</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>-&gt;<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = <name>result</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_final</name> = 'z'</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>IsCursorKey</name><argument_list>(<argument><expr><name>kd</name>-&gt;<name>keysym</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_type</name> = <name>ANSI_SS3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reply</name>-&gt;<name>a_final</name> = (<name>Char</name>) <name><name>curfinal</name><index>[<expr><name>kd</name>-&gt;<name>keysym</name> - <name>XK_Home</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr>(<name>void</name>) <name>reply</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>kd</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SUN_FUNC_KEYS */</comment>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>isName</name>(c) ((c) == '_' || (c) == '-' || isalnum(CharOf(c)))</cpp:define>

<function><type><name>static</name> <name>const</name> <name>char</name> *</type>
<name>skipName</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr>*<name>s</name> != '\0' &amp;&amp; <call><name>isName</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt></while>
    <return>return <expr><name>s</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Found a ":" in a translation, check what is past it to see if it contains
 * any of the insert-text action names.
 */</comment>
<function><type><name>static</name> <name>Boolean</name></type>
<name>keyCanInsert</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>parse</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Boolean</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>escape</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>quoted</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name><name>table</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr>"insert"</expr>,
	<expr>"insert-seven-bit"</expr>,
	<expr>"insert-eight-bit"</expr>,
	<expr>"string"</expr>,
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>*<name>parse</name> != '\0' &amp;&amp; *<name>parse</name> != '\n'</expr>)</condition> <block>{
	<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr>*<name>parse</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>escape</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>escape</name> = <name>False</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '\\'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>escape</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '"'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>quoted</name> = (<name>Boolean</name>) ! <name>quoted</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr>!<name>quoted</name> &amp;&amp; <call><name>isName</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>next</name> =<init> <expr><call><name>skipName</name><argument_list>(<argument><expr>--<name>parse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>size_t</name></type> <name>need</name> =<init> <expr><call>(<name>size_t</name>) <argument_list>(<argument><expr><name>next</name> - <name>parse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		<if>if <condition>(<expr><name>need</name> == <call><name>strlen</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call>
		    &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
		    <break>break;</break>
		}</block></then></if>
	    }</block></for>
	    <expr_stmt><expr><name>parse</name> = <name>next</name></expr>;</expr_stmt>
	}</block></then></if></else></if></else></if></else></if>

    }</block></while>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Strip the entire action, to avoid matching it.
 */</comment>
<function><type><name>static</name> <name>char</name> *</type>
<name>stripAction</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>base</name></decl></param>, <param><decl><type><name>char</name> *</type><name>last</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name>last</name> != <name>base</name></expr>)</condition> <block>{
	<if>if <condition>(<expr>*--<name>last</name> == '\n'</expr>)</condition><then> <block>{
	    <break>break;</break>
	}</block></then></if>
    }</block></while>
    <return>return <expr><name>last</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>char</name> *</type>
<name>stripBlanks</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>base</name></decl></param>, <param><decl><type><name>char</name> *</type><name>last</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name>last</name> != <name>base</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ch</name> =<init> <expr><call><name>CharOf</name><argument_list>(<argument><expr><name><name>last</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>ch</name> != ' ' &amp;&amp; <name>ch</name> != '\t'</expr>)</condition><then>
	    <break>break;</break></then></if>
	<expr_stmt><expr>--<name>last</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>last</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Strip unneeded whitespace from a translations resource, mono-casing and
 * returning a malloc'd copy of the result.
 */</comment>
<function><type><name>static</name> <name>char</name> *</type>
<name>stripTranslations</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>onlyInsert</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>dst</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>dst</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>dst</name> != 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>state</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>ch</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>prv</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>char</name> *</type><name>d</name> =<init> <expr><name>dst</name></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("stripping:\n%s\n", <name>s</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <while>while <condition>(<expr>*<name>s</name> != '\0'</expr>)</condition> <block>{
		<expr_stmt><expr><name>ch</name> = *<name>s</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ch</name> == '\n'</expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><name>d</name> != <name>dst</name></expr>)</condition><then>
			<expr_stmt><expr>*<name>d</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></then></if>
		    <expr_stmt><expr><name>state</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr>":!#"</expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>d</name> = <call><name>stripBlanks</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>onlyInsert</name> &amp;&amp; (<name>ch</name> == ':') &amp;&amp; !<call><name>keyCanInsert</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>d</name> = <call><name>stripAction</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
		    <expr_stmt><expr><name>state</name> = -1</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>state</name> &gt;= 0</expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>state</name> == 0 || <call><name>strchr</name><argument_list>(<argument><expr>"&lt;&gt;~ \t"</expr></argument>, <argument><expr><name>prv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			    <continue>continue;</continue></then></if>
		    }</block></then> <else>else <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr>"&lt;&gt;~"</expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>d</name> = <call><name>stripBlanks</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if></else></if>
		    <expr_stmt><expr>*<name>d</name>++ = <call><name>x_toupper</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr>++<name>state</name></expr>;</expr_stmt>
		}</block></then></if></else></if></else></if>
		<expr_stmt><expr><name>prv</name> = <name>ch</name></expr>;</expr_stmt>
	    }</block></while>
	    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...result:\n%s\n", <name>dst</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>dst</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Make a simple check to see if a given translations keyword appears in
 * xterm's translations resource.  It does not attempt to parse the strings,
 * just makes a case-independent check and ensures that the ends of the match
 * are on token-boundaries.
 *
 * That this can only retrieve translations that are given as resource values;
 * the default translations in charproc.c for example are not retrievable by
 * any interface to X.
 *
 * Also:  We can retrieve only the most-specified translation resource.  For
 * example, if the resource file specifies both "*translations" and
 * "XTerm*translations", we see only the latter.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>TranslationsUseKeyword</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>, <param><decl><type><name>char</name> **</type><name>cache</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>keyword</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>onlyInsert</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>String</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>XtResource</name></type> <name><name>key_resources</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr><block>{<expr><name>XtNtranslations</name></expr>, <expr><name>XtCTranslations</name></expr>, <expr><name>XtRString</name></expr>,
	 <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr>, <expr><name>XtRString</name></expr>, <expr>(<name>XtPointer</name>) <name>NULL</name></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>copy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>test</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>test</name> = <call><name>stripTranslations</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>onlyInsert</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>*<name>cache</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XtGetSubresources</name><argument_list>(<argument><expr><name>w</name></expr></argument>,
			      <argument><expr>(<name>XtPointer</name>) &amp;<name>data</name></expr></argument>,
			      <argument><expr>"vt100"</expr></argument>,
			      <argument><expr>"VT100"</expr></argument>,
			      <argument><expr><name>key_resources</name></expr></argument>,
			      <argument><expr><call><name>XtNumber</name><argument_list>(<argument><expr><name>key_resources</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><name>NULL</name></expr></argument>,
			      <argument><expr>(<name>Cardinal</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>data</name> != 0 &amp;&amp; (<name>copy</name> = <call><name>stripTranslations</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>onlyInsert</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>cache</name> = <name>copy</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr>*<name>cache</name> != 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>char</name> *</type><name>p</name> =<init> <expr>*<name>cache</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>state</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>now</name> =<init> <expr>' '</expr>, <expr><name>prv</name></expr></init></decl>;</decl_stmt>

	    <while>while <condition>(<expr>*<name>p</name> != 0</expr>)</condition> <block>{
		<expr_stmt><expr><name>prv</name> = <name>now</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>now</name> = *<name>p</name>++</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>now</name> == ':'
		    || <name>now</name> == '!'</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>state</name> = -1</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>now</name> == '\n'</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>state</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>state</name> &gt;= 0</expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><name>now</name> == <name><name>test</name><index>[<expr><name>state</name></expr>]</index></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>state</name> != 0
			     || !<call><name>isName</name><argument_list>(<argument><expr><name>prv</name></expr></argument>)</argument_list></call>)
			    &amp;&amp; ((<name><name>test</name><index>[<expr>++<name>state</name></expr>]</index></name> == 0)
				&amp;&amp; !<call><name>isName</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
			    <break>break;</break>
			}</block></then></if>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><name>state</name> = 0</expr>;</expr_stmt>
		    }</block></else></if>
		}</block></then></if></else></if></else></if>
	    }</block></while>
	}</block></then></if>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("TranslationsUseKeyword(%p, %s) = %d\n",
	   (<name>void</name> *) <name>w</name>, <name>keyword</name>, <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Bool</name></type>
<name>xtermHasTranslation</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>keyword</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>onlyInsert</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>TranslationsUseKeyword</name><argument_list>(<argument><expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr>&amp;(<name>xw</name>-&gt;<name>keyboard</name>.<name>shell_translations</name>)</expr></argument>,
				   <argument><expr><name>keyword</name></expr></argument>,
				   <argument><expr><name>onlyInsert</name></expr></argument>)</argument_list></call>
	    || <call><name>TranslationsUseKeyword</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>,
				      <argument><expr>&amp;(<name>xw</name>-&gt;<name>keyboard</name>.<name>xterm_translations</name>)</expr></argument>,
				      <argument><expr><name>keyword</name></expr></argument>,
				      <argument><expr><name>onlyInsert</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXTRA_PASTE</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>addTranslation</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>fromString</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>toString</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>have</name> =<init> <expr>(<name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name>
		   ? <call><name>strlen</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr></argument>)</argument_list></call>
		   : 0)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>need</name> =<init> <expr>(((<name>have</name> != 0) ? (<name>have</name> + 4) : 0)
		   + <call><name>strlen</name><argument_list>(<argument><expr><name>fromString</name></expr></argument>)</argument_list></call>
		   + <call><name>strlen</name><argument_list>(<argument><expr><name>toString</name></expr></argument>)</argument_list></call>
		   + 6)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>xtermHasTranslation</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fromString</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name>
	    = <call><name>TypeRealloc</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>need</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name>) != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("adding %s: %s\n", <name>fromString</name>, <name>toString</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>have</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr></argument>, <argument><expr>" \\n\\"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr></argument>, <argument><expr>"%s: %s"</expr></argument>,
		    <argument><expr><name>fromString</name></expr></argument>, <argument><expr><name>toString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...{%s}\n", <name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>SaveMask</name>(name)	xw-&gt;misc.name |= (unsigned) mask;\
			TRACE(("SaveMask(%s) %#x (%#x is%s modifier)\n", \
				#name, \
				xw-&gt;misc.name, (unsigned) mask, \
				ModifierName((unsigned) mask)));</cpp:define>
<comment type="block">/*
 * Determine which modifier mask (if any) applies to the Num_Lock keysym.
 *
 * Also, determine which modifiers are associated with the ALT keys, so we can
 * send that information as a parameter for special keys in Sun/PC keyboard
 * mode.  However, if the ALT modifier is used in translations, we do not want
 * to confuse things by sending the parameter.
 */</comment>
<function><type><name>void</name></type>
<name>VTInitModifiers</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XModifierKeymap</name> *</type><name>keymap</name> =<init> <expr><call><name>XGetModifierMapping</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name>, <name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KeySym</name></type> <name>keysym</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>min_keycode</name>, <name>max_keycode</name>, <name>keysyms_per_keycode</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>keymap</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>KeySym</name> *</type><name>theMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>keycode_count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTInitModifiers\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XDisplayKeycodes</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>&amp;<name>min_keycode</name></expr></argument>, <argument><expr>&amp;<name>max_keycode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keycode_count</name> = (<name>max_keycode</name> - <name>min_keycode</name> + 1)</expr>;</expr_stmt>
	<expr_stmt><expr><name>theMap</name> = <call><name>XGetKeyboardMapping</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>,
				     <argument><expr>(<name>KeyCode</name>) <name>min_keycode</name></expr></argument>,
				     <argument><expr><name>keycode_count</name></expr></argument>,
				     <argument><expr>&amp;<name>keysyms_per_keycode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>theMap</name> != 0</expr>)</condition><then> <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXTRA_PASTE</name></expr></cpp:if>
	    <comment type="block">/*
	     * Assume that if we can find the paste keysym in the X keyboard
	     * mapping that the server allows the corresponding translations
	     * resource.
	     */</comment>
	    <decl_stmt><decl><type><name>int</name></type> <name>limit</name> =<init> <expr>(<name>max_keycode</name> - <name>min_keycode</name>) * <name>keysyms_per_keycode</name></expr></init></decl>;</decl_stmt>
	    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>limit</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XF86XK_Paste</name></cpp:ifdef>
		<if>if <condition>(<expr><name><name>theMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>XF86XK_Paste</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("keyboard has XF86XK_Paste\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>addTranslation</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				   <argument><expr>"&lt;KeyPress&gt; XF86Paste"</expr></argument>,
				   <argument><expr>"insert-selection(SELECT, CUT_BUFFER0)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SunXK_Paste</name></cpp:ifdef>
		<if>if <condition>(<expr><name><name>theMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>SunXK_Paste</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("keyboard has SunXK_Paste\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>addTranslation</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				   <argument><expr>"&lt;KeyPress&gt; SunPaste"</expr></argument>,
				   <argument><expr>"insert-selection(SELECT, CUT_BUFFER0)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_EXTRA_PASTE */</comment>

	    <for>for (<init><expr><name>i</name> = <name>k</name> = 0</expr>, <expr><name>mask</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 8</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>mask</name> &lt;&lt;= 1</expr></incr>) <block>{
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>keymap</name>-&gt;<name>max_keypermod</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
		    <decl_stmt><decl><type><name>KeyCode</name></type> <name>code</name> =<init> <expr><name>keymap</name>-&gt;<name><name>modifiermap</name><index>[<expr><name>k</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
		    <if>if <condition>(<expr><name>code</name> == 0</expr>)</condition><then>
			<continue>continue;</continue></then></if>

		    <for>for (<init><expr><name>l</name> = 0</expr>;</init> <condition><expr><name>l</name> &lt; <name>keysyms_per_keycode</name></expr>;</condition> <incr><expr>++<name>l</name></expr></incr>) <block>{
			<expr_stmt><expr><name>keysym</name> = <call><name>XKeycodeToKeysym</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>keysym</name> == <name>NoSymbol</name></expr>)</condition><then> <block>{
			    <empty_stmt>;</empty_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><name>keysym</name> == <name>XK_Num_Lock</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>SaveMask</name><argument_list>(<argument><expr><name>num_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><name>keysym</name> == <name>XK_Alt_L</name> || <name>keysym</name> == <name>XK_Alt_R</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>SaveMask</name><argument_list>(<argument><expr><name>alt_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><name>keysym</name> == <name>XK_Meta_L</name> || <name>keysym</name> == <name>XK_Meta_R</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>SaveMask</name><argument_list>(<argument><expr><name>meta_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><name>mask</name> == <name>ShiftMask</name>
				   &amp;&amp; (<name>keysym</name> == <name>XK_Shift_L</name>
				       || <name>keysym</name> == <name>XK_Shift_R</name>)</expr>)</condition><then> <block>{
			    <empty_stmt>;</empty_stmt>	<comment type="block">/* ignore */</comment>
			}</block></then> <else>else <if>if <condition>(<expr><name>mask</name> == <name>ControlMask</name>
				   &amp;&amp; (<name>keysym</name> == <name>XK_Control_L</name>
				       || <name>keysym</name> == <name>XK_Control_R</name>)</expr>)</condition><then> <block>{
			    <empty_stmt>;</empty_stmt>	<comment type="block">/* ignore */</comment>
			}</block></then> <else>else <if>if <condition>(<expr><name>mask</name> == <name>LockMask</name>
				   &amp;&amp; (<name>keysym</name> == <name>XK_Caps_Lock</name>)</expr>)</condition><then> <block>{
			    <empty_stmt>;</empty_stmt>	<comment type="block">/* ignore */</comment>
			}</block></then> <else>else <if>if <condition>(<expr><name>keysym</name> == <name>XK_Mode_switch</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XK_ISO_Level3_Shift</name></cpp:ifdef>
				   || <name>keysym</name> == <name>XK_ISO_Level3_Shift</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			    )</condition><then> <block>{
			    <expr_stmt><expr><call><name>SaveMask</name><argument_list>(<argument><expr><name>other_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
		    }</block></for>
		}</block></for>
	    }</block></for>
	    <expr_stmt><expr><call><name>XFree</name><argument_list>(<argument><expr><name>theMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Don't disable any mods if "alwaysUseMods" is true. */</comment>
	<if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>alwaysUseMods</name></expr>)</condition><then> <block>{

	    <comment type="block">/*
	     * Force TranslationsUseKeyword() to reload.
	     */</comment>
	    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>shell_translations</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>shell_translations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>shell_translations</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>xterm_translations</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>xterm_translations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>xterm_translations</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/*
	     * If the Alt modifier is used in translations, we would rather not
	     * use it to modify function-keys when NumLock is active.
	     */</comment>
	    <if>if <condition>(<expr>(<name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name> != 0)
		&amp;&amp; <call><name>xtermHasTranslation</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>"alt"</expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ALT is used as a modifier in translations (ignore mask)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>alt_mods</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/*
	     * If the Meta modifier is used in translations, we would rather not
	     * use it to modify function-keys.
	     */</comment>
	    <if>if <condition>(<expr>(<name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name> != 0)
		&amp;&amp; <call><name>xtermHasTranslation</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>"meta"</expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("META is used as a modifier in translations\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>meta_mods</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>XFreeModifiermap</name><argument_list>(<argument><expr><name>keymap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_NUM_LOCK */</comment>
</unit>
