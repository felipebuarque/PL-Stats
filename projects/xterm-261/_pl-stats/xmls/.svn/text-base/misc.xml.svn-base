<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" dir="" filename="misc.c"><comment type="block">/* $XTermId: misc.c,v 1.503 2010/06/20 21:33:49 tom Exp $ */</comment>

<comment type="block">/*
 * Copyright 1999-2009,2010 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;version.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;main.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/keysym.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xatom.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/cursorfont.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xlocale.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/Error.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/SysUtil.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/WinUtil.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/Xmu.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_X11_SUNKEYSYM_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Sunkeysym.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LANGINFO_CODESET</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;langinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xutf8.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;data.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;error.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;menu.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fontutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xcharmouse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xstrings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xtermcap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;VTparse.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>XtSpecificationRelease</name> &lt; 6)</expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>X_GETTIMEOFDAY</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>X_GETTIMEOFDAY</name>(t) gettimeofday(t,(struct timezone *)0)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>XTERM_VMS_LOGFILE</name> "SYS$SCRATCH:XTERM_LOG.TXT"</cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGFILEEXEC</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ALLOWLOGFILEEXEC</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>OUR_EVENT</name>(event,Type) \
		(event.type == Type &amp;&amp; \
		  (event.xcrossing.window == XtWindow(XtParent(xw)) || \
		    (tekWidget &amp;&amp; \
		     event.xcrossing.window == XtWindow(XtParent(tekWidget)))))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>OUR_EVENT</name>(event,Type) \
		(event.type == Type &amp;&amp; \
		   (event.xcrossing.window == XtWindow(XtParent(xw))))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>static</name> <name>Cursor</name></type> <name>make_hidden_cursor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXEC_XTERM</name></expr></cpp:if>
<comment type="block">/* Like readlink(2), but returns a malloc()ed buffer, or NULL on
   error; adapted from libc docs */</comment>
<function><type><name>static</name> <name>char</name> *</type>
<name>Readlink</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> =<init> <expr>100</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
	<expr_stmt><expr><name>buf</name> = <call><name>TypeRealloc</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> = (<name>int</name>) <call><name>readlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>(<name>unsigned</name>) <name>n</name> &lt; <name>size</name></expr>)</condition><then> <block>{
	    <return>return <expr><name>buf</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>size</name> *= 2</expr>;</expr_stmt>
    }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_EXEC_XTERM */</comment>

<function><type><name>static</name> <name>void</name></type>
<name>Sleep</name><parameter_list>(<param><decl><type><name>int</name></type> <name>msec</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> struct <name>timeval</name></type> <name>select_timeout</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>select_timeout</name>.<name>tv_sec</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>select_timeout</name>.<name>tv_usec</name> = <name>msec</name> * 1000</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>select</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>select_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>selectwindow</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>flag</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("selectwindow(%d) flag=%d\n", <name>screen</name>-&gt;<name>select</name>, <name>flag</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>!<name>Ttoggled</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>TCursorToggle</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr><name>TOGGLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>select</name> |= <name>flag</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>Ttoggled</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>TCursorToggle</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr><name>TOGGLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>xic</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>XSetICFocus</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> &amp;&amp; <call><name>CursorMoved</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>select</name> |= <name>flag</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>ShowCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>GetScrollLock</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>unselectwindow</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>flag</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("unselectwindow(%d) flag=%d\n", <name>screen</name>-&gt;<name>select</name>, <name>flag</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>hide_pointer</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>hide_pointer</name> = <name>False</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermDisplayCursor</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>always_highlight</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>!<name>Ttoggled</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>TCursorToggle</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr><name>TOGGLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>select</name> &amp;= ~<name>flag</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<name>Ttoggled</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>TCursorToggle</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>, <argument><expr><name>TOGGLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>xic</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>XUnsetICFocus</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	    <expr_stmt><expr><name>screen</name>-&gt;<name>select</name> &amp;= ~<name>flag</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> &amp;&amp; <call><name>CursorMoved</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>ShowCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></else></if>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>DoSpecialEnterNotify</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEnterWindowEvent</name> *</type> <name>ev</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DoSpecialEnterNotify(%d)\n", <name>screen</name>-&gt;<name>select</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FOCUS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>((<name>ev</name>-&gt;<name>detail</name>) != <name>NotifyInferior</name>) &amp;&amp;
	<name>ev</name>-&gt;<name>focus</name> &amp;&amp;
	!(<name>screen</name>-&gt;<name>select</name> &amp; <name>FOCUS</name>)</expr>)</condition><then>
	<expr_stmt><expr><call><name>selectwindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>INWINDOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>DoSpecialLeaveNotify</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XEnterWindowEvent</name> *</type> <name>ev</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DoSpecialLeaveNotify(%d)\n", <name>screen</name>-&gt;<name>select</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FOCUS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>((<name>ev</name>-&gt;<name>detail</name>) != <name>NotifyInferior</name>) &amp;&amp;
	<name>ev</name>-&gt;<name>focus</name> &amp;&amp;
	!(<name>screen</name>-&gt;<name>select</name> &amp; <name>FOCUS</name>)</expr>)</condition><then>
	<expr_stmt><expr><call><name>unselectwindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>INWINDOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XUrgencyHint</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>XUrgencyHint</name> (1L &lt;&lt; 8)</cpp:define>	<comment type="block">/* X11R5 does not define */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>void</name></type>
<name>setXUrgency</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>enable</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>bellIsUrgent</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XWMHints</name> *</type><name>h</name> =<init> <expr><call><name>XGetWMHints</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>h</name> != 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>enable</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>h</name>-&gt;<name>flags</name> |= <name>XUrgencyHint</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>h</name>-&gt;<name>flags</name> &amp;= ~<name>XUrgencyHint</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>XSetWMHints</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>do_xevents</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>XtAppPending</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>)</argument_list></call>
	||
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>screen</name>-&gt;<name>display</name>-&gt;<name>qlen</name> &gt; 0
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<call><name>GetBytesAvailable</name><argument_list>(<argument><expr><call><name>ConnectionNumber</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; 0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</condition><then>
	<expr_stmt><expr><call><name>xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>xtermDisplayCursor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>Vshow</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>hide_pointer</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Display hidden_cursor\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XDefineCursor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>hidden_cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Display pointer_cursor\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>recolor_cursor</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>pointer_cursor</name></expr></argument>,
			   <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XDefineCursor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>pointer_cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>xtermShowPointer</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>enable</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>tried</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>enable</name> = <name>True</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Whether we actually hide the pointer depends on the pointer-mode and
     * the mouse-mode:
     */</comment>
    <if>if <condition>(<expr>!<name>enable</name></expr>)</condition><then> <block>{
	<switch>switch <condition>(<expr><name>screen</name>-&gt;<name>pointer_mode</name></expr>)</condition> <block>{
	<case>case <expr><name>pNever</name></expr>:
	    <expr_stmt><expr><name>enable</name> = <name>True</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>pNoMouse</name></expr>:
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> != <name>MOUSE_OFF</name></expr>)</condition><then>
		<expr_stmt><expr><name>enable</name> = <name>True</name></expr>;</expr_stmt></then></if>
	    <break>break;</break>
	</case><case>case <expr><name>pAlways</name></expr>:
	    <break>break;</break>
	</case>}</block></switch>
    }</block></then></if>

    <if>if <condition>(<expr><name>enable</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>hide_pointer</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>hide_pointer</name> = <name>False</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermDisplayCursor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name></expr>)</condition> <block>{
	    <case>case <expr><name>ANY_EVENT_MOUSE</name></expr>:
		<break>break;</break>
	    </case><default>default:
		<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    </default>}</block></switch>
	}</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr>!(<name>screen</name>-&gt;<name>hide_pointer</name>) &amp;&amp; (<name>tried</name> &lt;= 0)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>hidden_cursor</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>hidden_cursor</name> = <call><name>make_hidden_cursor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>hidden_cursor</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>tried</name> = 1</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>tried</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>hide_pointer</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermDisplayCursor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>MotionOn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>xevents</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XEvent</name></type> <name>event</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtInputMask</name></type> <name>input_mask</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>need_cleanup</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>Cleanup</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <comment type="block">/*
     * process timeouts, relying on the fact that XtAppProcessEvent
     * will process the timeout and return without blockng on the
     * XEvent queue.  Other sources i.e., the pty are handled elsewhere
     * with select().
     */</comment>
    <while>while <condition>(<expr>(<name>input_mask</name> = <call><name>XtAppPending</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition> <block>{
	<if>if <condition>(<expr><name>input_mask</name> &amp; <name>XtIMTimer</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>XtAppProcessEvent</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>, <argument><expr>(<name>XtInputMask</name>) <name>XtIMTimer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SESSION_MGT</name></expr></cpp:if>
	<comment type="block">/*
	 * Session management events are alternative input events. Deal with
	 * them in the same way.
	 */</comment>
	<else>else <if>if <condition>(<expr><name>input_mask</name> &amp; <name>XtIMAlternateInput</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>XtAppProcessEvent</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>, <argument><expr>(<name>XtInputMask</name>) <name>XtIMAlternateInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else
	    <break>break;</break></else></if></else></if>
    }</block></while>

    <comment type="block">/*
     * If there's no XEvents, don't wait around...
     */</comment>
    <if>if <condition>(<expr>(<name>input_mask</name> &amp; <name>XtIMXEvent</name>) != <name>XtIMXEvent</name></expr>)</condition><then>
	<return>return;</return></then></if>
    <do>do <block>{
	<comment type="block">/*
	 * This check makes xterm hang when in mouse hilite tracking mode.
	 * We simply ignore all events except for those not passed down to
	 * this function, e.g., those handled in in_put().
	 */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>waitingForTrackInfo</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>XtAppNextEvent</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Hack to get around problems with the toolkit throwing away
	 * eventing during the exclusive grab of the menu popup.  By
	 * looking at the event ourselves we make sure that we can
	 * do the right thing.
	 */</comment>
	<if>if <condition>(<expr><call><name>OUR_EVENT</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>EnterNotify</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>DoSpecialEnterNotify</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>event</name>.<name>xcrossing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>OUR_EVENT</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>LeaveNotify</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>DoSpecialLeaveNotify</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>event</name>.<name>xcrossing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr>(<name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>ANY_EVENT_MOUSE</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>
		    || <name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>DEC_LOCATOR</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_LOCATOR */</comment>
		   )
		   &amp;&amp; <name>event</name>.<name>xany</name>.<name>type</name> == <name>MotionNotify</name>
		   &amp;&amp; <name>event</name>.<name>xcrossing</name>.<name>window</name> == <call><name>XtWindow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>SendMousePosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if></else></if></else></if>

	<if>if <condition>(<expr>!<name>event</name>.<name>xany</name>.<name>send_event</name> ||
	    <name>screen</name>-&gt;<name>allowSendEvents</name> ||
	    ((<name>event</name>.<name>xany</name>.<name>type</name> != <name>KeyPress</name>) &amp;&amp;
	     (<name>event</name>.<name>xany</name>.<name>type</name> != <name>KeyRelease</name>) &amp;&amp;
	     (<name>event</name>.<name>xany</name>.<name>type</name> != <name>ButtonPress</name>) &amp;&amp;
	     (<name>event</name>.<name>xany</name>.<name>type</name> != <name>ButtonRelease</name>))</expr>)</condition><then> <block>{

	    <comment type="block">/*
	     * If the event is interesting (and not a keyboard event), turn the
	     * mouse pointer back on.
	     */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>hide_pointer</name></expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><name>event</name>.<name>xany</name>.<name>type</name></expr>)</condition> <block>{
		<case>case <expr><name>KeyPress</name></expr>:
		</case><case>case <expr><name>KeyRelease</name></expr>:
		</case><case>case <expr><name>ButtonPress</name></expr>:
		</case><case>case <expr><name>ButtonRelease</name></expr>:
		    <comment type="block">/* also these... */</comment>
		</case><case>case <expr><name>Expose</name></expr>:
		</case><case>case <expr><name>NoExpose</name></expr>:
		</case><case>case <expr><name>PropertyNotify</name></expr>:
		</case><case>case <expr><name>ClientMessage</name></expr>:
		    <break>break;</break>
		</case><default>default:
		    <expr_stmt><expr><call><name>xtermShowPointer</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</default>}</block></switch>
	    }</block></then></if>

	    <expr_stmt><expr><call><name>XtDispatchEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block> while <condition>(<expr><call><name>XtAppPending</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>)</argument_list></call> &amp; <name>XtIMXEvent</name></expr>)</condition>;</do>
}</block></function>

<function><type><name>static</name> <name>Cursor</name></type>
<name>make_hidden_cursor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cursor</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><name>screen</name>-&gt;<name>display</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XFontStruct</name> *</type><name>fn</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>static</name> <name>XColor</name></type> <name>dummy</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Prefer nil2 (which is normally available) to "fixed" (which is supposed
     * to be "always" available), since it's a smaller glyph in case the
     * server insists on drawing _something_.
     */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Ask for nil2 font\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>fn</name> = <call><name>XLoadQueryFont</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr>"nil2"</expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Ask for fixed font\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fn</name> = <call><name>XLoadQueryFont</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>DEFFONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>fn</name> != 0</expr>)</condition><then> <block>{
	<comment type="block">/* a space character seems to work as a cursor (dots are not needed) */</comment>
	<expr_stmt><expr><name>c</name> = <call><name>XCreateGlyphCursor</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>fn</name>-&gt;<name>fid</name></expr></argument>, <argument><expr><name>fn</name>-&gt;<name>fid</name></expr></argument>, <argument><expr>'X'</expr></argument>, <argument><expr>' '</expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XFreeFont</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>c</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("XCreateGlyphCursor -&gt;%#lx\n", <name>c</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>c</name>)</expr>;</return>
}</block></function>

<function><type><name>Cursor</name></type>
<name>make_colored_cursor</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>cursorindex</name></decl></param>,	<comment type="block">/* index into font */</comment>
		    <param><decl><type><name>unsigned</name> <name>long</name></type> <name>fg</name></decl></param>,	<comment type="block">/* pixel value */</comment>
		    <param><decl><type><name>unsigned</name> <name>long</name></type> <name>bg</name></decl></param>)</parameter_list>	<comment type="block">/* pixel value */</comment>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cursor</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><name>screen</name>-&gt;<name>display</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>c</name> = <call><name>XCreateFontCursor</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>cursorindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>c</name> != <name>None</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>recolor_cursor</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>c</name>)</expr>;</return>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleKeyPressed</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		 <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,
		 <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		 <param><decl><type><name>Cardinal</name> *<name>nparams</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Handle insert-seven-bit for %p\n", (<name>void</name> *) <name>w</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Input</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr>&amp;<name>event</name>-&gt;<name>xkey</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleEightBitKeyPressed</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
			 <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,
			 <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
			 <param><decl><type><name>Cardinal</name> *<name>nparams</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Handle insert-eight-bit for %p\n", (<name>void</name> *) <name>w</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Input</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr>&amp;<name>event</name>-&gt;<name>xkey</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleStringEvent</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,
		  <param><decl><type><name>Cardinal</name> *</type><name>nparams</name></decl></param>)</parameter_list>
<block>{

    <if>if <condition>(<expr>*<name>nparams</name> != 1</expr>)</condition><then>
	<return>return;</return></then></if>

    <if>if <condition>(<expr>(*<name>params</name>)<index>[<expr>0</expr>]</index> == '0' &amp;&amp; (*<name>params</name>)<index>[<expr>1</expr>]</index> == 'x' &amp;&amp; (*<name>params</name>)<index>[<expr>2</expr>]</index> != '\0'</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>abcdef</name> =<init> <expr>"ABCDEF"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>xxxxxx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UString</name></type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>value</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>p</name> = <call>(<name>UString</name>) <argument_list>(<argument><expr>*<name>params</name> + 2</expr></argument>)</argument_list></call></expr>;</init> <condition><expr>(<name>c</name> = <call><name>CharOf</name><argument_list>(<argument><expr><call><name>x_toupper</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) !=
	     '\0'</expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
	    <expr_stmt><expr><name>value</name> *= 16</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then>
		<expr_stmt><expr><name>value</name> += <call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>c</name> - '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr>(<name>xxxxxx</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>abcdef</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<expr_stmt><expr><name>value</name> += <call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>xxxxxx</name> - <name>abcdef</name></expr></argument>)</argument_list></call> + 10</expr>;</expr_stmt></then>
	    <else>else
		<break>break;</break></else></if></else></if>
	}</block></for>
	<if>if <condition>(<expr><name>c</name> == '\0'</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Char</name></type> <name><name>hexval</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	    <expr_stmt><expr><name><name>hexval</name><index>[<expr>0</expr>]</index></name> = (<name>Char</name>) <name>value</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>hexval</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>StringInput</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>hexval</name></expr></argument>, <argument><expr>(<name>size_t</name>) 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else <block>{
	<macro><name>StringInput</name><argument_list>(<argument>term</argument>, <argument>(const Char *) *params</argument>, <argument>strlen(*params)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></else></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXEC_XTERM</name></expr></cpp:if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PROCFS_ROOT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PROCFS_ROOT</name> "/proc"</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleSpawnTerminal</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		    <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		    <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,
		    <param><decl><type><name>Cardinal</name> *</type><name>nparams</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>child_cwd</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>child_exe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to find the actual program which is running in the child process.
     * This works for Linux.  If we cannot find the program, fall back to the
     * xterm program (which is usually adequate).  Give up if we are given only
     * a relative path to xterm, since that would not always match $PATH.
     */</comment>
    <expr_stmt><expr><name>child_exe</name> = <call><name>Readlink</name><argument_list>(<argument><expr><name>PROCFS_ROOT</name> "/self/exe"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>child_exe</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"./"</expr></argument>, <argument><expr>(<name>size_t</name>) 2</expr></argument>)</argument_list></call>
	    &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"../"</expr></argument>, <argument><expr>(<name>size_t</name>) 3</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>child_exe</name> = <call><name>xtermFindShell</name><argument_list>(<argument><expr><name>ProgramName</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Cannot exec-xterm given %s\n"</expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr><name>child_exe</name> == 0</expr>)</condition><then>
	    <return>return;</return></then></if>
    }</block></then></if>

    <comment type="block">/*
     * Determine the current working directory of the child so that we can
     * spawn a new terminal in the same directory.
     *
     * If we cannot get the CWD of the child, just use our own.
     */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>pid</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>child_cwd_link</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PROCFS_ROOT</name></expr></argument>)</argument_list></call> + 80</expr>]</index></name></decl>;</decl_stmt>
	<macro><name>sprintf</name><argument_list>(<argument>child_cwd_link</argument>, <argument>PROCFS_ROOT "/%lu/cwd"</argument>, <argument>(unsigned long) screen-&gt;pid</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><name>child_cwd</name> = <call><name>Readlink</name><argument_list>(<argument><expr><name>child_cwd_link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* The reaper will take care of cleaning up the child */</comment>
    <expr_stmt><expr><name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Could not fork: %s\n"</expr></argument>, <argument><expr><call><name>SysErrorMsg</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>!<name>pid</name></expr>)</condition><then> <block>{
	<comment type="block">/* We are the child */</comment>
	<if>if <condition>(<expr><name>child_cwd</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>IGNORE_RC</name><argument_list>(<argument><expr><call><name>chdir</name><argument_list>(<argument><expr><name>child_cwd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* We don't care if this fails */</comment>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>setuid</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>uid</name></expr></argument>)</argument_list></call> == -1
	    || <call><name>setgid</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>gid</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Cannot reset uid/gid\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>myargc</name> =<init> <expr>*<name>nparams</name> + 1</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>char</name> **</type><name>myargv</name> =<init> <expr><call><name>TypeMallocN</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>myargc</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><name><name>myargv</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>child_exe</name></expr>;</expr_stmt>

	    <while>while <condition>(<expr><name>n</name> &lt; <name>myargc</name></expr>)</condition> <block>{
		<expr_stmt><expr><name><name>myargv</name><index>[<expr><name>n</name>++</expr>]</index></name> = *<name>params</name>++</expr>;</expr_stmt>
	    }</block></while>

	    <expr_stmt><expr><name><name>myargv</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>execv</name><argument_list>(<argument><expr><name>child_exe</name></expr></argument>, <argument><expr><name>myargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* If we get here, we've failed */</comment>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"exec of '%s': %s\n"</expr></argument>, <argument><expr><name>child_exe</name></expr></argument>, <argument><expr><call><name>SysErrorMsg</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* We are the parent; clean up */</comment>
	<if>if <condition>(<expr><name>child_cwd</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>child_cwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>child_exe</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>child_exe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_EXEC_XTERM */</comment>

<comment type="block">/*
 * Rather than sending characters to the host, put them directly into our
 * input queue.  That lets a user have access to any of the control sequences
 * for a key binding.  This is the equivalent of local function key support.
 *
 * NOTE:  This code does not support the hexadecimal kludge used in
 * HandleStringEvent because it prevents us from sending an arbitrary string
 * (but it appears in a lot of examples - so we are stuck with it).  The
 * standard string converter does recognize "\" for newline ("\n") and for
 * octal constants (e.g., "\007" for BEL).  So we assume the user can make do
 * without a specialized converter.  (Don't try to use \000, though).
 */</comment>
<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleInterpret</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		<param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		<param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,
		<param><decl><type><name>Cardinal</name> *</type><name>param_count</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>*<name>param_count</name> == 1</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>value</name> =<init> <expr><name><name>params</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>need</name> =<init> <expr>(<name>int</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>used</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>VTbuffer</name>-&gt;<name>next</name> - <name>VTbuffer</name>-&gt;<name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>have</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>VTbuffer</name>-&gt;<name>last</name> - <name>VTbuffer</name>-&gt;<name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>have</name> - <name>used</name> + <name>need</name> &lt; <name>BUF_SIZE</name></expr>)</condition><then> <block>{

	    <expr_stmt><expr><call><name>fillPtyData</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>VTbuffer</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Interpret %s\n", <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>VTbuffer</name>-&gt;<name>update</name>++</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleEnterWindow</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>XtPointer</name> <name>eventdata</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>Boolean</name> * <name>cont</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* NOP since we handled it above */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleEnterWindow ignored\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FOCUS</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleLeaveWindow</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>XtPointer</name> <name>eventdata</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>Boolean</name> * <name>cont</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* NOP since we handled it above */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleLeaveWindow ignored\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FOCUS</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleFocusChange</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>XtPointer</name> <name>eventdata</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>XEvent</name> *</type> <name>ev</name></decl></param>,
		  <param><decl><type><name>Boolean</name> * <name>cont</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XFocusChangeEvent</name> *</type><name>event</name> =<init> <expr>(<name>XFocusChangeEvent</name> *) <name>ev</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleFocusChange type=%s, mode=%d, detail=%d\n",
	   <call><name>visibleEventType</name><argument_list>(<argument><expr><name>event</name>-&gt;<name>type</name></expr></argument>)</argument_list></call>,
	   <name>event</name>-&gt;<name>mode</name>,
	   <name>event</name>-&gt;<name>detail</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FOCUS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>quiet_grab</name>
	&amp;&amp; (<name>event</name>-&gt;<name>mode</name> == <name>NotifyGrab</name> || <name>event</name>-&gt;<name>mode</name> == <name>NotifyUngrab</name>)</expr>)</condition><then> <block>{
	<empty_stmt>;</empty_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>FocusIn</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>setXUrgency</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * NotifyNonlinear only happens (on FocusIn) if the pointer was not in
	 * one of our windows.  Use this to reset a case where one xterm is
	 * partly obscuring another, and X gets (us) confused about whether the
	 * pointer was in the window.  In particular, this can happen if the
	 * user is resizing the obscuring window, causing some events to not be
	 * delivered to the obscured window.
	 */</comment>
	<if>if <condition>(<expr><name>event</name>-&gt;<name>detail</name> == <name>NotifyNonlinear</name>
	    &amp;&amp; (<name>screen</name>-&gt;<name>select</name> &amp; <name>INWINDOW</name>) != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>unselectwindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>INWINDOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>selectwindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
		     <argument><expr>((<name>event</name>-&gt;<name>detail</name> == <name>NotifyPointer</name>)
		      ? <name>INWINDOW</name>
		      : <name>FOCUS</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SendFocusButton</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FOCUS_EVENT</name></expr></cpp:if>
	<if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>FocusOut</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>SendFocusButton</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/*
	 * XGrabKeyboard() will generate NotifyGrab event that we want to
	 * ignore.
	 */</comment>
	<if>if <condition>(<expr><name>event</name>-&gt;<name>mode</name> != <name>NotifyGrab</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>unselectwindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
			   <argument><expr>((<name>event</name>-&gt;<name>detail</name> == <name>NotifyPointer</name>)
			    ? <name>INWINDOW</name>
			    : <name>FOCUS</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>grabbedKbd</name> &amp;&amp; (<name>event</name>-&gt;<name>mode</name> == <name>NotifyUngrab</name>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ReverseVideo</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>grabbedKbd</name> = <name>False</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_securekbd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if></else></if>
}</block></function>

<decl_stmt><decl><type><name>static</name> <name>long</name></type> <name>lastBellTime</name></decl>;</decl_stmt>	<comment type="block">/* in milliseconds */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_XKB_BELL_EXT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>static</name> <name>Atom</name></type>
<name>AtomBell</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>which</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DATA</name>(name) { XkbBI_##name, XkbBN_##name }</cpp:define>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>table</name><index>[]</index></name> = <block>{
	<expr><call><name>DATA</name><argument_list>(<argument><expr><name>Info</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>DATA</name><argument_list>(<argument><expr><name>MarginBell</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>DATA</name><argument_list>(<argument><expr><name>MinorError</name></expr></argument>)</argument_list></call></expr>,
	    <macro><name>DATA</name><argument_list>(<argument>TerminalBell</argument>)</argument_list></macro>
    }</block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name></type> <name>result</name> =<init> <expr><name>None</name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<if>if <condition>(<expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>value</name> == <name>which</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <call><name>XInternAtom</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
    }</block></for>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>xtermBell</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>which</name></decl></param>, <param><decl><type><name>int</name></type> <name>percent</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_XKB_BELL_EXT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>Atom</name></type> <name>tony</name> =<init> <expr><call><name>AtomBell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>which</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><name>which</name></expr>)</condition> <block>{
    <case>case <expr><name>XkbBI_Info</name></expr>:
    </case><case>case <expr><name>XkbBI_MinorError</name></expr>:
    </case><case>case <expr><name>XkbBI_MajorError</name></expr>:
    </case><case>case <expr><name>XkbBI_TerminalBell</name></expr>:
	<switch>switch <condition>(<expr><name>screen</name>-&gt;<name>warningVolume</name></expr>)</condition> <block>{
	<case>case <expr><name>bvOff</name></expr>:
	    <expr_stmt><expr><name>percent</name> = -100</expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>bvLow</name></expr>:
	    <break>break;</break>
	</case><case>case <expr><name>bvHigh</name></expr>:
	    <expr_stmt><expr><name>percent</name> = 100</expr>;</expr_stmt>
	    <break>break;</break>
	</case>}</block></switch>
	<break>break;</break>
    </case><case>case <expr><name>XkbBI_MarginBell</name></expr>:
	<switch>switch <condition>(<expr><name>screen</name>-&gt;<name>marginVolume</name></expr>)</condition> <block>{
	<case>case <expr><name>bvOff</name></expr>:
	    <expr_stmt><expr><name>percent</name> = -100</expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>bvLow</name></expr>:
	    <break>break;</break>
	</case><case>case <expr><name>bvHigh</name></expr>:
	    <expr_stmt><expr><name>percent</name> = 100</expr>;</expr_stmt>
	    <break>break;</break>
	</case>}</block></switch>
	<break>break;</break>
    </case><default>default:
	<break>break;</break>
    </default>}</block></switch>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_XKB_BELL_EXT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr><name>tony</name> != <name>None</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>XkbBell</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>, <argument><expr><name>tony</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>XBell</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>Bell</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>which</name></decl></param>, <param><decl><type><name>int</name></type> <name>percent</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>timeval</name></type> <name>curtime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>now_msecs</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BELL %d %d%%\n", <name>which</name>, <name>percent</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>XtIsRealized</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>setXUrgency</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* has enough time gone by that we are allowed to ring
       the bell again? */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>bellSuppressTime</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>bellInProgress</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>do_xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>bellInProgress</name></expr>)</condition><then> <block>{	<comment type="block">/* even after new events? */</comment>
		<return>return;</return>
	    }</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>X_GETTIMEOFDAY</name><argument_list>(<argument><expr>&amp;<name>curtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now_msecs</name> = 1000 * <name>curtime</name>.<name>tv_sec</name> + <name>curtime</name>.<name>tv_usec</name> / 1000</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>lastBellTime</name> != 0 &amp;&amp; <name>now_msecs</name> - <name>lastBellTime</name> &gt;= 0 &amp;&amp;
	    <name>now_msecs</name> - <name>lastBellTime</name> &lt; <name>screen</name>-&gt;<name>bellSuppressTime</name></expr>)</condition><then> <block>{
	    <return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><name>lastBellTime</name> = <name>now_msecs</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>visualbell</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>VisualBell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>xtermBell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>which</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>poponbell</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>XRaiseWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>bellSuppressTime</name></expr>)</condition><then> <block>{
	<comment type="block">/* now we change a property and wait for the notify event to come
	   back.  If the server is suspending operations while the bell
	   is being emitted (problematic for audio bell), this lets us
	   know when the previous bell has finished */</comment>
	<decl_stmt><decl><type><name>Widget</name></type> <name>w</name> =<init> <expr><call><name>CURRENT_EMU</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>XChangeProperty</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>XA_NOTICE</name></expr></argument>, <argument><expr><name>XA_NOTICE</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name>PropModeAppend</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>bellInProgress</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>VB_DELAY</name> <name>screen</name>-&gt;visualBellDelay</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>flashWindow</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Window</name></type> <name>window</name></decl></param>, <param><decl><type><name>GC</name></type> <name>visualGC</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>width</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>height</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>XFillRectangle</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>visualGC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XFlush</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><name>VB_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XFillRectangle</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>visualGC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>VisualBell</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>VB_DELAY</name> &gt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Pixel</name></type> <name>xorPixel</name> =<init> <expr>(<call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call> ^
			  <call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XGCValues</name></type> <name>gcval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GC</name></type> <name>visualGC</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>gcval</name>.<name>function</name> = <name>GXxor</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>gcval</name>.<name>foreground</name> = <name>xorPixel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>visualGC</name> = <call><name>XtGetGC</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>term</name></expr></argument>, <argument><expr><name>GCFunction</name> + <name>GCForeground</name></expr></argument>, <argument><expr>&amp;<name>gcval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>TekScreen</name> *</type><name>tekscr</name> =<init> <expr><call><name>TekScreenOf</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>flashWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>TWindow</name><argument_list>(<argument><expr><name>tekscr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>visualGC</name></expr></argument>,
			<argument><expr><call><name>TFullWidth</name><argument_list>(<argument><expr><name>tekscr</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>TFullHeight</name><argument_list>(<argument><expr><name>tekscr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
	    <expr_stmt><expr><call><name>flashWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>visualGC</name></expr></argument>,
			<argument><expr><call><name>FullWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>FullHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>XtReleaseGC</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>term</name></expr></argument>, <argument><expr><name>visualGC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>HandleBellPropertyChange</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
			 <param><decl><type><name>XtPointer</name> <name>data</name></type> <name>GCC_UNUSED</name></decl></param>,
			 <param><decl><type><name>XEvent</name> *</type> <name>ev</name></decl></param>,
			 <param><decl><type><name>Boolean</name> * <name>more</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ev</name>-&gt;<name>xproperty</name>.<name>atom</name> == <name>XA_NOTICE</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>bellInProgress</name> = <name>False</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>Window</name></type>
<name>WMFrameWindow</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>termw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Window</name></type> <name>win_root</name>, <name>win_current</name>, *<name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name></type> <name>win_parent</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nchildren</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>win_current</name> = <call><name>XtWindow</name><argument_list>(<argument><expr><name>termw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* find the parent which is child of root */</comment>
    <do>do <block>{
	<if>if <condition>(<expr><name>win_parent</name></expr>)</condition><then>
	    <expr_stmt><expr><name>win_current</name> = <name>win_parent</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>XQueryTree</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>termw</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>,
		   <argument><expr><name>win_current</name></expr></argument>,
		   <argument><expr>&amp;<name>win_root</name></expr></argument>,
		   <argument><expr>&amp;<name>win_parent</name></expr></argument>,
		   <argument><expr>&amp;<name>children</name></expr></argument>,
		   <argument><expr>&amp;<name>nchildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XFree</name><argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>win_root</name> != <name>win_parent</name></expr>)</condition>;</do>

    <return>return <expr><name>win_current</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DABBREV</name></expr></cpp:if>
<comment type="block">/*
 * The following code implements `dynamic abbreviation' expansion a la
 * Emacs.  It looks in the preceding visible screen and its scrollback
 * to find expansions of a typed word.  It compares consecutive
 * expansions and ignores one of them if they are identical.
 * (Tomasz J. Cholewo, t.cholewo@ieee.org)
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>IS_WORD_CONSTITUENT</name>(x) ((x) != ' ' &amp;&amp; (x) != '\0')</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAXWLEN</name> 1024</cpp:define>		<comment type="block">/* maximum word length as in tcsh */</comment>

<function><type><name>static</name> <name>int</name></type>
<name>dabbrev_prev_char</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>, <param><decl><type><name>LineData</name> **</type> <name>ld</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>firstLine</name> =<init> <expr>-(<name>screen</name>-&gt;<name>savedlines</name>)</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cell</name>-&gt;<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>cell</name>-&gt;<name>row</name> &gt;= <name>firstLine</name></expr>)</condition> <block>{
	<if>if <condition>(<expr>--(<name>cell</name>-&gt;<name>col</name>) &gt;= 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>*<name>ld</name></expr></argument>)</argument_list></call>-&gt;<name><name>charData</name><index>[<expr><name>cell</name>-&gt;<name>col</name></expr>]</index></name></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
	<if>if <condition>(<expr>--(<name>cell</name>-&gt;<name>row</name>) &lt; <name>firstLine</name></expr>)</condition><then>
	    <break>break;</break></then></if>		<comment type="block">/* ...there is no previous line */</comment>
	<expr_stmt><expr>*<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cell</name>-&gt;<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cell</name>-&gt;<name>col</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>LineTstWrapped</name><argument_list>(<argument><expr>*<name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = ' '</expr>;</expr_stmt>	<comment type="block">/* treat lines as separate */</comment>
	    <break>break;</break>
	}</block></then></if>
    }</block></while>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>char</name> *</type>
<name>dabbrev_prev_word</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>CELL</name> *</type> <name>cell</name></decl></param>, <param><decl><type><name>LineData</name> **</type> <name>ld</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>ab</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> *</type><name>abword</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>ab_end</name> =<init> <expr>(<name>ab</name> + <name>MAXWLEN</name> - 1)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>abword</name> = <name>ab_end</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>abword</name> = '\0'</expr>;</expr_stmt>		<comment type="block">/* end of string marker */</comment>

    <while>while <condition>(<expr>(<name>c</name> = <call><name>dabbrev_prev_char</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call>) &gt;= 0 &amp;&amp;
	   <call><name>IS_WORD_CONSTITUENT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<if>if <condition>(<expr><name>abword</name> &gt; <name>ab</name></expr>)</condition><then>	<comment type="block">/* store only |MAXWLEN| last chars */</comment>
	    <expr_stmt><expr>*(--<name>abword</name>) = (<name>char</name>) <name>c</name></expr>;</expr_stmt></then></if>
    }</block></while>

    <if>if <condition>(<expr><name>c</name> &gt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>abword</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>abword</name> != <name>ab_end</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>abword</name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>result</name> != 0</expr>)</condition><then> <block>{
	<while>while <condition>(<expr>(<name>c</name> = <call><name>dabbrev_prev_char</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call>) &gt;= 0 &amp;&amp;
	       !<call><name>IS_WORD_CONSTITUENT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	    <empty_stmt>;</empty_stmt>			<comment type="block">/* skip preceding spaces */</comment>
	}</block></while>
	<expr_stmt><expr>(<name>cell</name>-&gt;<name>col</name>)++</expr>;</expr_stmt>		<comment type="block">/* can be | &gt; screen-&gt;max_col| */</comment>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>dabbrev_expand</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pty</name> =<init> <expr><name>screen</name>-&gt;<name>respond</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* file descriptor of pty */</comment>

    <decl_stmt><decl><type><name>static</name> <name>CELL</name></type> <name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>dabbrev_hint</name> =<init> <expr>0</expr>, <expr>*<name>lastexpansion</name> = 0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>unsigned</name> <name>int</name></type> <name>expansions</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> *</type><name>expansion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>copybuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>hint_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>del_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>buf_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>dabbrev_working</name></expr>)</condition><then> <block>{	<comment type="block">/* initialize */</comment>
	<expr_stmt><expr><name>expansions</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>cell</name>.<name>col</name> = <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cell</name>.<name>row</name> = <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>dabbrev_hint</name> != 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dabbrev_hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr>(<name>dabbrev_hint</name> = <call><name>dabbrev_prev_word</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>, <argument><expr>&amp;<name>ld</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{

	    <if>if <condition>(<expr><name>lastexpansion</name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lastexpansion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	    <if>if <condition>(<expr>(<name>lastexpansion</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>dabbrev_hint</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{

		<comment type="block">/* make own copy */</comment>
		<if>if <condition>(<expr>(<name>dabbrev_hint</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>dabbrev_hint</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>screen</name>-&gt;<name>dabbrev_working</name> = <name>True</name></expr>;</expr_stmt>
		    <comment type="block">/* we are in the middle of dabbrev process */</comment>
		}</block></then></if>
	    }</block></then> <else>else <block>{
		<return>return <expr><name>result</name></expr>;</return>
	    }</block></else></if>
	}</block></then> <else>else <block>{
	    <return>return <expr><name>result</name></expr>;</return>
	}</block></else></if>
	<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>dabbrev_working</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>lastexpansion</name> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lastexpansion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastexpansion</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>
	    <return>return <expr><name>result</name></expr>;</return>
	}</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>dabbrev_hint</name> == 0</expr>)</condition><then>
	<return>return <expr><name>result</name></expr>;</return></then></if>

    <expr_stmt><expr><name>hint_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>dabbrev_hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
	<if>if <condition>(<expr>(<name>expansion</name> = <call><name>dabbrev_prev_word</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>cell</name></expr></argument>, <argument><expr>&amp;<name>ld</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>expansions</name> &gt;= 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>expansions</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>cell</name>.<name>col</name> = <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cell</name>.<name>row</name> = <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt>
		<continue>continue;</continue>
	    }</block></then></if>
	    <break>break;</break>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>dabbrev_hint</name></expr></argument>, <argument><expr><name>expansion</name></expr></argument>, <argument><expr><name>hint_len</name></expr></argument>)</argument_list></call> &amp;&amp;	<comment type="block">/* empty hint matches everything */</comment>
	    <call><name>strlen</name><argument_list>(<argument><expr><name>expansion</name></expr></argument>)</argument_list></call> &gt; <name>hint_len</name> &amp;&amp;	<comment type="block">/* trivial expansion disallowed */</comment>
	    <call><name>strcmp</name><argument_list>(<argument><expr><name>expansion</name></expr></argument>, <argument><expr><name>lastexpansion</name></expr></argument>)</argument_list></call></expr>)</condition><then>	<comment type="block">/* different from previous */</comment>
	    <break>break;</break></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>expansion</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>del_cnt</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>lastexpansion</name></expr></argument>)</argument_list></call> - <name>hint_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_cnt</name> = <name>del_cnt</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>expansion</name></expr></argument>)</argument_list></call> - <name>hint_len</name></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name>copybuffer</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>Char</name></expr></argument>, <argument><expr><name>buf_cnt</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	    <comment type="block">/* delete previous expansion */</comment>
	    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>copybuffer</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>dabbrev_erase_char</name></expr></argument>, <argument><expr><name>del_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>copybuffer</name> + <name>del_cnt</name></expr></argument>,
		    <argument><expr><name>expansion</name> + <name>hint_len</name></expr></argument>,
		    <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>expansion</name></expr></argument>)</argument_list></call> - <name>hint_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>pty</name></expr></argument>, <argument><expr><name>copybuffer</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>buf_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <comment type="block">/* v_write() just reset our flag */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>dabbrev_working</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>copybuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lastexpansion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr>(<name>lastexpansion</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>expansion</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>expansions</name>++</expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleDabbrevExpand</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		    <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		    <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		    <param><decl><type><name>Cardinal</name> *<name>nparams</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Handle dabbrev-expand for %p\n", (<name>void</name> *) <name>w</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>dabbrev_expand</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_TerminalBell</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DABBREV */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MAXIMIZE</name></expr></cpp:if>
<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleDeIconify</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		<param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		<param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		<param><decl><type><name>Cardinal</name> *<name>nparams</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>XMapWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleIconify</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
	      <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
	      <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
	      <param><decl><type><name>Cardinal</name> *<name>nparams</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>XIconifyWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
		       <argument><expr><name>VShellWindow</name></expr></argument>,
		       <argument><expr><call><name>DefaultScreen</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>int</name></type>
<name>QueryMaximize</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>termw</name></decl></param>, <param><decl><type><name>unsigned</name> *</type><name>width</name></decl></param>, <param><decl><type><name>unsigned</name> *</type><name>height</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>termw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XSizeHints</name></type> <name>hints</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>supp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name></type> <name>root_win</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>root_x</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>		<comment type="block">/* saved co-ordinates */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>root_y</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>root_border</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>root_depth</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>XGetGeometry</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
		     <argument><expr><call><name>RootWindowOfScreen</name><argument_list>(<argument><expr><call><name>XtScreen</name><argument_list>(<argument><expr><name>termw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr>&amp;<name>root_win</name></expr></argument>,
		     <argument><expr>&amp;<name>root_x</name></expr></argument>,
		     <argument><expr>&amp;<name>root_y</name></expr></argument>,
		     <argument><expr><name>width</name></expr></argument>,
		     <argument><expr><name>height</name></expr></argument>,
		     <argument><expr>&amp;<name>root_border</name></expr></argument>,
		     <argument><expr>&amp;<name>root_depth</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("QueryMaximize: XGetGeometry position %d,%d size %d,%d border %d\n",
	       <name>root_x</name>,
	       <name>root_y</name>,
	       *<name>width</name>,
	       *<name>height</name>,
	       <name>root_border</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr>*<name>width</name> -= (<name>root_border</name> * 2)</expr>;</expr_stmt>
	<expr_stmt><expr>*<name>height</name> -= (<name>root_border</name> * 2)</expr>;</expr_stmt>

	<expr_stmt><expr><name>hints</name>.<name>flags</name> = <name>PMaxSize</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>XGetWMNormalHints</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
			      <argument><expr><name>VShellWindow</name></expr></argument>,
			      <argument><expr>&amp;<name>hints</name></expr></argument>,
			      <argument><expr>&amp;<name>supp</name></expr></argument>)</argument_list></call>
	    &amp;&amp; (<name>hints</name>.<name>flags</name> &amp; <name>PMaxSize</name>) != 0</expr>)</condition><then> <block>{

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("QueryMaximize: WM hints max_w %#x max_h %#x\n",
		   <name>hints</name>.<name>max_width</name>,
		   <name>hints</name>.<name>max_height</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr>(<name>unsigned</name>) <name>hints</name>.<name>max_width</name> &lt; *<name>width</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>width</name> = (<name>unsigned</name>) <name>hints</name>.<name>max_width</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>(<name>unsigned</name>) <name>hints</name>.<name>max_height</name> &lt; *<name>height</name></expr>)</condition><then>
		<expr_stmt><expr>*<name>height</name> = (<name>unsigned</name>) <name>hints</name>.<name>max_height</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<return>return <expr>1</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>RequestMaximize</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>termw</name></decl></param>, <param><decl><type><name>int</name></type> <name>maximize</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>termw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XWindowAttributes</name></type> <name>wm_attrs</name>, <name>vshell_attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>root_width</name>, <name>root_height</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("RequestMaximize %s\n", <name>maximize</name> ? "maximize" : "restore")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>maximize</name></expr>)</condition><then> <block>{

	<if>if <condition>(<expr><call><name>QueryMaximize</name><argument_list>(<argument><expr><name>termw</name></expr></argument>, <argument><expr>&amp;<name>root_width</name></expr></argument>, <argument><expr>&amp;<name>root_height</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

	    <if>if <condition>(<expr><call><name>XGetWindowAttributes</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
				     <argument><expr><call><name>WMFrameWindow</name><argument_list>(<argument><expr><name>termw</name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr>&amp;<name>wm_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

		<if>if <condition>(<expr><call><name>XGetWindowAttributes</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
					 <argument><expr><name>VShellWindow</name></expr></argument>,
					 <argument><expr>&amp;<name>vshell_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>restore_data</name> != <name>True</name>
			|| <name>screen</name>-&gt;<name>restore_width</name> != <name>root_width</name>
			|| <name>screen</name>-&gt;<name>restore_height</name> != <name>root_height</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>screen</name>-&gt;<name>restore_data</name> = <name>True</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>restore_x</name> = <name>wm_attrs</name>.<name>x</name> + <name>wm_attrs</name>.<name>border_width</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>restore_y</name> = <name>wm_attrs</name>.<name>y</name> + <name>wm_attrs</name>.<name>border_width</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>restore_width</name> = (<name>unsigned</name>) <name>vshell_attrs</name>.<name>width</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>restore_height</name> = (<name>unsigned</name>) <name>vshell_attrs</name>.<name>height</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleMaximize: save window position %d,%d size %d,%d\n",
			       <name>screen</name>-&gt;<name>restore_x</name>,
			       <name>screen</name>-&gt;<name>restore_y</name>,
			       <name>screen</name>-&gt;<name>restore_width</name>,
			       <name>screen</name>-&gt;<name>restore_height</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>

		    <comment type="block">/* subtract wm decoration dimensions */</comment>
		    <expr_stmt><expr><name>root_width</name> -=
			<call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>wm_attrs</name>.<name>width</name> - <name>vshell_attrs</name>.<name>width</name>)
				    + (<name>wm_attrs</name>.<name>border_width</name> * 2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>root_height</name> -=
			<call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>wm_attrs</name>.<name>height</name> - <name>vshell_attrs</name>.<name>height</name>)
				    + (<name>wm_attrs</name>.<name>border_width</name> * 2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <expr_stmt><expr><call><name>XMoveResizeWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>,
				      <argument><expr>0 + <name>wm_attrs</name>.<name>border_width</name></expr></argument>,	<comment type="block">/* x */</comment>
				      <argument><expr>0 + <name>wm_attrs</name>.<name>border_width</name></expr></argument>,	<comment type="block">/* y */</comment>
				      <argument><expr><name>root_width</name></expr></argument>,
				      <argument><expr><name>root_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
	}</block></then></if>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>restore_data</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleRestoreSize: position %d,%d size %d,%d\n",
		   <name>screen</name>-&gt;<name>restore_x</name>,
		   <name>screen</name>-&gt;<name>restore_y</name>,
		   <name>screen</name>-&gt;<name>restore_width</name>,
		   <name>screen</name>-&gt;<name>restore_height</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>restore_data</name> = <name>False</name></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>XMoveResizeWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
			      <argument><expr><name>VShellWindow</name></expr></argument>,
			      <argument><expr><name>screen</name>-&gt;<name>restore_x</name></expr></argument>,
			      <argument><expr><name>screen</name>-&gt;<name>restore_y</name></expr></argument>,
			      <argument><expr><name>screen</name>-&gt;<name>restore_width</name></expr></argument>,
			      <argument><expr><name>screen</name>-&gt;<name>restore_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleMaximize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
	       <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
	       <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
	       <param><decl><type><name>Cardinal</name> *<name>nparams</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>RequestMaximize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>void</name></type>
<name>HandleRestoreSize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		  <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>Cardinal</name> *<name>nparams</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>RequestMaximize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MAXIMIZE */</comment>

<function><type><name>void</name></type>
<name>Redraw</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XExposeEvent</name></type> <name>event</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Redraw\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>event</name>.<name>type</name> = <name>Expose</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>event</name>.<name>display</name> = <name>screen</name>-&gt;<name>display</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>event</name>.<name>x</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>event</name>.<name>y</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>event</name>.<name>count</name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>event</name>.<name>window</name> = <call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>event</name>.<name>width</name> = <name>term</name>-&gt;<name>core</name>.<name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>event</name>.<name>height</name> = <name>term</name>-&gt;<name>core</name>.<name>height</name></expr>;</expr_stmt>
	<expr_stmt><expr>(*<name>term</name>-&gt;<name>core</name>.<name>widget_class</name>-&gt;<name>core_class</name>.<name>expose</name>) ((<name>Widget</name>) <name>term</name>,
						       (<name>XEvent</name> *) &amp; <name>event</name>,
						       <name>NULL</name>)</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>ScrollbarWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr>(<name>screen</name>-&gt;<name>scrollWidget</name>-&gt;<name>core</name>.<name>widget_class</name>-&gt;<name>core_class</name>.<name>expose</name>)
		(<name>screen</name>-&gt;<name>scrollWidget</name>, (<name>XEvent</name> *) &amp; <name>event</name>, <name>NULL</name>)</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TekScreen</name> *</type><name>tekscr</name> =<init> <expr><call><name>TekScreenOf</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>event</name>.<name>window</name> = <call><name>TWindow</name><argument_list>(<argument><expr><name>tekscr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>event</name>.<name>width</name> = <name>tekWidget</name>-&gt;<name>core</name>.<name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>event</name>.<name>height</name> = <name>tekWidget</name>-&gt;<name>core</name>.<name>height</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TekExpose</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>tekWidget</name></expr></argument>, <argument><expr>(<name>XEvent</name> *) &amp; <name>event</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TIMESTAMP_FMT</name> "%s%d-%02d-%02d-%02d-%02d-%02d"</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TIMESTAMP_FMT</name> "%s%d-%02d-%02d.%02d:%02d:%02d"</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>timestamp_filename</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>src</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>time_t</name></type> <name>tstamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>tm</name> *</type><name>tstruct</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tstamp</name> = <call><name>time</name><argument_list>(<argument><expr>(<name>time_t</name> *) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tstruct</name> = <call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>tstamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>TIMESTAMP_FMT</name></expr></argument>,
	    <argument><expr><name>src</name></expr></argument>,
	    <argument><expr><name>tstruct</name>-&gt;<name>tm_year</name> + 1900</expr></argument>,
	    <argument><expr><name>tstruct</name>-&gt;<name>tm_mon</name> + 1</expr></argument>,
	    <argument><expr><name>tstruct</name>-&gt;<name>tm_mday</name></expr></argument>,
	    <argument><expr><name>tstruct</name>-&gt;<name>tm_hour</name></expr></argument>,
	    <argument><expr><name>tstruct</name>-&gt;<name>tm_min</name></expr></argument>,
	    <argument><expr><name>tstruct</name>-&gt;<name>tm_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type>
<name>open_userfile</name><parameter_list>(<param><decl><type><name>uid_t</name></type> <name>uid</name></decl></param>, <param><decl><type><name>gid_t</name></type> <name>gid</name></decl></param>, <param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>append</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>stat</name></type> <name>sb</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
    <if>if <condition>(<expr>(<name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_WRONLY</name> | <name>O_CREAT</name> | <name>O_TRUNC</name></expr></argument>, <argument><expr>0644</expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>the_error</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: cannot open %s: %d:%s\n"</expr></argument>,
		<argument><expr><name>xterm_name</name></expr></argument>,
		<argument><expr><name>path</name></expr></argument>,
		<argument><expr><name>the_error</name></expr></argument>,
		<argument><expr><call><name>SysErrorMsg</name><argument_list>(<argument><expr><name>the_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>chown</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr>(<call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> != 0 &amp;&amp; (<name>errno</name> != <name>ENOENT</name>))
	|| (<call><name>creat_as</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>append</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0644</expr></argument>)</argument_list></call> &lt;= 0)
	|| ((<name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_WRONLY</name> | <name>O_APPEND</name></expr></argument>)</argument_list></call>) &lt; 0)</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>the_error</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: cannot open %s: %d:%s\n"</expr></argument>,
		<argument><expr><name>xterm_name</name></expr></argument>,
		<argument><expr><name>path</name></expr></argument>,
		<argument><expr><name>the_error</name></expr></argument>,
		<argument><expr><call><name>SysErrorMsg</name><argument_list>(<argument><expr><name>the_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Doublecheck that the user really owns the file that we've opened before
     * we do any damage, and that it is not world-writable.
     */</comment>
    <if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>sb</name></expr></argument>)</argument_list></call> &lt; 0
	|| <name>sb</name>.<name>st_uid</name> != <name>uid</name>
	|| (<name>sb</name>.<name>st_mode</name> &amp; 022) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: you do not own %s\n"</expr></argument>, <argument><expr><name>xterm_name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <return>return <expr><name>fd</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>VMS</name></cpp:ifndef>
<comment type="block">/*
 * Create a file only if we could with the permissions of the real user id.
 * We could emulate this with careful use of access() and following
 * symbolic links, but that is messy and has race conditions.
 * Forking is messy, too, but we can't count on setreuid() or saved set-uids
 * being available.
 *
 * Note: When called for user logging, we have ensured that the real and
 * effective user ids are the same, so this remains as a convenience function
 * for the debug logs.
 *
 * Returns
 *	 1 if we can proceed to open the file in relative safety,
 *	-1 on error, e.g., cannot fork
 *	 0 otherwise.
 */</comment>
<function><type><name>int</name></type>
<name>creat_as</name><parameter_list>(<param><decl><type><name>uid_t</name></type> <name>uid</name></decl></param>, <param><decl><type><name>gid_t</name></type> <name>gid</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>append</name></decl></param>, <param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>childstat</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_WAITPID</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type> <name>waited</name></decl>;</decl_stmt>
    <function_decl><type><name>SIGNAL_T</name></type>(*<name>chldfunc</name>) <parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>chldfunc</name> = <call><name>signal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAITPID */</comment>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("creat_as(uid=%d/%d, gid=%d/%d, append=%d, pathname=%s, mode=%#o)\n",
	   (<name>int</name>) <name>uid</name>, (<name>int</name>) <call><name>geteuid</name><argument_list>()</argument_list></call>,
	   (<name>int</name>) <name>gid</name>, (<name>int</name>) <call><name>getegid</name><argument_list>()</argument_list></call>,
	   <name>append</name>,
	   <name>pathname</name>,
	   <name>mode</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>uid</name> == <call><name>geteuid</name><argument_list>()</argument_list></call> &amp;&amp; <name>gid</name> == <call><name>getegid</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>,
		  <argument><expr><name>O_WRONLY</name> | <name>O_CREAT</name> | (<name>append</name> ? <name>O_APPEND</name> : <name>O_EXCL</name>)</expr></argument>,
		  <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fd</name> &gt;= 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>fd</name> &gt;= 0)</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>pid</name></expr>)</condition> <block>{
    <case>case <expr>0</expr>:			<comment type="block">/* child */</comment>
	<if>if <condition>(<expr><call><name>setgid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> == -1
	    || <call><name>setuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
	    <comment type="block">/* we cannot report an error here via stderr, just quit */</comment>
	    <expr_stmt><expr><name>retval</name> = 1</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>,
		      <argument><expr><name>O_WRONLY</name> | <name>O_CREAT</name> | (<name>append</name> ? <name>O_APPEND</name> : <name>O_EXCL</name>)</expr></argument>,
		      <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>fd</name> &gt;= 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retval</name> = 0</expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>retval</name> = 1</expr>;</expr_stmt>
	    }</block></else></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* NOTREACHED */</comment>
    </case><case>case <expr>-1</expr>:			<comment type="block">/* error */</comment>
	<return>return <expr><name>retval</name></expr>;</return>
    </case><default>default:			<comment type="block">/* parent */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WAITPID</name></cpp:ifdef>
	<while>while <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr>&amp;<name>childstat</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EINTR</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>errno</name> == <name>EINTR</name></expr>)</condition><then>
		<continue>continue;</continue></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EINTR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ERESTARTSYS</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>errno</name> == <name>ERESTARTSYS</name></expr>)</condition><then>
		<continue>continue;</continue></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ERESTARTSYS */</comment>
	    <break>break;</break>
	}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* HAVE_WAITPID */</comment>
	<expr_stmt><expr><name>waited</name> = <call><name>wait</name><argument_list>(<argument><expr>&amp;<name>childstat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>chldfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	   Since we had the signal handler uninstalled for a while,
	   we might have missed the termination of our screen child.
	   If we can check for this possibility without hanging, do so.
	 */</comment>
	<do>do
	    <if>if <condition>(<expr><name>waited</name> == <call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call>-&gt;<name>pid</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>Cleanup</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	while <condition>(<expr>(<name>waited</name> = <call><name>nonblocking_wait</name><argument_list>()</argument_list></call>) &gt; 0</expr>)</condition> ;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WAITPID */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIFEXITED</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WIFEXITED</name>(status) ((status &amp; 0xff) != 0)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>childstat</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>retval</name> = 1</expr>;</expr_stmt></then></if>
	<return>return <expr><name>retval</name></expr>;</return>
    </default>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !VMS */</comment>

<function><type><name>int</name></type>
<name>xtermResetIds</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>setgid</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>gid</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: unable to reset group-id\n"</expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>setuid</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>uid</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: unable to reset user-id\n"</expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>

<comment type="block">/*
 * Logging is a security hole, since it allows a setuid program to write
 * arbitrary data to an arbitrary file.  So it is disabled by default.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGFILEEXEC</name></cpp:ifdef>
<function><type><name>static</name> <name>SIGNAL_T</name></type>
<name>logpipe</name><parameter_list>(<param><decl><type><name>int</name> <name>sig</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SYSV</name></cpp:ifdef>
    <expr_stmt><expr>(<name>void</name>) <call><name>signal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SYSV */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>logging</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>CloseLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ALLOWLOGFILEEXEC */</comment>

<function><type><name>void</name></type>
<name>StartLog</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>log_default</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGFILEEXEC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ALLOWLOGFILEEXEC */</comment>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>logging</name> || (<name>screen</name>-&gt;<name>inhibit</name> &amp; <name>I_LOG</name>)</expr>)</condition><then>
	<return>return;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>			<comment type="block">/* file name is fixed in VMS variant */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>logfd</name> = <call><name>open</name><argument_list>(<argument><expr><name>XTERM_VMS_LOGFILE</name></expr></argument>,
			 <argument><expr><name>O_CREAT</name> | <name>O_TRUNC</name> | <name>O_APPEND</name> | <name>O_RDWR</name></expr></argument>,
			 <argument><expr>0640</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>logfd</name> &lt; 0</expr>)</condition><then>
	<return>return;</return></then></if>			<comment type="block">/* open failed */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/*VMS */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>logfile</name> == <name>NULL</name> || *<name>screen</name>-&gt;<name>logfile</name> == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>logfile</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>log_default</name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTNAME</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRFTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
	    <decl_stmt><decl><type><name>char</name></type> <name><name>log_def_name</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* see sprintf below */</comment>
	    <decl_stmt><decl><type><name>char</name></type> <name><name>hostname</name><index>[<expr>255 + 1</expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Internet standard limit (RFC 1035):
					   ``To simplify implementations, the
					   total length of a domain name (i.e.,
					   label octets and label length
					   octets) is restricted to 255 octets
					   or less.'' */</comment>
	    <decl_stmt><decl><type><name>char</name></type> <name><name>yyyy_mm_dd_hh_mm_ss</name><index>[<expr>4 + 5 * (1 + 2) + 1</expr>]</index></name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>time_t</name></type> <name>now</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type>struct <name>tm</name> *</type><name>ltm</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>now</name> = <call><name>time</name><argument_list>(<argument><expr>(<name>time_t</name> *) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>ltm</name> = (struct <name>tm</name> *) <call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<call><name>gethostname</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0) &amp;&amp;
		(<call><name>strftime</name><argument_list>(<argument><expr><name>yyyy_mm_dd_hh_mm_ss</name></expr></argument>,
			  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>yyyy_mm_dd_hh_mm_ss</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr>"%Y.%m.%d.%H.%M.%S"</expr></argument>, <argument><expr><name>ltm</name></expr></argument>)</argument_list></call> &gt; 0)</expr>)</condition><then> <block>{
		<expr_stmt><expr>(<name>void</name>) <call><name>sprintf</name><argument_list>(<argument><expr><name>log_def_name</name></expr></argument>, <argument><expr>"Xterm.log.%.255s.%.20s.%d"</expr></argument>,
			       <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>yyyy_mm_dd_hh_mm_ss</name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr>(<name>log_default</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>log_def_name</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>log_def_name</name> =<init> <expr>"XtermLog.XXXXXX"</expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr>(<name>log_default</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>log_def_name</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	    <expr_stmt><expr><call><name>mktemp</name><argument_list>(<argument><expr><name>log_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>screen</name>-&gt;<name>logfile</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>log_default</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	    <return>return;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr>*<name>screen</name>-&gt;<name>logfile</name> == '|'</expr>)</condition><then> <block>{	<comment type="block">/* exec command */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGFILEEXEC</name></cpp:ifdef>
	<comment type="block">/*
	 * Warning, enabling this "feature" allows arbitrary programs
	 * to be run.  If ALLOWLOGFILECHANGES is enabled, this can be
	 * done through escape sequences....  You have been warned.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>p</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>shell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>passwd</name> *</type><name>pw</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> &lt; 0 || (<name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call>) &lt; 0</expr>)</condition><then>
	    <return>return;</return></then></if>
	<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then> <block>{		<comment type="block">/* child */</comment>
	    <comment type="block">/*
	     * Close our output (we won't be talking back to the
	     * parent), and redirect our child's output to the
	     * original stderr.
	     */</comment>
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>ConnectionNumber</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr>(((<name>cp</name> = <call><name>x_getenv</name><argument_list>(<argument><expr>"SHELL"</expr></argument>)</argument_list></call>) == <name>NULL</name>)
		 &amp;&amp; ((<name>pw</name> = <call><name>getpwuid</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>uid</name></expr></argument>)</argument_list></call>) == <name>NULL</name>
		     || *(<name>cp</name> = <name>pw</name>-&gt;<name>pw_shell</name>) == 0))
		|| (<name>shell</name> = <call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>dummy</name><index>[]</index></name> =<init> <expr>"/bin/sh"</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>shell</name> = <name>dummy</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>shell</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>

	    <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* (this is redundant) */</comment>
	    <if>if <condition>(<expr><call><name>xtermResetIds</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>ERROR_SETUID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	    <expr_stmt><expr><call><name>execl</name><argument_list>(<argument><expr><name>shell</name></expr></argument>, <argument><expr><name>shell</name></expr></argument>, <argument><expr>"-c"</expr></argument>, <argument><expr>&amp;<name>screen</name>-&gt;<name><name>logfile</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>(<name>void</name> *) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: Can't exec `%s'\n"</expr></argument>, <argument><expr><name>xterm_name</name></expr></argument>,
		    <argument><expr>&amp;<name>screen</name>-&gt;<name><name>logfile</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>ERROR_LOGEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>logfd</name> = <name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>logpipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr>(<name>screen</name>-&gt;<name>logfd</name> = <call><name>open_userfile</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>uid</name></expr></argument>,
					   <argument><expr><name>screen</name>-&gt;<name>gid</name></expr></argument>,
					   <argument><expr><name>screen</name>-&gt;<name>logfile</name></expr></argument>,
					   <argument><expr>(<name>log_default</name> != 0)</expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then>
	    <return>return;</return></then></if>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*VMS */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>logstart</name> = <name>VTbuffer</name>-&gt;<name>next</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>logging</name> = <name>True</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_logging</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>CloseLog</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>logging</name> || (<name>screen</name>-&gt;<name>inhibit</name> &amp; <name>I_LOG</name>)</expr>)</condition><then>
	<return>return;</return></then></if>
    <expr_stmt><expr><call><name>FlushLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>logfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>logging</name> = <name>False</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_logging</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>FlushLog</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>logging</name> &amp;&amp; !(<name>screen</name>-&gt;<name>inhibit</name> &amp; <name>I_LOG</name>)</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Char</name> *</type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>			<comment type="block">/* avoid logging output loops which otherwise occur sometimes
				   when there is no output and cp/screen-&gt;logstart are 1 apart */</comment>
	<if>if <condition>(<expr>!<name>tt_new_output</name></expr>)</condition><then>
	    <return>return;</return></then></if>
	<expr_stmt><expr><name>tt_new_output</name> = <name>False</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>
	<expr_stmt><expr><name>cp</name> = <name>VTbuffer</name>-&gt;<name>next</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>logstart</name> != 0
	    &amp;&amp; (<name>i</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>cp</name> - <name>screen</name>-&gt;<name>logstart</name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>IGNORE_RC</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>logfd</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>logstart</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>logstart</name> = <name>VTbuffer</name>-&gt;<name>next</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ALLOWLOGGING */</comment>

<comment type="block">/***====================================================================***/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>ReportAnsiColorRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>colornum</name></decl></param>, <param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>AllowColorOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ecGetAnsiColor</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XColor</name></type> <name>color</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Colormap</name></type> <name>cmap</name> =<init> <expr><name>xw</name>-&gt;<name>core</name>.<name>colormap</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ReportAnsiColorRequest %d\n", <name>colornum</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>color</name>.<name>pixel</name> = <call><name>GET_COLOR_RES</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>colornum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XQueryColor</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr>&amp;<name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"4;%d;rgb:%04x/%04x/%04x"</expr></argument>,
		<argument><expr><name>colornum</name></expr></argument>,
		<argument><expr><name>color</name>.<name>red</name></expr></argument>,
		<argument><expr><name>color</name>.<name>green</name></expr></argument>,
		<argument><expr><name>color</name>.<name>blue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_OSC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>unsigned</name></type>
<name>getColormapSize</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>display</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numFound</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XVisualInfo</name></type> <name>myTemplate</name>, *<name>visInfoPtr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>myTemplate</name>.<name>visualid</name> = <call><name>XVisualIDFromVisual</name><argument_list>(<argument><expr><call><name>DefaultVisual</name><argument_list>(<argument><expr><name>display</name></expr></argument>,
							    <argument><expr><call><name>XDefaultScreen</name><argument_list>(<argument><expr><name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>visInfoPtr</name> = <call><name>XGetVisualInfo</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr>(<name>long</name>) <name>VisualIDMask</name></expr></argument>,
				<argument><expr>&amp;<name>myTemplate</name></expr></argument>, <argument><expr>&amp;<name>numFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = (<name>numFound</name> &gt;= 1) ? (<name>unsigned</name>) <name>visInfoPtr</name>-&gt;<name>colormap_size</name> : 0</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XFree</name><argument_list>(<argument><expr>(<name>char</name> *) <name>visInfoPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Find closest color for "def" in "cmap".
 * Set "def" to the resulting color.
 *
 * Based on Monish Shah's "find_closest_color()" for Vim 6.0,
 * modified with ideas from David Tong's "noflash" library.
 * The code from Vim in turn was derived from FindClosestColor() in Tcl/Tk.
 *
 * These provide some introduction:
 *	http://en.wikipedia.org/wiki/YIQ
 *		for an introduction to YIQ weights.
 *	http://en.wikipedia.org/wiki/Luminance_(video)
 *		for a discussion of luma.
 *	http://en.wikipedia.org/wiki/YUV
 *
 * Return False if not able to find or allocate a color.
 */</comment>
<function><type><name>static</name> <name>Boolean</name></type>
<name>find_closest_color</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>dpy</name></decl></param>, <param><decl><type><name>Colormap</name></type> <name>cmap</name></decl></param>, <param><decl><type><name>XColor</name> *</type> <name>def</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Boolean</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XColor</name> *</type><name>colortable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>tried</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>diff</name>, <name>thisRGB</name>, <name>bestRGB</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>attempts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>bestInx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>cmap_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmap_size</name> = <call><name>getColormapSize</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cmap_size</name> != 0</expr>)</condition><then> <block>{

	<expr_stmt><expr><name>colortable</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>XColor</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>cmap_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>colortable</name> != 0</expr>)</condition><then> <block>{

	    <expr_stmt><expr><name>tried</name> = <call><name>TypeCallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>cmap_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>tried</name> != 0</expr>)</condition><then> <block>{

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>cmap_size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		    <expr_stmt><expr><name><name>colortable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pixel</name> = (<name>unsigned</name> <name>long</name>) <name>i</name></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>XQueryColors</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr><name>colortable</name></expr></argument>, <argument><expr>(<name>int</name>) <name>cmap_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try (possibly each entry in the color map) to find the best
		 * approximation to the requested color.
		 */</comment>
		<for>for (<init><expr><name>attempts</name> = 0</expr>;</init> <condition><expr><name>attempts</name> &lt; <name>cmap_size</name></expr>;</condition> <incr><expr><name>attempts</name>++</expr></incr>) <block>{
		    <decl_stmt><decl><type><name>Boolean</name></type> <name>first</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>

		    <expr_stmt><expr><name>bestRGB</name> = 0.0</expr>;</expr_stmt>
		    <expr_stmt><expr><name>bestInx</name> = 0</expr>;</expr_stmt>
		    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>cmap_size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>!<name><name>tried</name><index>[<expr><name>bestInx</name></expr>]</index></name></expr>)</condition><then> <block>{
			    <comment type="block">/*
			     * Look for the best match based on luminance.
			     * Measure this by the least-squares difference of
			     * the weighted R/G/B components from the color map
			     * versus the requested color.  Use the Y (luma)
			     * component of the YIQ color space model for
			     * weights that correspond to the luminance.
			     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>AddColorWeight</name>(weight, color) \
			    diff = weight * (int) ((def-&gt;color) - colortable[i].color); \
			    thisRGB = diff * diff</cpp:define>

			    <expr_stmt><expr><call><name>AddColorWeight</name><argument_list>(<argument><expr>0.30</expr></argument>, <argument><expr><name>red</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>AddColorWeight</name><argument_list>(<argument><expr>0.61</expr></argument>, <argument><expr><name>green</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>AddColorWeight</name><argument_list>(<argument><expr>0.11</expr></argument>, <argument><expr><name>blue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			    <if>if <condition>(<expr><name>first</name> || (<name>thisRGB</name> &lt; <name>bestRGB</name>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>first</name> = <name>False</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bestInx</name> = <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bestRGB</name> = <name>thisRGB</name></expr>;</expr_stmt>
			    }</block></then></if>
			}</block></then></if>
		    }</block></for>
		    <if>if <condition>(<expr><call><name>XAllocColor</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr>&amp;<name><name>colortable</name><index>[<expr><name>bestInx</name></expr>]</index></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>def</name> = <name><name>colortable</name><index>[<expr><name>bestInx</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
			<break>break;</break>
		    }</block></then></if>
		    <comment type="block">/*
		     * It failed - either the color map entry was readonly, or
		     * another client has allocated the entry.  Mark the entry
		     * so we will ignore it
		     */</comment>
		    <expr_stmt><expr><name><name>tried</name><index>[<expr><name>bestInx</name></expr>]</index></name> = <name>True</name></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>colortable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Allocate a color for the "ANSI" colors.  That actually includes colors up
 * to 256.
 *
 * Returns
 *	-1 on error
 *	0 on no change
 *	1 if a new color was allocated.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>AllocateAnsiColor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		  <param><decl><type><name>ColorRes</name> *</type> <name>res</name></decl></param>,
		  <param><decl><type><name>const</name> <name>char</name> *</type><name>spec</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XColor</name></type> <name>def</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Colormap</name></type> <name>cmap</name> =<init> <expr><name>xw</name>-&gt;<name>core</name>.<name>colormap</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>XParseColor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr>&amp;<name>def</name></expr></argument>)</argument_list></call>
	&amp;&amp; (<call><name>XAllocColor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr>&amp;<name>def</name></expr></argument>)</argument_list></call>
	    || <call><name>find_closest_color</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr>&amp;<name>def</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
	       <expr><name>res</name>-&gt;<name>mode</name> == <name>True</name> &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	       <call><name>EQL_COLOR_RES</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>def</name>.<name>pixel</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>SET_COLOR_RES</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>def</name>.<name>pixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("AllocateAnsiColor[%d] %s (pixel %#lx)\n",
		   <call>(<name>int</name>) <argument_list>(<argument><expr><name>res</name> - <name>screen</name>-&gt;<name>Acolors</name></expr></argument>)</argument_list></call>, <name>spec</name>, <name>def</name>.<name>pixel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
	    <if>if <condition>(<expr>!<name>res</name>-&gt;<name>mode</name></expr>)</condition><then>
		<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>res</name>-&gt;<name>mode</name> = <name>True</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></else></if>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("AllocateAnsiColor %s (failed)\n", <name>spec</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>(<name>result</name>)</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
<function><type><name>Pixel</name></type>
<name>xtermGetColorRes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ColorRes</name> *</type> <name>res</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Pixel</name></type> <name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>res</name>-&gt;<name>mode</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>res</name>-&gt;<name>value</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermGetColorRes for Acolors[%d]\n",
	       <call>(<name>int</name>) <argument_list>(<argument><expr><name>res</name> - <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>Acolors</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>res</name> &gt;= <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>Acolors</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>res</name> - <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>Acolors</name> &lt; <name>MAXCOLORS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><call><name>AllocateAnsiColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>res</name>-&gt;<name>resource</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>res</name>-&gt;<name>value</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEXT_FG</name></expr>]</index></name>.<name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name>-&gt;<name>mode</name> = -<name>True</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
			<argument><expr>"%s: Cannot allocate color %s\n"</expr></argument>,
			<argument><expr><name>xterm_name</name></expr></argument>,
			<argument><expr><call><name>NonNull</name><argument_list>(<argument><expr><name>res</name>-&gt;<name>resource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><name>result</name> = <name>res</name>-&gt;<name>value</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
	}</block></else></if>
    }</block></else></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>int</name></type>
<name>ChangeOneAnsiColor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>color</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>color</name> &lt; 0 || <name>color</name> &gt;= <name>MAXCOLORS</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>code</name> = -1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type><name>ColorRes</name> *</type><name>res</name> =<init> <expr>&amp;(<call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>color</name></expr>]</index></name>)</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ChangeAnsiColor for Acolors[%d]\n", <name>color</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>code</name> = <call><name>AllocateAnsiColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>code</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Set or query entries in the Acolors[] array by parsing pairs of color/name
 * values from the given buffer.
 *
 * The color can be any legal index into Acolors[], which consists of the
 * 16/88/256 "ANSI" colors, followed by special color values for the various
 * colorXX resources.  The indices for the special color values are not
 * simple to work with, so an alternative is to use the calls which pass in
 * 'first' set to the beginning of those indices.
 *
 * If the name is "?", report to the host the current value for the color.
 */</comment>
<function><type><name>static</name> <name>Bool</name></type>
<name>ChangeAnsiColorRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		       <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
		       <param><decl><type><name>int</name></type> <name>first</name></decl></param>,
		       <param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>color</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>repaint</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> =<init> <expr>(<name>MAXCOLORS</name> - <name>first</name>)</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ChangeAnsiColorRequest string='%s'\n", <name>buf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>buf</name> &amp;&amp; *<name>buf</name></expr>)</condition> <block>{
	<expr_stmt><expr><name>name</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
	    <break>break;</break></then></if>
	<expr_stmt><expr>*<name>name</name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><name>name</name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name>color</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>color</name> &lt; 0 || <name>color</name> &gt;= <name>last</name></expr>)</condition><then>
	    <break>break;</break></then></if>		<comment type="block">/* quit on any error */</comment>
	<expr_stmt><expr><name>buf</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buf</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
	    <expr_stmt><expr><name>buf</name>++</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"?"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ReportAnsiColorRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>color</name> + <name>first</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>code</name> = <call><name>ChangeOneAnsiColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>color</name> + <name>first</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>code</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* stop on any error */</comment>
		<break>break;</break>
	    }</block></then> <else>else <if>if <condition>(<expr><name>code</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>repaint</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then></if></else></if>
	    <comment type="block">/* FIXME:  free old color somehow?  We aren't for the other color
	     * change style (dynamic colors).
	     */</comment>
	}</block></else></if>
    }</block></while>

    <return>return <expr>(<name>repaint</name>)</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Bool</name></type>
<name>ResetOneAnsiColor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>color</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>repaint</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> =<init> <expr><name>MAXCOLORS</name> - <name>start</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>color</name> &gt;= 0 &amp;&amp; <name>color</name> &lt; <name>last</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>ColorRes</name> *</type><name>res</name> =<init> <expr>&amp;(<call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>color</name> + <name>start</name></expr>]</index></name>)</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>res</name>-&gt;<name>mode</name></expr>)</condition><then> <block>{
	    <comment type="block">/* a color has been allocated for this slot - test further... */</comment>
	    <if>if <condition>(<expr><call><name>ChangeOneAnsiColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>color</name> + <name>start</name></expr></argument>, <argument><expr><name>res</name>-&gt;<name>resource</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>repaint</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><name>repaint</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>ResetAnsiColorRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>repaint</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>color</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ResetAnsiColorRequest(%s)\n", <name>buf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>buf</name> != '\0'</expr>)</condition><then> <block>{
	<comment type="block">/* reset specific colors */</comment>
	<while>while <condition>(<expr>!<call><name>IsEmpty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	    <decl_stmt><decl><type><name>char</name> *</type><name>next</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>color</name> = (<name>int</name>) <call><name>strtol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>next</name> == <name>buf</name>) || (<name>color</name> &lt; 0)</expr>)</condition><then>
		<break>break;</break></then></if>		<comment type="block">/* no number at all */</comment>
	    <if>if <condition>(<expr><name>next</name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr>";"</expr></argument>, <argument><expr>*<name>next</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		    <break>break;</break></then></if>	<comment type="block">/* unexpected delimiter */</comment>
		<expr_stmt><expr>++<name>next</name></expr>;</expr_stmt>
	    }</block></then></if>

	    <if>if <condition>(<expr><call><name>ResetOneAnsiColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>++<name>repaint</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><name>buf</name> = <name>next</name></expr>;</expr_stmt>
	}</block></while>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...resetting all %d colors\n", <name>MAXCOLORS</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>color</name> = 0</expr>;</init> <condition><expr><name>color</name> &lt; <name>MAXCOLORS</name></expr>;</condition> <incr><expr>++<name>color</name></expr></incr>) <block>{
	    <if>if <condition>(<expr><call><name>ResetOneAnsiColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr>++<name>repaint</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></for>
    }</block></else></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...ResetAnsiColorRequest -&gt;%d\n", <name>repaint</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>repaint</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>find_closest_color</name>(display, cmap, def) 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_ISO_COLORS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>ManipulateSelectionData</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PDATA</name>(a,b) { a, #b }</cpp:define>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	<decl_stmt><decl><type><name>char</name></type> <name>given</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>String</name></type> <name>result</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>table</name><index>[]</index></name> = <block>{
	<expr><call><name>PDATA</name><argument_list>(<argument><expr>'s'</expr></argument>, <argument><expr><name>SELECT</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'p'</expr></argument>, <argument><expr><name>PRIMARY</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'c'</expr></argument>, <argument><expr><name>CLIPBOARD</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'0'</expr></argument>, <argument><expr><name>CUT_BUFFER0</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'1'</expr></argument>, <argument><expr><name>CUT_BUFFER1</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'2'</expr></argument>, <argument><expr><name>CUT_BUFFER2</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'3'</expr></argument>, <argument><expr><name>CUT_BUFFER3</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'4'</expr></argument>, <argument><expr><name>CUT_BUFFER4</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'5'</expr></argument>, <argument><expr><name>CUT_BUFFER5</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'6'</expr></argument>, <argument><expr><name>CUT_BUFFER6</name></expr></argument>)</argument_list></call></expr>,
	    <expr><call><name>PDATA</name><argument_list>(<argument><expr>'7'</expr></argument>, <argument><expr><name>CUT_BUFFER7</name></expr></argument>)</argument_list></call></expr>,
    }</block></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>base</name> =<init> <expr><name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>used</name> =<init> <expr><call><name>x_strdup</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>j</name>, <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> *</type><name>select_args</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Manipulate selection data\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr>*<name>buf</name> != ';' &amp;&amp; *<name>buf</name> != '\0'</expr>)</condition> <block>{
	<expr_stmt><expr>++<name>buf</name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr>*<name>buf</name> == ';'</expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>buf</name>++ = '\0'</expr>;</expr_stmt>

	<if>if <condition>(<expr>*<name>base</name> == '\0'</expr>)</condition><then>
	    <expr_stmt><expr><name>base</name> = "s0"</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>select_args</name> = <call><name>TypeCallocN</name><argument_list>(<argument><expr><name>String</name></expr></argument>, <argument><expr>1 + <call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	    <return>return;</return></then></if>
	<while>while <condition>(<expr>*<name>base</name> != '\0'</expr>)</condition> <block>{
	    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>base</name> == <name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>given</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name><name>used</name><index>[<expr><name>n</name></expr>]</index></name> = *<name>base</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>select_args</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>result</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("atom[%d] %s\n", <name>n</name>, <name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		}</block></then></if>
	    }</block></for>
	    <expr_stmt><expr>++<name>base</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name><name>used</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"?"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetSelection</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Getting selection\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_OSC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>"52"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Tell xtermGetSelection data is base64 encoded */</comment>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_paste</name> = <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>base64_final</name> = <name>final</name></expr>;</expr_stmt>

		<comment type="block">/* terminator will be written in this call */</comment>
		<expr_stmt><expr><call><name>xtermGetSelection</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>, <argument><expr>(<name>Time</name>) 0</expr></argument>, <argument><expr><name>select_args</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <block>{
	    <if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewSetSelection</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Setting selection with %s\n", <name>buf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ClearSelectionBuffer</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr>*<name>buf</name> != '\0'</expr>)</condition>
		    <expr_stmt><expr><call><name>AppendToSelectionBuffer</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>buf</name>++</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
		<expr_stmt><expr><call><name>CompleteSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>select_args</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></else></if>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_PASTE64 */</comment>

<comment type="block">/***====================================================================***/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsSetUtf8Title</name>(xw) (IsTitleMode(xw, tmSetUtf8) || (xw-&gt;screen.utf8_title))</cpp:define>

<function><type><name>static</name> <name>Bool</name></type>
<name>xtermIsPrintable</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>Char</name> **</type> <name>bufp</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>last</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>cp</name> =<init> <expr>*<name>bufp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>next</name> =<init> <expr><name>cp</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>) <name>screen</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>last</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>xtermEnvUTF8</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>IsSetUtf8Title</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>PtyData</name></type> <name>data</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>decodeUtf8</name><argument_list>(<argument><expr><call><name>fakePtyData</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>data</name>.<name>utf_data</name> != <name>UCS_REPL</name>
		&amp;&amp; (<name>data</name>.<name>utf_data</name> &gt;= 128 ||
		    <name><name>ansi_table</name><index>[<expr><name>data</name>.<name>utf_data</name></expr>]</index></name> == <name>CASE_PRINT</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>next</name> += (<name>data</name>.<name>utf_size</name> - 1)</expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_C1_PRINT</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>c1_printable</name>
	    &amp;&amp; (*<name>cp</name> &gt;= 128 &amp;&amp; *<name>cp</name> &lt; 160)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name><name>ansi_table</name><index>[<expr>*<name>cp</name></expr>]</index></name> == <name>CASE_PRINT</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>
    <expr_stmt><expr>*<name>bufp</name> = <name>next</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/***====================================================================***/</comment>

<comment type="block">/*
 * Enum corresponding to the actual OSC codes rather than the internal
 * array indices.  Compare with TermColors.
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <expr><name>OSC_TEXT_FG</name> = 10</expr>
    ,<expr><name>OSC_TEXT_BG</name></expr>
    ,<expr><name>OSC_TEXT_CURSOR</name></expr>
    ,<expr><name>OSC_MOUSE_FG</name></expr>
    ,<expr><name>OSC_MOUSE_BG</name></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    ,<expr><name>OSC_TEK_FG</name> = 15</expr>
    ,<expr><name>OSC_TEK_BG</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    ,<expr><name>OSC_HIGHLIGHT_BG</name> = 17</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    ,<expr><name>OSC_TEK_CURSOR</name> = 18</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    ,<expr><name>OSC_HIGHLIGHT_FG</name> = 19</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ,<expr><name>OSC_NCOLORS</name></expr>
}</block></enum></type> <name>OscTextColors</name>;</typedef>

<comment type="block">/*
 * Map codes to OSC controls that can reset colors.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>OSC_RESET</name> 100</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>OSC_Reset</name>(code) (code) + OSC_RESET</cpp:define>

<decl_stmt><decl><type><name>static</name> <name>ScrnColors</name> *</type><name>pOldColors</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><name>static</name> <name>Bool</name></type>
<name>GetOldColors</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>pOldColors</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>pOldColors</name> = (<name>ScrnColors</name> *) <call><name>XtMalloc</name><argument_list>(<argument><expr>(<name>Cardinal</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>ScrnColors</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pOldColors</name> == <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"allocation failure in GetOldColors\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>(<name>False</name>)</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>pOldColors</name>-&gt;<name>which</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NCOLORS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	    <expr_stmt><expr><name>pOldColors</name>-&gt;<name><name>colors</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>GetColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>pOldColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>True</name>)</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>oppositeColor</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{
    <case>case <expr><name>TEXT_FG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>TEXT_BG</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>TEXT_BG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>TEXT_FG</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>MOUSE_FG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>MOUSE_BG</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>MOUSE_BG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>MOUSE_FG</name></expr>;</expr_stmt>
	<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    </case><case>case <expr><name>TEK_FG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>TEK_BG</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>TEK_BG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>TEK_FG</name></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    </case><case>case <expr><name>HIGHLIGHT_FG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>HIGHLIGHT_BG</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>HIGHLIGHT_BG</name></expr>:
	<expr_stmt><expr><name>n</name> = <name>HIGHLIGHT_FG</name></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><default>default:
	<break>break;</break>
    </default>}</block></switch>
    <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>ReportColorRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>AllowColorOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ecGetColor</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XColor</name></type> <name>color</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Colormap</name></type> <name>cmap</name> =<init> <expr><name>xw</name>-&gt;<name>core</name>.<name>colormap</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * ChangeColorsRequest() has "always" chosen the opposite color when
	 * reverse-video is set.  Report this as the original color index, but
	 * reporting the opposite color which would be used.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>(<name>xw</name>-&gt;<name>misc</name>.<name>re_verse</name>) ? <call><name>oppositeColor</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call> : <name>ndx</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetOldColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>color</name>.<name>pixel</name> = <name>pOldColors</name>-&gt;<name><name>colors</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XQueryColor</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr>&amp;<name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"%d;rgb:%04x/%04x/%04x"</expr></argument>, <argument><expr><name>i</name> + 10</expr></argument>,
		<argument><expr><name>color</name>.<name>red</name></expr></argument>,
		<argument><expr><name>color</name>.<name>green</name></expr></argument>,
		<argument><expr><name>color</name>.<name>blue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ReportColors %d: %#lx as %s\n",
	       <name>ndx</name>, <name>pOldColors</name>-&gt;<name><name>colors</name><index>[<expr><name>ndx</name></expr>]</index></name>, <name>buffer</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_OSC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>Bool</name></type>
<name>UpdateOldColors</name><parameter_list>(<param><decl><type><name>XtermWidget</name> <name>xw</name></type> <name>GCC_UNUSED</name></decl></param>, <param><decl><type><name>ScrnColors</name> *</type> <name>pNew</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* if we were going to free old colors, this would be the place to
     * do it.   I've decided not to (for now), because it seems likely
     * that we'd have a small set of colors we use over and over, and that
     * we could save some overhead this way.   The only case in which this
     * (clearly) fails is if someone is trying a boatload of colors, in
     * which case they can restart xterm
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NCOLORS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>pNew</name>-&gt;<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pNew</name>-&gt;<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><name>pOldColors</name>-&gt;<name><name>colors</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pNew</name>-&gt;<name><name>colors</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
    <return>return <expr>(<name>True</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
 * OSC codes are constant, but the indices for the color arrays depend on how
 * xterm is compiled.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>OscToColorIndex</name><parameter_list>(<param><decl><type><name>OscTextColors</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>CASE</name>(name) case OSC_##name: result = name; break</cpp:define>
    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>TEK_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>TEK_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><name>TEK_CURSOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>OSC_NCOLORS</name></expr>:
	<break>break;</break>
    </case>}</block></switch>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Bool</name></type>
<name>ChangeColorsRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		    <param><decl><type><name>int</name></type> <name>start</name></decl></param>,
		    <param><decl><type><name>char</name> *</type><name>names</name></decl></param>,
		    <param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>thisName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnColors</name></type> <name>newColors</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>ndx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ChangeColorsRequest start=%d, names='%s'\n", <name>start</name>, <name>names</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>GetOldColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>newColors</name>.<name>which</name> = 0</expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NCOLORS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	    <expr_stmt><expr><name>newColors</name>.<name><name>names</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init><expr><name>i</name> = <name>start</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>OSC_NCOLORS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	    <expr_stmt><expr><name>ndx</name> = <call><name>OscToColorIndex</name><argument_list>(<argument><expr>(<name>OscTextColors</name>) <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>re_verse</name></expr>)</condition><then>
		<expr_stmt><expr><name>ndx</name> = <call><name>oppositeColor</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	    <if>if <condition>(<expr><call><name>IsEmpty</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>newColors</name>.<name><name>names</name><index>[<expr><name>ndx</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<if>if <condition>(<expr><name><name>names</name><index>[<expr>0</expr>]</index></name> == ';'</expr>)</condition><then>
		    <expr_stmt><expr><name>thisName</name> = <name>NULL</name></expr>;</expr_stmt></then>
		<else>else
		    <expr_stmt><expr><name>thisName</name> = <name>names</name></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>names</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>names</name> != <name>NULL</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr>*<name>names</name>++ = '\0'</expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>thisName</name> != 0 &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>thisName</name></expr></argument>, <argument><expr>"?"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>ReportColorRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr>!<name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>ndx</name></expr>]</index></name>
			   || (<name>thisName</name>
			       &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>thisName</name></expr></argument>, <argument><expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>ndx</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>AllocateTermColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>newColors</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><name>thisName</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if></else></if>
	    }</block></else></if>
	}</block></for>

	<if>if <condition>(<expr><name>newColors</name>.<name>which</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ChangeColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>newColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UpdateOldColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>newColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>Bool</name></type>
<name>ResetColorsRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		   <param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>thisName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnColors</name></type> <name>newColors</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ndx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ResetColorsRequest code=%d\n", <name>code</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>GetOldColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ndx</name> = <call><name>OscToColorIndex</name><argument_list>(<argument><expr><call>(<name>OscTextColors</name>) <argument_list>(<argument><expr><name>code</name> - <name>OSC_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>re_verse</name></expr>)</condition><then>
	    <expr_stmt><expr><name>ndx</name> = <call><name>oppositeColor</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>thisName</name> = <name>xw</name>-&gt;<name>screen</name>.<name><name>Tcolors</name><index>[<expr><name>ndx</name></expr>]</index></name>.<name>resource</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newColors</name>.<name>which</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>newColors</name>.<name><name>names</name><index>[<expr><name>ndx</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>thisName</name> != 0
	    &amp;&amp; <name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>ndx</name></expr>]</index></name> != 0
	    &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>thisName</name></expr></argument>, <argument><expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>ndx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>AllocateTermColor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>newColors</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><name>thisName</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name>newColors</name>.<name>which</name> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ChangeColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>newColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateOldColors</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>newColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
<comment type="block">/*
 * Initially, 'source' points to '#' or '?'.
 *
 * Look for an optional sign and optional number.  If those are found, lookup
 * the corresponding menu font entry.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>ParseShiftedFont</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>char</name> *</type><name>source</name></decl></param>, <param><decl><type><name>char</name> **</type><name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num</name> =<init> <expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rel</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>*++<name>source</name> == '+'</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>rel</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>source</name>++</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>*<name>source</name> == '-'</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>rel</name> = -1</expr>;</expr_stmt>
	<expr_stmt><expr><name>source</name>++</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>val</name> =<init> <expr><call><name>atoi</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>rel</name> &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>rel</name> = <name>val</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>rel</name> &lt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>rel</name> = -<name>val</name></expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>num</name> = <name>val</name></expr>;</expr_stmt></else></if></else></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>rel</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>num</name> = <call><name>lookupRelativeFontSize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				     <argument><expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ParseShiftedFont(%s) -&gt;%d (%s)\n", *<name>target</name>, <name>num</name>, <name>source</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>target</name> = <name>source</name></expr>;</expr_stmt>
    <return>return <expr><name>num</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>QueryFontRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>AllowFontOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>efGetFont</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bool</name></type> <name>success</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>base</name> =<init> <expr><name>buf</name> + 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>temp</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num</name> = <call><name>ParseShiftedFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>num</name> &lt; 0
	    || <name>num</name> &gt; <name>fontMenu_lastBuiltin</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>success</name> = <name>False</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
	    <if>if <condition>(<expr><call><name>UsingRenderFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>name</name> = <call><name>getFaceName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr>(<name>name</name> = <name>screen</name>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>success</name> = <name>False</name></expr>;</expr_stmt>
	    }</block></then></if></else></if>
	}</block></else></if>

	<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_OSC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>"50"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>success</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>buf</name> &gt;= <name>base</name></expr>)</condition><then> <block>{
		<comment type="block">/* identify the font-entry, unless it is the current one */</comment>
		<if>if <condition>(<expr>*<name>buf</name> != '\0'</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'#'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr>*<name>name</name> != '\0'</expr>)</condition><then>
			<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>ChangeFontRequest</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>AllowFontOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>efSetFont</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bool</name></type> <name>success</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VTFontNames</name></type> <name>fonts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the font specification is a "#", followed by an optional sign and
	 * optional number, lookup the corresponding menu font entry.
	 *
	 * Further, if the "#", etc., is followed by a font name, use that
	 * to load the font entry.
	 */</comment>
	<if>if <condition>(<expr>*<name>buf</name> == '#'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>num</name> = <call><name>ParseShiftedFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name>num</name> &lt; 0
		|| <name>num</name> &gt; <name>fontMenu_lastBuiltin</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>success</name> = <name>False</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<comment type="block">/*
		 * Skip past the optional number, and any whitespace to look
		 * for a font specification within the control.
		 */</comment>
		<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		    <expr_stmt><expr>++<name>buf</name></expr>;</expr_stmt>
		}</block></while>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		    <expr_stmt><expr>++<name>buf</name></expr>;</expr_stmt>
		}</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
		<if>if <condition>(<expr><call><name>UsingRenderFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <empty_stmt>;</empty_stmt>		<comment type="block">/* there is only one font entry to load */</comment>
		}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{
		    <comment type="block">/*
		     * Normally there is no font specified in the control.
		     * But if there is, simply overwrite the font entry.
		     */</comment>
		    <if>if <condition>(<expr>*<name>buf</name> == '\0'</expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>buf</name> = <name>screen</name>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
			    <expr_stmt><expr><name>success</name> = <name>False</name></expr>;</expr_stmt>
			}</block></then></if>
		    }</block></then></if>
		}</block></else></if>
	    }</block></else></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>num</name> = <name>screen</name>-&gt;<name>menu_font_number</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>name</name> = <call><name>x_strtrim</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>success</name> &amp;&amp; !<call><name>IsEmpty</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
	    <if>if <condition>(<expr><call><name>UsingRenderFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>setFaceName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xtermUpdateFontInfo</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <block>{
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>fonts</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>fonts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fonts</name>.<name>f_n</name> = <name>name</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetVTFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>True</name></expr></argument>, <argument><expr>&amp;<name>fonts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SHIFT_FONTS */</comment>

<comment type="block">/***====================================================================***/</comment>

<function><type><name>void</name></type>
<name>do_osc</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>oscbuf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>state</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>temp</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>ansi_colors</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>Bool</name></type> <name>need_data</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_osc %s\n", <name>oscbuf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lines should be of the form &lt;OSC&gt; number ; string &lt;ST&gt;, however
     * older xterms can accept &lt;BEL&gt; as a final character.  We will respond
     * with the same final character as the application sends to make this
     * work better with shell scripts, which may have trouble reading an
     * &lt;ESC&gt;&lt;backslash&gt;, which is the 7-bit equivalent to &lt;ST&gt;.
     */</comment>
    <expr_stmt><expr><name>mode</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>cp</name> = <name>oscbuf</name></expr>;</init> <condition><expr>*<name>cp</name> != '\0'</expr>;</condition> <incr><expr><name>cp</name>++</expr></incr>) <block>{
	<switch>switch <condition>(<expr><name>state</name></expr>)</condition> <block>{
	<case>case <expr>0</expr>:
	    <if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>mode</name> = 10 * <name>mode</name> + (*<name>cp</name> - '0')</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>mode</name> &gt; 65535</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_osc found unknown mode %d\n", <name>mode</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return;</return>
		}</block></then></if>
		<break>break;</break>
	    }</block></then></if>
	    <comment type="block">/* FALLTHRU */</comment>
	</case><case>case <expr>1</expr>:
	    <if>if <condition>(<expr>*<name>cp</name> != ';'</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_osc did not find semicolon offset %d\n",
		       <call>(<name>int</name>) <argument_list>(<argument><expr><name>cp</name> - <name>oscbuf</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	    }</block></then></if>
	    <expr_stmt><expr><name>state</name> = 2</expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>2</expr>:
	    <expr_stmt><expr><name>buf</name> = (<name>char</name> *) <name>cp</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>state</name> = 3</expr>;</expr_stmt>
	    <comment type="block">/* FALLTHRU */</comment>
	</case><default>default:
	    <if>if <condition>(<expr>!<call><name>xtermIsPrintable</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr><name>oscbuf</name> + <name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{
		<case>case <expr>0</expr>:
		</case><case>case <expr>1</expr>:
		</case><case>case <expr>2</expr>:
		    <break>break;</break>
		</case><default>default:
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_osc found nonprinting char %02X offset %d\n",
			   <call><name>CharOf</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call>,
			   <call>(<name>int</name>) <argument_list>(<argument><expr><name>cp</name> - <name>oscbuf</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return;</return>
		</default>}</block></switch>
	    }</block></then></if>
	</default>}</block></switch>
    }</block></for>

    <comment type="block">/*
     * Most OSC controls other than resets require data.  Handle the others as
     * a special case.
     */</comment>
    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEXT_FG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEXT_BG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_MOUSE_FG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_MOUSE_BG</name></expr></argument>)</argument_list></call></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEK_FG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEK_BG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEK_CURSOR</name></expr></argument>)</argument_list></call></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>need_data</name> = <name>False</name></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><default>default:
	<break>break;</break>
    </default>}</block></switch>

    <comment type="block">/*
     * Check if we have data when we want, and not when we do not want it.
     * Either way, that is a malformed control sequence, and will be ignored.
     */</comment>
    <if>if <condition>(<expr><call><name>IsEmpty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>need_data</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_osc found no data\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>temp</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> = <name>temp</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>!<name>need_data</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_osc found found unwanted data\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if></else></if>

    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{
    <case>case <expr>0</expr>:			<comment type="block">/* new icon name and title */</comment>
	<expr_stmt><expr><call><name>ChangeIconName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ChangeTitle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr>1</expr>:			<comment type="block">/* new icon name only */</comment>
	<expr_stmt><expr><call><name>ChangeIconName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr>2</expr>:			<comment type="block">/* new title only */</comment>
	<expr_stmt><expr><call><name>ChangeTitle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>

    </case><case>case <expr>3</expr>:			<comment type="block">/* change X property */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewSetXprop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>ChangeXprop</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    </case><case>case <expr>5</expr>:
	<expr_stmt><expr><name>ansi_colors</name> = <name>NUM_ANSI_COLORS</name></expr>;</expr_stmt>
	<comment type="block">/* FALLTHRU */</comment>
    </case><case>case <expr>4</expr>:
	<if>if <condition>(<expr><call><name>ChangeAnsiColorRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ansi_colors</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>xtermRepaint</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<break>break;</break>
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>:
	<expr_stmt><expr><name>ansi_colors</name> = <name>NUM_ANSI_COLORS</name></expr>;</expr_stmt>
	<comment type="block">/* FALLTHRU */</comment>
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>:
	<if>if <condition>(<expr><call><name>ResetAnsiColorRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ansi_colors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>xtermRepaint</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr><name>OSC_TEXT_FG</name></expr>:
    </case><case>case <expr><name>OSC_TEXT_BG</name></expr>:
    </case><case>case <expr><name>OSC_TEXT_CURSOR</name></expr>:
    </case><case>case <expr><name>OSC_MOUSE_FG</name></expr>:
    </case><case>case <expr><name>OSC_MOUSE_BG</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    </case><case>case <expr><name>OSC_HIGHLIGHT_BG</name></expr>:
    </case><case>case <expr><name>OSC_HIGHLIGHT_FG</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    </case><case>case <expr><name>OSC_TEK_FG</name></expr>:
    </case><case>case <expr><name>OSC_TEK_BG</name></expr>:
    </case><case>case <expr><name>OSC_TEK_CURSOR</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>dynamicColors</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ChangeColorsRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEXT_FG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEXT_BG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_MOUSE_FG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_MOUSE_BG</name></expr></argument>)</argument_list></call></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEK_FG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEK_BG</name></expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>OSC_Reset</name><argument_list>(<argument><expr><name>OSC_TEK_CURSOR</name></expr></argument>)</argument_list></call></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>dynamicColors</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ResetColorsRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr>30</expr>:
    </case><case>case <expr>31</expr>:
	<comment type="block">/* reserved for Konsole (Stephan Binner &lt;Stephan.Binner@gmx.de&gt;) */</comment>
	<break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
    </case><case>case <expr>46</expr>:			<comment type="block">/* new log file */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGFILECHANGES</name></cpp:ifdef>
	<comment type="block">/*
	 * Warning, enabling this feature allows people to overwrite
	 * arbitrary files accessible to the person running xterm.
	 */</comment>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"?"</expr></argument>)</argument_list></call>
	    &amp;&amp; (<name>cp</name> = <call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>logfile</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>logfile</name> = <name>cp</name></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ALLOWLOGGING */</comment>

    </case><case>case <expr>50</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
	<if>if <condition>(<expr>*<name>buf</name> == '?'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>QueryFontRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>shift_fonts</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ChangeFontRequest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SHIFT_FONTS */</comment>
	<break>break;</break>
    </case><case>case <expr>51</expr>:
	<comment type="block">/* reserved for Emacs shell (Rob Mayoff &lt;mayoff@dqd.com&gt;) */</comment>
	<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PASTE64</name></expr></cpp:if>
    </case><case>case <expr>52</expr>:
	<expr_stmt><expr><call><name>ManipulateSelectionData</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/*
	 * One could write code to send back the display and host names,
	 * but that could potentially open a fairly nasty security hole.
	 */</comment>
    </case><default>default:
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_osc - unrecognized code\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </default>}</block></switch>
    <expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SunXK_F36</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_UDK</name> 37</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_UDK</name> 35</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>static</name></type> struct <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
}</block></decl></decl_stmt> <expr_stmt><expr><name><name>user_keys</name><index>[<expr><name>MAX_UDK</name></expr>]</index></name></expr>;</expr_stmt>

<comment type="block">/*
 * Parse one nibble of a hex byte from the OSC string.  We have removed the
 * string-terminator (replacing it with a null), so the only other delimiter
 * that is expected is semicolon.  Ignore other characters (Ray Neuman says
 * "real" terminals accept commas in the string definitions).
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>udk_value</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> **</type><name>cp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
	<if>if <condition>(<expr>(<name>c</name> = **<name>cp</name>) != '\0'</expr>)</condition><then>
	    <expr_stmt><expr>*<name>cp</name> = *<name>cp</name> + 1</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>c</name> == ';' || <name>c</name> == '\0'</expr>)</condition><then>
	    <break>break;</break></then></if>
	<if>if <condition>(<expr>(<name>result</name> = <call><name>x_hex2int</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>) &gt;= 0</expr>)</condition><then>
	    <break>break;</break></then></if>
    }</block></for>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>reset_decudk</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>MAX_UDK</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><name><name>user_keys</name><index>[<expr><name>n</name></expr>]</index></name>.<name>str</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>user_keys</name><index>[<expr><name>n</name></expr>]</index></name>.<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>user_keys</name><index>[<expr><name>n</name></expr>]</index></name>.<name>str</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>user_keys</name><index>[<expr><name>n</name></expr>]</index></name>.<name>len</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
}</block></function>

<comment type="block">/*
 * Parse the data for DECUDK (user-defined keys).
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>parse_decudk</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>cp</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr>*<name>cp</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>base</name> =<init> <expr><name>cp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>str</name> =<init> <expr><call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>key</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lo</name>, <name>hi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>key</name> = (<name>key</name> * 10) + <call>(<name>unsigned</name>) <argument_list>(<argument><expr>*<name>cp</name>++ - '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	<if>if <condition>(<expr>*<name>cp</name> == '/'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt>
	    <while>while <condition>(<expr>(<name>hi</name> = <call><name>udk_value</name><argument_list>(<argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call>) &gt;= 0
		   &amp;&amp; (<name>lo</name> = <call><name>udk_value</name><argument_list>(<argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call>) &gt;= 0</expr>)</condition> <block>{
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>len</name>++</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>hi</name> &lt;&lt; 4) | <name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></while>
	}</block></then></if>
	<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name>key</name> &lt; <name>MAX_UDK</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name><name>user_keys</name><index>[<expr><name>key</name></expr>]</index></name>.<name>str</name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>user_keys</name><index>[<expr><name>key</name></expr>]</index></name>.<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name><name>user_keys</name><index>[<expr><name>key</name></expr>]</index></name>.<name>str</name> = <name>str</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>user_keys</name><index>[<expr><name>key</name></expr>]</index></name>.<name>len</name> = <name>len</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<if>if <condition>(<expr>*<name>cp</name> == ';'</expr>)</condition><then>
	    <expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>cp</name> == <name>base</name></expr>)</condition><then>		<comment type="block">/* badly-formed sequence - bail out */</comment>
	    <break>break;</break></then></if>
    }</block></while>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>SOFT_WIDE</name> 10</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>SOFT_HIGH</name> 20</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>parse_decdld</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type> <name>params</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>string</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>DscsName</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pfn</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pcn</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pe</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>2</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pcmw</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>3</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pw</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>4</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pt</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>5</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pcmh</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>6</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>Pcss</name> =<init> <expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr>7</expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>start_char</name> =<init> <expr><name>Pcn</name> + 0x20</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>char_wide</name> =<init> <expr>((<name>Pcmw</name> == 0)
		     ? (<name>Pcss</name> ? 6 : 10)
		     : (<name>Pcmw</name> &gt; 4
			? <name>Pcmw</name>
			: (<name>Pcmw</name> + 3)))</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>char_high</name> =<init> <expr>((<name>Pcmh</name> == 0)
		     ? ((<name>Pcmw</name> &gt;= 2 || <name>Pcmw</name> &lt;= 4)
			? 10
			: 20)
		     : <name>Pcmh</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name></type> <name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name></type> <name><name>bits</name><index>[<expr><name>SOFT_HIGH</name></expr>]</index><index>[<expr><name>SOFT_WIDE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>first</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>prior</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr>0</expr>, <expr><name>col</name> = 0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Parsing DECDLD\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  font number   %d\n", <name>Pfn</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  starting char %d\n", <name>Pcn</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  erase control %d\n", <name>Pe</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  char-width    %d\n", <name>Pcmw</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  font-width    %d\n", <name>Pw</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  text/full     %d\n", <name>Pt</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  char-height   %d\n", <name>Pcmh</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  charset-size  %d\n", <name>Pcss</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>Pfn</name> &gt; 1
	|| <name>Pcn</name> &gt; 95
	|| <name>Pe</name> &gt; 2
	|| <name>Pcmw</name> &gt; 10
	|| <name>Pcmw</name> == 1
	|| <name>Pt</name> &gt; 2
	|| <name>Pcmh</name> &gt; 20
	|| <name>Pcss</name> &gt; 1
	|| <name>char_wide</name> &gt; <name>SOFT_WIDE</name>
	|| <name>char_high</name> &gt; <name>SOFT_HIGH</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DECDLD illegal parameter\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
    <while>while <condition>(<expr>*<name>string</name> != '\0'</expr>)</condition> <block>{
	<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr>*<name>string</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ch</name> &gt;= <name>ANSI_SPA</name> &amp;&amp; <name>ch</name> &lt;= 0x2f</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then>
		<expr_stmt><expr><name><name>DscsName</name><index>[<expr><name>len</name>++</expr>]</index></name> = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> &gt;= 0x30 &amp;&amp; <name>ch</name> &lt;= 0x7e</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name><name>DscsName</name><index>[<expr><name>len</name>++</expr>]</index></name> = (<name>char</name>) <name>ch</name></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if></else></if>
    }</block></while>
    <expr_stmt><expr><name><name>DscsName</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  Dscs name     '%s'\n", <name>DscsName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("  character matrix %dx%d\n", <name>char_high</name>, <name>char_wide</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>*<name>string</name> != '\0'</expr>)</condition> <block>{
	<if>if <condition>(<expr><name>first</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Char %d:\n", <name>start_char</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>prior</name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>row</name> = 0</expr>;</init> <condition><expr><name>row</name> &lt; <name>char_high</name></expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%.*s\n", <name>char_wide</name>, <name><name>bits</name><index>[<expr><name>row</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
	    }</block></then></if>
	    <expr_stmt><expr><name>prior</name> = <name>False</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>first</name> = <name>False</name></expr>;</expr_stmt>
	    <for>for (<init><expr><name>row</name> = 0</expr>;</init> <condition><expr><name>row</name> &lt; <name>char_high</name></expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
		<for>for (<init><expr><name>col</name> = 0</expr>;</init> <condition><expr><name>col</name> &lt; <name>char_wide</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
		    <expr_stmt><expr><name><name>bits</name><index>[<expr><name>row</name></expr>]</index><index>[<expr><name>col</name></expr>]</index></name> = '.'</expr>;</expr_stmt>
		}</block></for>
	    }</block></for>
	    <expr_stmt><expr><name>row</name> = <name>col</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr>*<name>string</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ch</name> &gt;= 0x3f &amp;&amp; <name>ch</name> &lt;= 0x7e</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>ch</name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>ch</name> - 0x3f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; 6</expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		<expr_stmt><expr><name><name>bits</name><index>[<expr><name>row</name> + <name>n</name></expr>]</index><index>[<expr><name>col</name></expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr>(<name>ch</name> &amp; (1 &lt;&lt; <name>n</name>)) ? '*' : '.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></for>
	    <expr_stmt><expr><name>col</name> += 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>prior</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '/'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>row</name> += 6</expr>;</expr_stmt>
	    <expr_stmt><expr><name>col</name> = 0</expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == ';'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>first</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>start_char</name></expr>;</expr_stmt>
	}</block></then></if></else></if></else></if>
    }</block></while>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>parse_decdld</name>(p,q)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Parse numeric parameters.  Normally we use a state machine to simplify
 * interspersing with control characters, but have the string already.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>parse_ansi_params</name><parameter_list>(<param><decl><type><name>ANSI</name> *</type> <name>params</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> **</type><name>string</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>cp</name> =<init> <expr>*<name>string</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParmType</name></type> <name>nparam</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>*<name>cp</name> != '\0'</expr>)</condition> <block>{
	<decl_stmt><decl><type><name>Char</name></type> <name>ch</name> =<init> <expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>cp</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>nparam</name> &lt; <name>NPARAM</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>params</name>-&gt;<name><name>a_param</name><index>[<expr><name>nparam</name></expr>]</index></name> =
		    <call>(<name>ParmType</name>) <argument_list>(<argument><expr>(<name>params</name>-&gt;<name><name>a_param</name><index>[<expr><name>nparam</name></expr>]</index></name> * 10)
				+ (<name>ch</name> - '0')</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == ';'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>++<name>nparam</name> &lt; <name>NPARAM</name></expr>)</condition><then>
		<expr_stmt><expr><name>params</name>-&gt;<name>a_nparam</name> = <name>nparam</name></expr>;</expr_stmt></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> &lt; 32</expr>)</condition><then> <block>{
	    <empty_stmt>;</empty_stmt>
	}</block></then> <else>else <block>{
	    <comment type="block">/* should be 0x30 to 0x7e */</comment>
	    <expr_stmt><expr><name>params</name>-&gt;<name>a_final</name> = <name>ch</name></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></else></if></else></if></else></if>
    }</block></while>
    <expr_stmt><expr>*<name>string</name> = <name>cp</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>do_dcs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>dcsbuf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>dcslen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>reply</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>cp</name> =<init> <expr>(<name>const</name> <name>char</name> *) <name>dcsbuf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>okay</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ANSI</name></type> <name>params</name></decl>;</decl_stmt>

    <macro><name>TRACE</name><argument_list>(<argument>("do_dcs(%s:%lu)\n", (char *) dcsbuf, (unsigned long) dcslen)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr><name>dcslen</name> != <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<comment type="block">/* shouldn't have nulls in the string */</comment>
	<return>return;</return></then></if>

    <switch>switch <condition>(<expr>*<name>cp</name></expr>)</condition> <block>{		<comment type="block">/* intermediate character, or parameter */</comment>
    <case>case <expr>'$'</expr>:			<comment type="block">/* DECRQSS */</comment>
	<expr_stmt><expr><name>okay</name> = <name>True</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>cp</name>++ == 'q'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>"\"q"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* DECSCA */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>"%d%s"</expr></argument>,
			<argument><expr>(<name>screen</name>-&gt;<name>protected_mode</name> == <name>DEC_PROTECT</name>)
			&amp;&amp; (<name>xw</name>-&gt;<name>flags</name> &amp; <name>PROTECTED</name>) ? 1 : 0</expr></argument>,
			<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>"\"p"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* DECSCL */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>"%d%s%s"</expr></argument>,
			<argument><expr>(<name>screen</name>-&gt;<name>vtXX_level</name> ?
			 <name>screen</name>-&gt;<name>vtXX_level</name> : 1) + 60</expr></argument>,
			<argument><expr>(<name>screen</name>-&gt;<name>vtXX_level</name> &gt;= 2)
			? (<name>screen</name>-&gt;<name>control_eight_bits</name>
			   ? ";0" : ";1")
			: ""</expr></argument>,
			<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* DECSTBM */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>"%d;%dr"</expr></argument>,
			<argument><expr><name>screen</name>-&gt;<name>top_marg</name> + 1</expr></argument>,
			<argument><expr><name>screen</name>-&gt;<name>bot_marg</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>"m"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* SGR */</comment>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>BOLD</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>";1"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>UNDERLINE</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>";4"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>BLINK</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>";5"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>INVERSE</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>";7"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>INVISIBLE</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>";8"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_256_COLORS</name> || <name>OPT_88_COLORS</name></expr></cpp:if>
		<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
		    if (xw-&gt;flags &amp; FG_COLOR) {
			if (xw-&gt;cur_foreground &gt;= 16)
			    sprintf(reply + strlen(reply),
				    ";38;5;%d", xw-&gt;cur_foreground);
			else
			    sprintf(reply + strlen(reply),
				    ";%d%d",
				    xw-&gt;cur_foreground &gt;= 8 ? 9 : 3,
				    xw-&gt;cur_foreground &gt;= 8 ?
				    xw-&gt;cur_foreground - 8 :
				    xw-&gt;cur_foreground);
		    }
		    if (xw-&gt;flags &amp; BG_COLOR) {
			if (xw-&gt;cur_background &gt;= 16)
			    sprintf(reply + strlen(reply),
				    ";48;5;%d", xw-&gt;cur_foreground);
			else
			    sprintf(reply + strlen(reply),
				    ";%d%d",
				    xw-&gt;cur_background &gt;= 8 ? 10 : 4,
				    xw-&gt;cur_background &gt;= 8 ?
				    xw-&gt;cur_background - 8 :
				    xw-&gt;cur_background);
		    }
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:elif>
		<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
		    if (xw-&gt;flags &amp; FG_COLOR)
			sprintf(reply + strlen(reply),
				";%d%d",
				xw-&gt;cur_foreground &gt;= 8 ? 9 : 3,
				xw-&gt;cur_foreground &gt;= 8 ?
				xw-&gt;cur_foreground - 8 :
				xw-&gt;cur_foreground);
		    if (xw-&gt;flags &amp; BG_COLOR)
			sprintf(reply + strlen(reply),
				";%d%d",
				xw-&gt;cur_background &gt;= 8 ? 10 : 4,
				xw-&gt;cur_background &gt;= 8 ?
				xw-&gt;cur_background - 8 :
				xw-&gt;cur_background);
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>reply</name></expr></argument>, <argument><expr>"m"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else
		<expr_stmt><expr><name>okay</name> = <name>False</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if>

	    <if>if <condition>(<expr><name>okay</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_DCS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>okay</name> ? '1' : '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'$'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'r'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name> = <name>reply</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_CAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_CAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TCAP_QUERY</name></expr></cpp:if>
    </case><case>case <expr>'+'</expr>:
	<expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt>
	<switch>switch <condition>(<expr>*<name>cp</name></expr>)</condition> <block>{
	<case>case <expr>'p'</expr>:
	    <if>if <condition>(<expr><call><name>AllowTcapOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>etSetTcap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_termcap</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>cp</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
	</case><case>case <expr>'q'</expr>:
	    <if>if <condition>(<expr><call><name>AllowTcapOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>etGetTcap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Bool</name></type> <name>fkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>parsed</name> =<init> <expr>++<name>cp</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>code</name> = <call><name>xtermcapKeycode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>parsed</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>, <argument><expr>&amp;<name>fkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_DCS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>code</name> &gt;= 0 ? '1' : '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'+'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'r'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr>*<name>cp</name> != 0 &amp;&amp; (<name>code</name> &gt;= -1)</expr>)</condition> <block>{
		    <if>if <condition>(<expr><name>cp</name> == <name>parsed</name></expr>)</condition><then>
			<break>break;</break></then></if>	<comment type="block">/* no data found, error */</comment>

		    <for>for (<init><expr><name>tmp</name> = <name>cp</name></expr>;</init> <condition><expr><name>tmp</name> != <name>parsed</name></expr>;</condition> <incr><expr>++<name>tmp</name></expr></incr>)
			<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>*<name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

		    <if>if <condition>(<expr><name>code</name> &gt;= 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>tc_query_code</name> = <name>code</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>tc_query_fkey</name> = <name>fkey</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
			<comment type="block">/* XK_COLORS is a fake code for the "Co" entry (maximum
			 * number of colors) */</comment>
			<if>if <condition>(<expr><name>code</name> == <name>XK_COLORS</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>unparseputn</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>NUM_ANSI_COLORS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if>if <condition>(<expr><name>code</name> == <name>XK_TCAPNAME</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>xterm_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
			    <decl_stmt><decl><type><name>XKeyEvent</name></type> <name>event</name></decl>;</decl_stmt>
			    <expr_stmt><expr><name>event</name>.<name>state</name> = <name>state</name></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>Input</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if></else></if>
			<expr_stmt><expr><name>screen</name>-&gt;<name>tc_query_code</name> = -1</expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<break>break;</break>	<comment type="block">/* no match found, error */</comment>
		    }</block></else></if>

		    <expr_stmt><expr><name>cp</name> = <name>parsed</name></expr>;</expr_stmt>
		    <if>if <condition>(<expr>*<name>parsed</name> == ';'</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>*<name>parsed</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> = <name>parsed</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>code</name> = <call><name>xtermcapKeycode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>parsed</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>, <argument><expr>&amp;<name>fkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
		}</block></while>
		<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
	</case>}</block></switch>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><default>default:
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 200</expr>)</condition><then> <block>{	<comment type="block">/* VT220 */</comment>
	    <expr_stmt><expr><call><name>parse_ansi_params</name><argument_list>(<argument><expr>&amp;<name>params</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <switch>switch <condition>(<expr><name>params</name>.<name>a_final</name></expr>)</condition> <block>{
	    <case>case <expr>'|'</expr>:		<comment type="block">/* DECUDK */</comment>
		<if>if <condition>(<expr><name>params</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then>
		    <expr_stmt><expr><call><name>reset_decudk</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>parse_decudk</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr>'{'</expr>:		<comment type="block">/* DECDLD (no '}' case though) */</comment>
		<expr_stmt><expr><call><name>parse_decdld</name><argument_list>(<argument><expr>&amp;<name>params</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    </case>}</block></switch>
	}</block></then></if>
	<break>break;</break>
    </default>}</block></switch>
    <expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>char</name> *</type>
<name>udk_lookup</name><parameter_list>(<param><decl><type><name>int</name></type> <name>keycode</name></decl></param>, <param><decl><type><name>int</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>keycode</name> &gt;= 0 &amp;&amp; <name>keycode</name> &lt; <name>MAX_UDK</name></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>len</name> = <name><name>user_keys</name><index>[<expr><name>keycode</name></expr>]</index></name>.<name>len</name></expr>;</expr_stmt>
	<return>return <expr><name><name>user_keys</name><index>[<expr><name>keycode</name></expr>]</index></name>.<name>str</name></expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>ChangeGroup</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>attribute</name></decl></param>, <param><decl><type><name>char</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>static</name> <name>Char</name> *</type><name>converted</name></decl>;</decl_stmt>	<comment type="block">/* NO_LEAKS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>empty</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Arg</name></type> <name><name>args</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>changed</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Widget</name></type> <name>w</name> =<init> <expr><call><name>CURRENT_EMU</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Widget</name></type> <name>top</name> =<init> <expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> *</type><name>my_attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>c1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>cp</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>AllowTitleOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>

    <if>if <condition>(<expr><name>value</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><name>value</name> = <name>empty</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>IsTitleMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>tmSetBase16</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>test</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>value</name> = <call><name>x_decode_hex</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>*<name>temp</name> != '\0'</expr>)</condition><then>
	    <return>return;</return></then></if>
	<for>for (<init><expr><name>test</name> = <name>value</name></expr>;</init> <condition><expr>*<name>test</name> != '\0'</expr>;</condition> <incr><expr>++<name>test</name></expr></incr>) <block>{
	    <if>if <condition>(<expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>test</name></expr></argument>)</argument_list></call> &lt; 32</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>test</name> = '\0'</expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block></for>
    }</block></then></if>

    <expr_stmt><expr><name>c1</name> = (<name>Char</name> *) <name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>name</name> = <name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>my_attr</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ChangeGroup(attribute=%s, value=%s)\n", <name>my_attr</name>, <name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Ignore titles that are too long to be plausible requests.
     */</comment>
    <if>if <condition>(<expr><name>limit</name> &gt; 0 &amp;&amp; <name>limit</name> &lt; 1024</expr>)</condition><then> <block>{

	<comment type="block">/*
	 * After all decoding, overwrite nonprintable characters with '?'.
	 */</comment>
	<for>for (<init><expr><name>cp</name> = <name>c1</name></expr>;</init> <condition><expr>*<name>cp</name> != 0</expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>) <block>{
	    <decl_stmt><decl><type><name>Char</name> *</type><name>c2</name> =<init> <expr><name>cp</name></expr></init></decl>;</decl_stmt>
	    <if>if <condition>(<expr>!<call><name>xtermIsPrintable</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>, <argument><expr><name>c1</name> + <name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr>'?'</expr></argument>, <argument><expr><call>(<name>size_t</name>) <argument_list>(<argument><expr><name>cp</name> + 1 - <name>c2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<comment type="block">/*
	 * If we're running in UTF-8 mode, and have not been told that the
	 * title string is in UTF-8, it is likely that non-ASCII text in the
	 * string will be rejected because it is not printable in the current
	 * locale.  So we convert it to UTF-8, allowing the X library to
	 * convert it back.
	 */</comment>
	<if>if <condition>(<expr><call><name>xtermEnvUTF8</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>IsSetUtf8Title</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>name</name><index>[<expr><name>n</name></expr>]</index></name> != '\0'</expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>CharOf</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call> &gt; 127</expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><name>converted</name> != 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>converted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		    <if>if <condition>(<expr>(<name>converted</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>Char</name></expr></argument>, <argument><expr>1 + (6 * <name>limit</name>)</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>Char</name> *</type><name>temp</name> =<init> <expr><name>converted</name></expr></init></decl>;</decl_stmt>
			<while>while <condition>(<expr>*<name>name</name> != 0</expr>)</condition> <block>{
			    <expr_stmt><expr><name>temp</name> = <call><name>convertToUTF8</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr>++<name>name</name></expr>;</expr_stmt>
			}</block></while>
			<expr_stmt><expr>*<name>temp</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> = (<name>char</name> *) <name>converted</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...converted{%s}\n", <name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
		    <break>break;</break>
		}</block></then></if>
	    }</block></for>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAME_NAME</name></expr></cpp:if>
	<comment type="block">/* If the attribute isn't going to change, then don't bother... */</comment>

	<if>if <condition>(<expr><name>resource</name>.<name>sameName</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>XtSetArg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>my_attr</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XtGetValues</name><argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...comparing{%s}\n", <name>buf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>buf</name> != 0 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>changed</name> = <name>False</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SAME_NAME */</comment>

	<if>if <condition>(<expr><name>changed</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...updating %s\n", <name>my_attr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...value is %s\n", <name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XtSetArg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>my_attr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XtSetValues</name><argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <if>if <condition>(<expr><call><name>xtermEnvUTF8</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Atom</name></type> <name>my_atom</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>propname</name> =<init> <expr>(!<call><name>strcmp</name><argument_list>(<argument><expr><name>my_attr</name></expr></argument>, <argument><expr><name>XtNtitle</name></expr></argument>)</argument_list></call>
					? "_NET_WM_NAME"
					: "_NET_WM_ICON_NAME")</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>(<name>my_atom</name> = <call><name>XInternAtom</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call>) != <name>None</name></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><call><name>IsSetUtf8Title</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...updating %s\n", <name>propname</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...value is %s\n", <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XChangeProperty</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr><name>my_atom</name></expr></argument>,
					<argument><expr><call><name>XA_UTF8_STRING</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>8</expr></argument>,
					<argument><expr><name>PropModeReplace</name></expr></argument>,
					<argument><expr>(<name>Char</name> *) <name>value</name></expr></argument>,
					<argument><expr>(<name>int</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...deleting %s\n", <name>propname</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XDeleteProperty</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr><name>my_atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></else></if>
		}</block></then></if>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>my_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>IsTitleMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>tmSetBase16</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    }</block></then></if>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>ChangeIconName</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>name</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>dummy</name><index>[]</index></name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>name</name> = <name>dummy</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ZICONBEEP</name></expr></cpp:if>		<comment type="block">/* If warning should be given then give it */</comment>
    <if>if <condition>(<expr><name>resource</name>.<name>zIconBeep</name> &amp;&amp; <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>zIconBeep_flagged</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>newname</name> =<init> <expr><call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> + 4</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>newname</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"malloc failed in ChangeIconName\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newname</name></expr></argument>, <argument><expr>"*** "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>newname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ChangeGroup</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XtNiconName</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_ZICONBEEP */</comment>
	<expr_stmt><expr><call><name>ChangeGroup</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XtNiconName</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>ChangeTitle</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ChangeGroup</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XtNtitle</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>Strlen</name>(s) strlen((char *)(s))</cpp:define>

<function><type><name>void</name></type>
<name>ChangeXprop</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>toplevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Window</name></type> <name>w</name> =<init> <expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>toplevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XTextProperty</name></type> <name>text_prop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name></type> <name>aprop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>pchEndPropName</name> =<init> <expr>(<name>Char</name> *) <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>pchEndPropName</name></expr>)</condition><then>
	<expr_stmt><expr>*<name>pchEndPropName</name> = '\0'</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>aprop</name> = <call><name>XInternAtom</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pchEndPropName</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<comment type="block">/* no "=value" given, so delete the property */</comment>
	<expr_stmt><expr><call><name>XDeleteProperty</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>aprop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>text_prop</name>.<name>value</name> = <name>pchEndPropName</name> + 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>text_prop</name>.<name>encoding</name> = <name>XA_STRING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>text_prop</name>.<name>format</name> = 8</expr>;</expr_stmt>
	<expr_stmt><expr><name>text_prop</name>.<name>nitems</name> = <call><name>Strlen</name><argument_list>(<argument><expr><name>text_prop</name>.<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XSetTextProperty</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>text_prop</name></expr></argument>, <argument><expr><name>aprop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/***====================================================================***/</comment>

<comment type="block">/*
 * This is part of ReverseVideo().  It reverses the data stored for the old
 * "dynamic" colors that might have been retrieved using OSC 10-18.
 */</comment>
<function><type><name>void</name></type>
<name>ReverseOldColors</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ScrnColors</name> *</type><name>pOld</name> =<init> <expr><name>pOldColors</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>tmpPix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>tmpName</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>pOld</name></expr>)</condition><then> <block>{
	<comment type="block">/* change text cursor, if necesary */</comment>
	<if>if <condition>(<expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEXT_CURSOR</name></expr>]</index></name> == <name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEXT_FG</name></expr>]</index></name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEXT_CURSOR</name></expr>]</index></name> = <name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEXT_BG</name></expr>]</index></name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_CURSOR</name></expr>]</index></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr><name>pOldColors</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_CURSOR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_CURSOR</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_BG</name></expr>]</index></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>tmpName</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_BG</name></expr>]</index></name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_CURSOR</name></expr>]</index></name> = <name>tmpName</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEXT_FG</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEXT_BG</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmpPix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_FG</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEXT_BG</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmpName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>MOUSE_FG</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>MOUSE_BG</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmpPix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>MOUSE_FG</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>MOUSE_BG</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmpName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEK_FG</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOld</name>-&gt;<name><name>colors</name><index>[<expr><name>TEK_BG</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmpPix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEK_FG</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOld</name>-&gt;<name><name>names</name><index>[<expr><name>TEK_BG</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmpName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return;</return>
}</block></function>

<function><type><name>Bool</name></type>
<name>AllocateTermColor</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		  <param><decl><type><name>ScrnColors</name> *</type> <name>pNew</name></decl></param>,
		  <param><decl><type><name>int</name></type> <name>ndx</name></decl></param>,
		  <param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>,
		  <param><decl><type><name>Bool</name></type> <name>always</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>always</name> || <call><name>AllowColorOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ecSetColor</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XColor</name></type> <name>def</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Colormap</name></type> <name>cmap</name> =<init> <expr><name>xw</name>-&gt;<name>core</name>.<name>colormap</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>newName</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>XParseColor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>def</name></expr></argument>)</argument_list></call>
	    &amp;&amp; (<call><name>XAllocColor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr>&amp;<name>def</name></expr></argument>)</argument_list></call>
		|| <call><name>find_closest_color</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>cmap</name></expr></argument>, <argument><expr>&amp;<name>def</name></expr></argument>)</argument_list></call>)
	    &amp;&amp; (<name>newName</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name><name>names</name><index>[<expr><name>ndx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>SET_COLOR_VALUE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><name>def</name>.<name>pixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>SET_COLOR_NAME</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("AllocateTermColor #%d: %s (pixel %#lx)\n", <name>ndx</name>, <name>newName</name>, <name>def</name>.<name>pixel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("AllocateTermColor #%d: %s (failed)\n", <name>ndx</name>, <name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<comment type="block">/***====================================================================***/</comment>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>Panic</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *<name>s</name></type> <name>GCC_UNUSED</name></decl></param>, <param><decl><type><name>int</name> <name>a</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: PANIC!\t"</expr></argument>, <argument><expr><name>xterm_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"\r\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>
}</block></function>

<function><type><name>const</name> <name>char</name> *</type>
<name>SysErrorMsg</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>unknown</name><index>[]</index></name> =<init> <expr>"unknown error"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>s</name> =<init> <expr><call><name>strerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>s</name> ? <name>s</name> : <name>unknown</name></expr>;</return>
}</block></function>

<function><type><name>const</name> <name>char</name> *</type>
<name>SysReasonMsg</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* *INDENT-OFF* */</comment>
    <decl_stmt><decl><type><name>static</name> <name>const</name></type> <type>struct</type> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>table</name><index>[]</index></name> = <block>{
	<expr><block>{ <expr><name>ERROR_FIONBIO</name></expr>,	<expr>"main:  ioctl() failed on FIONBIO"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_F_GETFL</name></expr>,	<expr>"main: ioctl() failed on F_GETFL"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_F_SETFL</name></expr>,	<expr>"main: ioctl() failed on F_SETFL"</expr>, }</block></expr>,
	<expr><block>{ <expr><name>ERROR_OPDEVTTY</name></expr>,	<expr>"spawn: open() failed on /dev/tty"</expr>, }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCGETP</name></expr>,	<expr>"spawn: ioctl() failed on TIOCGETP"</expr>, }</block></expr>,
	<expr><block>{ <expr><name>ERROR_PTSNAME</name></expr>,	<expr>"spawn: ptsname() failed"</expr>, }</block></expr>,
	<expr><block>{ <expr><name>ERROR_OPPTSNAME</name></expr>,	<expr>"spawn: open() failed on ptsname"</expr>, }</block></expr>,
	<expr><block>{ <expr><name>ERROR_PTEM</name></expr>,		<expr>"spawn: ioctl() failed on I_PUSH/\"ptem\""</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_CONSEM</name></expr>,		<expr>"spawn: ioctl() failed on I_PUSH/\"consem\""</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_LDTERM</name></expr>,		<expr>"spawn: ioctl() failed on I_PUSH/\"ldterm\""</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TTCOMPAT</name></expr>,	<expr>"spawn: ioctl() failed on I_PUSH/\"ttcompat\""</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCSETP</name></expr>,	<expr>"spawn: ioctl() failed on TIOCSETP"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCSETC</name></expr>,	<expr>"spawn: ioctl() failed on TIOCSETC"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCSETD</name></expr>,	<expr>"spawn: ioctl() failed on TIOCSETD"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCSLTC</name></expr>,	<expr>"spawn: ioctl() failed on TIOCSLTC"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCLSET</name></expr>,	<expr>"spawn: ioctl() failed on TIOCLSET"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_INIGROUPS</name></expr>,	<expr>"spawn: initgroups() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_FORK</name></expr>,		<expr>"spawn: fork() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_EXEC</name></expr>,		<expr>"spawn: exec() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_PTYS</name></expr>,		<expr>"get_pty: not enough ptys"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_PTY_EXEC</name></expr>,	<expr>"waiting for initial map"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_SETUID</name></expr>,		<expr>"spawn: setuid() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_INIT</name></expr>,		<expr>"spawn: can't initialize window"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCKSET</name></expr>,	<expr>"spawn: ioctl() failed on TIOCKSET"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TIOCKSETC</name></expr>,	<expr>"spawn: ioctl() failed on TIOCKSETC"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_LUMALLOC</name></expr>,	<expr>"luit: command-line malloc failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_SELECT</name></expr>,		<expr>"in_put: select() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_VINIT</name></expr>,		<expr>"VTInit: can't initialize window"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_KMMALLOC1</name></expr>,	<expr>"HandleKeymapChange: malloc failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TSELECT</name></expr>,	<expr>"Tinput: select() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_TINIT</name></expr>,		<expr>"TekInit: can't initialize window"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_BMALLOC2</name></expr>,	<expr>"SaltTextAway: malloc() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_LOGEXEC</name></expr>,	<expr>"StartLog: exec() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_XERROR</name></expr>,		<expr>"xerror: XError event"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_XIOERROR</name></expr>,	<expr>"xioerror: X I/O error"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_SCALLOC</name></expr>,	<expr>"Alloc: calloc() failed on base"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_SCALLOC2</name></expr>,	<expr>"Alloc: calloc() failed on rows"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_SAVE_PTR</name></expr>,	<expr>"ScrnPointers: malloc/realloc() failed"</expr> }</block></expr>,
	<expr><block>{ <expr><name>ERROR_MMALLOC</name></expr>,	<expr>"my_memmove: malloc/realloc failed"</expr> }</block></expr>,
    }</block></expr>;</expr_stmt>
    <comment type="block">/* *INDENT-ON* */</comment>

    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>result</name> =<init> <expr>"?"</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<if>if <condition>(<expr><name>code</name> == <name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>code</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
    }</block></for>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>SysError</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>oerrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: Error %d, errno %d: "</expr></argument>, <argument><expr><name>xterm_name</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>oerrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><call><name>SysErrorMsg</name><argument_list>(<argument><expr><name>oerrno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Reason: %s\n"</expr></argument>, <argument><expr><call><name>SysReasonMsg</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Cleanup</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * cleanup by sending SIGHUP to client processes
 */</comment>
<function><type><name>void</name></type>
<name>Cleanup</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>Bool</name></type> <name>cleaning</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Process "-hold" and session cleanup only for a normal exit.
     */</comment>
    <if>if <condition>(<expr><name>code</name> == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>cleaning</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>hold_screen</name> = 0</expr>;</expr_stmt>
	    <return>return;</return>
	}</block></then></if>

	<expr_stmt><expr><name>cleaning</name> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>need_cleanup</name> = <name>False</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Cleanup %d\n", <name>code</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>hold_screen</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>hold_screen</name> = 2</expr>;</expr_stmt>
	    <while>while <condition>(<expr><name>hold_screen</name></expr>)</condition> <block>{
		<expr_stmt><expr><call><name>xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></while>
	}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SESSION_MGT</name></expr></cpp:if>
	<if>if <condition>(<expr><name>resource</name>.<name>sessionMgt</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XtVaSetValues</name><argument_list>(<argument><expr><name>toplevel</name></expr></argument>,
			  <argument><expr><name>XtNjoinSession</name></expr></argument>, <argument><expr><name>False</name></expr></argument>,
			  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>pid</name> &gt; 1</expr>)</condition><then> <block>{
	<expr_stmt><expr>(<name>void</name>) <call><name>kill_process_group</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>pid</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>Exit</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>VMS</name></cpp:ifndef>
<function><type><name>char</name> *</type>
<name>xtermFindShell</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>leaf</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>warning</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name> =<init> <expr><name>leaf</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermFindShell(%s)\n", <name>leaf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>result</name> != '\0' &amp;&amp; <call><name>strchr</name><argument_list>(<argument><expr>"+/-"</expr></argument>, <argument><expr>*<name>result</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<comment type="block">/* find it in $PATH */</comment>
	<if>if <condition>(<expr>(<name>s</name> = <call><name>x_getenv</name><argument_list>(<argument><expr>"PATH"</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>(<name>tmp</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Bool</name></type> <name>found</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr>*<name>s</name> != '\0'</expr>)</condition> <block>{
		    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <for>for (<init><expr><name>d</name> = <name>tmp</name></expr>;</init><condition>;</condition> <incr><expr>++<name>d</name></expr></incr>) <block>{
			<if>if <condition>(<expr>*<name>d</name> == ':' || *<name>d</name> == '\0'</expr>)</condition><then> <block>{
			    <decl_stmt><decl><type><name>int</name></type> <name>skip</name> =<init> <expr>(*<name>d</name> != '\0')</expr></init></decl>;</decl_stmt>
			    <expr_stmt><expr>*<name>d</name> = '/'</expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>d</name> + 1</expr></argument>, <argument><expr><name>leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <if>if <condition>(<expr><name>skip</name></expr>)</condition><then>
				<expr_stmt><expr>++<name>d</name></expr>;</expr_stmt></then></if>
			    <expr_stmt><expr><name>s</name> += (<name>d</name> - <name>tmp</name>)</expr>;</expr_stmt>
			    <if>if <condition>(<expr>*<name>tmp</name> == '/'
				&amp;&amp; <call><name>strstr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call> == 0
				&amp;&amp; <call><name>access</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>result</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> = <name>True</name></expr>;</expr_stmt>
			    }</block></then></if>
			    <break>break;</break>
			}</block></then></if>
			<if>if <condition>(<expr><name>found</name></expr>)</condition><then>
			    <break>break;</break></then></if>
		    }</block></for>
		    <if>if <condition>(<expr><name>found</name></expr>)</condition><then>
			<break>break;</break></then></if>
		}</block></while>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...xtermFindShell(%s)\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>result</name> != '/'
	|| <call><name>strstr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call> != 0
	|| <call><name>access</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>warning</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"No absolute path found for shell: %s\n"</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>ENV_HUNK</name>(n)	(unsigned) ((((n) + 1) | 31) + 1)</cpp:define>

<comment type="block">/*
 * copy the environment before Setenv'ing.
 */</comment>
<function><type><name>void</name></type>
<name>xtermCopyEnv</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>oldenv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>newenv</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>size</name> = 0</expr>;</init> <condition><expr><name><name>oldenv</name><index>[<expr><name>size</name></expr>]</index></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>size</name>++</expr></incr>) <block>{
	<empty_stmt>;</empty_stmt>
    }</block></for>

    <expr_stmt><expr><name>newenv</name> = <call><name>TypeCallocN</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><call><name>ENV_HUNK</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>newenv</name></expr></argument>, <argument><expr><name>oldenv</name></expr></argument>, <argument><expr><name>size</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>environ</name> = <name>newenv</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * sets the value of var to be arg in the Unix 4.2 BSD environment env.
 * Var should end with '=' (bindings are of the form "var=value").
 * This procedure assumes the memory for the first level of environ
 * was allocated using calloc, with enough extra room at the end so not
 * to have to do a realloc().
 */</comment>
<function><type><name>void</name></type>
<name>xtermSetenv</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>var</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>value</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>test</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>envindex</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>found</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermSetenv(%s=%s)\n", <name>var</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr>(<name>test</name> = <name><name>environ</name><index>[<expr><name>envindex</name></expr>]</index></name>) != <name>NULL</name></expr>)</condition> <block>{
	    <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> == 0 &amp;&amp; <name><name>test</name><index>[<expr><name>len</name></expr>]</index></name> == '='</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>found</name> = <name>envindex</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	    <expr_stmt><expr><name>envindex</name>++</expr>;</expr_stmt>
	}</block></while>

	<if>if <condition>(<expr><name>found</name> &lt; 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>need</name> =<init> <expr><call><name>ENV_HUNK</name><argument_list>(<argument><expr><name>envindex</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>have</name> =<init> <expr><call><name>ENV_HUNK</name><argument_list>(<argument><expr><name>envindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>need</name> &gt; <name>have</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> **</type><name>newenv</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>newenv</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>newenv</name> == 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Cannot increase environment\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>newenv</name></expr></argument>, <argument><expr><name>environ</name></expr></argument>, <argument><expr><name>have</name> * <call><name>sizeof</name><argument_list>(<argument><expr>*<name>newenv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>environ</name> = <name>newenv</name></expr>;</expr_stmt>
	    }</block></then></if>

	    <expr_stmt><expr><name>found</name> = <name>envindex</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>environ</name><index>[<expr><name>found</name> + 1</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>environ</name> = <name>environ</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name><name>environ</name><index>[<expr><name>found</name></expr>]</index></name> = <call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr>1 + <name>len</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>environ</name><index>[<expr><name>found</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Cannot allocate environment %s\n"</expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>found</name></expr>]</index></name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>int</name></type>
<name>xerror</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>d</name></decl></param>, <param><decl><type><name>XErrorEvent</name> *</type> <name>ev</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s:  warning, error event received:\n"</expr></argument>, <argument><expr><name>xterm_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <call><name>XmuPrintDefaultErrorMessage</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Exit</name><argument_list>(<argument><expr><name>ERROR_XERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>			<comment type="block">/* appease the compiler */</comment>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>int</name></type>
<name>xioerror</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>dpy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>the_error</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>) <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
		   <argument><expr>"%s:  fatal IO error %d (%s) or KillClient on X server \"%s\"\r\n"</expr></argument>,
		   <argument><expr><name>xterm_name</name></expr></argument>, <argument><expr><name>the_error</name></expr></argument>, <argument><expr><call><name>SysErrorMsg</name><argument_list>(<argument><expr><name>the_error</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>DisplayString</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Exit</name><argument_list>(<argument><expr><name>ERROR_XIOERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>			<comment type="block">/* appease the compiler */</comment>
}</block></function>

<function><type><name>void</name></type>
<name>xt_error</name><parameter_list>(<param><decl><type><name>String</name></type> <name>message</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>(<name>void</name>) <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s Xt error: %s\n"</expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for the obvious - Xt does a poor job of reporting this.
     */</comment>
    <if>if <condition>(<expr><call><name>x_getenv</name><argument_list>(<argument><expr>"DISPLAY"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s:  DISPLAY is not set\n"</expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type>
<name>XStrCmp</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s1</name></decl></param>, <param><decl><type><name>char</name> *</type><name>s2</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>s1</name> &amp;&amp; <name>s2</name></expr>)</condition><then>
	<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if>
    <if>if <condition>(<expr><name>s1</name> &amp;&amp; *<name>s1</name></expr>)</condition><then>
	<return>return <expr>(1)</expr>;</return></then></if>
    <if>if <condition>(<expr><name>s2</name> &amp;&amp; *<name>s2</name></expr>)</condition><then>
	<return>return <expr>(-1)</expr>;</return></then></if>
    <return>return <expr>(0)</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>withdraw_window</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>dpy</name></decl></param>, <param><decl><type><name>Window</name></type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>scr</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("withdraw_window %#lx\n", (<name>long</name>) <name>w</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <call><name>XmuUpdateMapHints</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XWithdrawWindow</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>scr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>set_vt_visibility</name><parameter_list>(<param><decl><type><name>Bool</name></type> <name>on</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_vt_visibility(%d)\n", <name>on</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>on</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>Vshow</name> &amp;&amp; <name>term</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>VTInit</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XtMapWidget</name><argument_list>(<argument><expr><call><name>XtParent</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
	    <comment type="block">/* we need both of these during initialization */</comment>
	    <expr_stmt><expr><call><name>XtMapWidget</name><argument_list>(<argument><expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ShowToolbar</name><argument_list>(<argument><expr><name>resource</name>.<name>toolBar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>Vshow</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <else>else <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>Vshow</name> &amp;&amp; <name>term</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>withdraw_window</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name>VShellWindow</name></expr></argument>,
			    <argument><expr><call><name>XScreenNumberOfScreen</name><argument_list>(<argument><expr><call><name>XtScreen</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>Vshow</name> = <name>False</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>set_vthide_sensitivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_tekhide_sensitivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_vttekmode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_tekshow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_vtshow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>set_tek_visibility</name><parameter_list>(<param><decl><type><name>Bool</name></type> <name>on</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_tek_visibility(%d)\n", <name>on</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>on</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>!<call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>tekWidget</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TekInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* will exit on failure */</comment>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>tekWidget</name> != 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Widget</name></type> <name>tekParent</name> =<init> <expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>XtRealizeWidget</name><argument_list>(<argument><expr><name>tekParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XtMapWidget</name><argument_list>(<argument><expr><call><name>XtParent</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
		<comment type="block">/* we need both of these during initialization */</comment>
		<expr_stmt><expr><call><name>XtMapWidget</name><argument_list>(<argument><expr><name>tekParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XtMapWidget</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>XtOverrideTranslations</name><argument_list>(<argument><expr><name>tekParent</name></expr></argument>,
				       <argument><expr><call><name>XtParseTranslationTable</name>
				       <argument_list>(<argument><expr>"&lt;Message&gt;WM_PROTOCOLS: DeleteWindow()"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>) <call><name>XSetWMProtocols</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>tekParent</name></expr></argument>)</argument_list></call></expr></argument>,
				       <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>tekParent</name></expr></argument>)</argument_list></call></expr></argument>,
				       <argument><expr>&amp;<name>wm_delete_window</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call> = <name>True</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call> &amp;&amp; <name>tekWidget</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>withdraw_window</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name>TShellWindow</name></expr></argument>,
			    <argument><expr><call><name>XScreenNumberOfScreen</name><argument_list>(<argument><expr><call><name>XtScreen</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call> = <name>False</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>set_tekhide_sensitivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_vthide_sensitivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_vtshow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_tekshow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_vttekmode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>end_tek_mode</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>FlushLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>Tekend</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>end_vt_mode</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>FlushLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>VTend</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>switch_modes</name><parameter_list>(<param><decl><type><name>Bool</name></type> <name>tovt</name></decl></param>)</parameter_list>		<comment type="block">/* if true, then become vt mode */</comment>
<block>{
    <if>if <condition>(<expr><name>tovt</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>tekRefreshList</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>TekRefresh</name><argument_list>(<argument><expr><name>tekWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>end_tek_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* WARNING: this does a longjmp... */</comment>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>end_vt_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* WARNING: this does a longjmp... */</comment>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>hide_vt_window</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>set_vt_visibility</name><argument_list>(<argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>switch_modes</name><argument_list>(<argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="block">/* switch to tek mode */</comment>
}</block></function>

<function><type><name>void</name></type>
<name>hide_tek_window</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>set_tek_visibility</name><argument_list>(<argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tekRefreshList</name> = (<name>TekLink</name> *) 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>switch_modes</name><argument_list>(<argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="block">/* does longjmp to vt mode */</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_TEK4014 */</comment>

<function><type><name>static</name> <name>const</name> <name>char</name> *</type>
<name>skip_punct</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr>*<name>s</name> == '-' || *<name>s</name> == '/' || *<name>s</name> == '+' || *<name>s</name> == '#' || *<name>s</name> == '%'</expr>)</condition> <block>{
	<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>s</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>cmp_options</name><parameter_list>(<param><decl><type><name>const</name> <name>void</name> *</type><name>a</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>s1</name> =<init> <macro><name>skip_punct</name><argument_list>(<argument>((const OptionHelp *) a)-&gt;opt</argument>)</argument_list></macro></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>s2</name> =<init> <macro><name>skip_punct</name><argument_list>(<argument>((const OptionHelp *) b)-&gt;opt</argument>)</argument_list></macro></init></decl>;</decl_stmt>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>cmp_resources</name><parameter_list>(<param><decl><type><name>const</name> <name>void</name> *</type><name>a</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <return>return <macro><name>strcmp</name><argument_list>(<argument>((const XrmOptionDescRec *) a)-&gt;option</argument>,
		  <argument>((const XrmOptionDescRec *) b)-&gt;option</argument>)</argument_list></macro>;</return>
}</block></function>

<function><type><name>XrmOptionDescRec</name> *</type>
<name>sortedOptDescs</name><parameter_list>(<param><decl><type><name>XrmOptionDescRec</name> *</type> <name>descs</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>res_count</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>XrmOptionDescRec</name> *</type><name>res_array</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_LEAKS</name></cpp:ifdef>
    <if>if <condition>(<expr><name>descs</name> == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>res_array</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>res_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>res_array</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>res_array</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Cardinal</name></type> <name>j</name></decl>;</decl_stmt>

	<comment type="block">/* make a sorted index to 'resources' */</comment>
	<expr_stmt><expr><name>res_array</name> = <call><name>TypeCallocN</name><argument_list>(<argument><expr><name>XrmOptionDescRec</name></expr></argument>, <argument><expr><name>res_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res_array</name> != 0</expr>)</condition><then> <block>{
	    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>res_count</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
		<expr_stmt><expr><name><name>res_array</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>descs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>
	    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>res_array</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>res_count</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>res_array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmp_resources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if></else></if>
    <return>return <expr><name>res_array</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * The first time this is called, construct sorted index to the main program's
 * list of options, taking into account the on/off options which will be
 * compressed into one token.  It's a lot simpler to do it this way than
 * maintain the list in sorted form with lots of ifdef's.
 */</comment>
<function><type><name>OptionHelp</name> *</type>
<name>sortedOpts</name><parameter_list>(<param><decl><type><name>OptionHelp</name> *</type> <name>options</name></decl></param>, <param><decl><type><name>XrmOptionDescRec</name> *</type> <name>descs</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>numDescs</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>OptionHelp</name> *</type><name>opt_array</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_LEAKS</name></cpp:ifdef>
    <if>if <condition>(<expr><name>descs</name> == 0 &amp;&amp; <name>opt_array</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>sortedOptDescs</name><argument_list>(<argument><expr><name>descs</name></expr></argument>, <argument><expr><name>numDescs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opt_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opt_array</name> = 0</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    }</block></then> <else>else <if>if <condition>(<expr><name>options</name> == 0 || <name>descs</name> == 0</expr>)</condition><then> <block>{
	<return>return <expr>0</expr>;</return>
    }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>opt_array</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>opt_count</name>, <name>j</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>Cardinal</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XrmOptionDescRec</name> *</type><name>res_array</name> =<init> <expr><call><name>sortedOptDescs</name><argument_list>(<argument><expr><name>descs</name></expr></argument>, <argument><expr><name>numDescs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>mesg</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr>(<name>void</name>) <name>descs</name></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>) <name>numDescs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* count 'options' and make a sorted index to it */</comment>
	<for>for (<init><expr><name>opt_count</name> = 0</expr>;</init> <condition><expr><name><name>options</name><index>[<expr><name>opt_count</name></expr>]</index></name>.<name>opt</name> != 0</expr>;</condition> <incr><expr>++<name>opt_count</name></expr></incr>) <block>{
	    <empty_stmt>;</empty_stmt>
	}</block></for>
	<expr_stmt><expr><name>opt_array</name> = <call><name>TypeCallocN</name><argument_list>(<argument><expr><name>OptionHelp</name></expr></argument>, <argument><expr><name>opt_count</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>opt_count</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
	    <expr_stmt><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>options</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>opt_array</name></expr></argument>, <argument><expr><name>opt_count</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>OptionHelp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmp_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* supply the "turn on/off" strings if needed */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>opt_count</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
	    <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>opt</name></expr></argument>, <argument><expr>"-/+"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name> =<init> <expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>opt</name> + 3</expr></init></decl>;</decl_stmt>
		<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <name>numDescs</name></expr>;</condition> <incr><expr>++<name>k</name></expr></incr>) <block>{
		    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>value</name> =<init> <expr><name><name>res_array</name><index>[<expr><name>k</name></expr>]</index></name>.<name>value</name></expr></init></decl>;</decl_stmt>
		    <if>if <condition>(<expr><name><name>res_array</name><index>[<expr><name>k</name></expr>]</index></name>.<name><name>option</name><index>[<expr>0</expr>]</index></name> == '-'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>code</name> = -1</expr>;</expr_stmt>
		    }</block></then> <else>else <if>if <condition>(<expr><name><name>res_array</name><index>[<expr><name>k</name></expr>]</index></name>.<name><name>option</name><index>[<expr>0</expr>]</index></name> == '+'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>code</name> = 1</expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><name>code</name> = 0</expr>;</expr_stmt>
		    }</block></else></if></else></if>
		    <if>if <condition>(<expr><call><name>x_strindex</name><argument_list>(<argument><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name></expr></argument>, <argument><expr>"inhibit"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<expr_stmt><expr><name>code</name> = -<name>code</name></expr>;</expr_stmt></then></if>
		    <if>if <condition>(<expr><name>code</name> != 0
			&amp;&amp; <name><name>res_array</name><index>[<expr><name>k</name></expr>]</index></name>.<name>value</name> != 0
			&amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>res_array</name><index>[<expr><name>k</name></expr>]</index></name>.<name>option</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>((<name>code</name> &lt; 0) &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"on"</expr></argument>)</argument_list></call>)
			    || ((<name>code</name> &gt; 0) &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"off"</expr></argument>)</argument_list></call>)
			    || ((<name>code</name> &gt; 0) &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
			    <expr_stmt><expr><name>mesg</name> = "turn on/off"</expr>;</expr_stmt>
			}</block></then> <else>else <block>{
			    <expr_stmt><expr><name>mesg</name> = "turn off/on"</expr>;</expr_stmt>
			}</block></else></if>
			<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name></expr></argument>, <argument><expr>"turn "</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type><name>s</name> =<init> <expr><call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>,
						      <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call>
						      + 1
						      + <call><name>strlen</name><argument_list>(<argument><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>s</name> != 0</expr>)</condition><then> <block>{
				    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%s %s"</expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				    <expr_stmt><expr><name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name> = <name>s</name></expr>;</expr_stmt>
				}</block></then></if>
			    }</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("OOPS ")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    }</block></else></if>
			}</block></then></if>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s: %s %s: %s (%s)\n",
			       <name>mesg</name>,
			       <name><name>res_array</name><index>[<expr><name>k</name></expr>]</index></name>.<name>option</name>,
			       <name><name>res_array</name><index>[<expr><name>k</name></expr>]</index></name>.<name>value</name>,
			       <name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>opt</name>,
			       <name><name>opt_array</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		    }</block></then></if>
		}</block></for>
	    }</block></then></if>
	}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return <expr><name>opt_array</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Report the character-type locale that xterm was started in.
 */</comment>
<function><type><name>char</name> *</type>
<name>xtermEnvLocale</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>result</name> = <call><name>x_nonempty</name><argument_list>(<argument><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <call><name>x_strdup</name><argument_list>(<argument><expr>"C"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>result</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermEnvLocale -&gt;%s\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>xtermEnvEncoding</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LANGINFO_CODESET</name></cpp:ifdef>
	<expr_stmt><expr><name>result</name> = <call><name>nl_langinfo</name><argument_list>(<argument><expr><name>CODESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name> *</type><name>locale</name> =<init> <expr><call><name>xtermEnvLocale</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>locale</name></expr></argument>, <argument><expr>"C"</expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name>locale</name></expr></argument>, <argument><expr>"POSIX"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = "ASCII"</expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>result</name> = "ISO-8859-1"</expr>;</expr_stmt>
	}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermEnvEncoding -&gt;%s\n", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
 * Tell whether xterm was started in a locale that uses UTF-8 encoding for
 * characters.  That environment is inherited by subprocesses and used in
 * various library calls.
 */</comment>
<function><type><name>Bool</name></type>
<name>xtermEnvUTF8</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>Bool</name></type> <name>init</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>init</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>init</name> = <name>True</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LANGINFO_CODESET</name></cpp:ifdef>
	<expr_stmt><expr><name>result</name> = (<call><name>strcmp</name><argument_list>(<argument><expr><call><name>xtermEnvEncoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"UTF-8"</expr></argument>)</argument_list></call> == 0)</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>result</name> = (<call><name>strstr</name><argument_list>(<argument><expr><call><name>xtermEnvLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"UTF-8"</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermEnvUTF8 -&gt;%s\n", <call><name>BtoS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_WIDE_CHARS */</comment>

<comment type="block">/*
 * Returns the version-string used in the "-v' message as well as a few other
 * places.  It is derived (when possible) from the __vendorversion__ symbol
 * that some newer imake configurations define.
 */</comment>
<function><type><name>char</name> *</type>
<name>xtermVersion</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>vendor_version</name><index>[]</index></name> =<init> <expr><name>__vendorversion__</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>vendor</name> =<init> <expr><name>vendor_version</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>first</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>second</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> = <call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>vendor</name></expr></argument>)</argument_list></call> + 9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then>
	    <expr_stmt><expr><name>result</name> = <name>vendor</name></expr>;</expr_stmt></then>
	<else>else <block>{
	    <comment type="block">/* some vendors leave trash in this string */</comment>
	    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>vendor</name></expr></argument>, <argument><expr>"Version "</expr></argument>, <argument><expr>(<name>size_t</name>) 8</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>vendor</name> += 8</expr>;</expr_stmt></then>
		<else>else <if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>vendor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr>++<name>vendor</name></expr>;</expr_stmt></then>
		<else>else
		    <break>break;</break></else></if></else></if>
	    }</block></for>
	    <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>vendor</name></expr></argument>)</argument_list></call> &lt; <name>BUFSIZ</name> &amp;&amp;
		<call><name>sscanf</name><argument_list>(<argument><expr><name>vendor</name></expr></argument>, <argument><expr>"%[0-9.] %[A-Za-z_0-9.]"</expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>second</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>"%s %s(%d)"</expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>XTERM_PATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>"%s(%d)"</expr></argument>, <argument><expr><name>vendor</name></expr></argument>, <argument><expr><name>XTERM_PATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></else></if>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Check if the current widget, or any parent, is the VT100 "xterm" widget.
 */</comment>
<function><type><name>XtermWidget</name></type>
<name>getXtermWidget</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>w</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xw</name> = (<name>XtermWidget</name>) <call><name>CURRENT_EMU</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>IsXtermWidget</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>xw</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>IsXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xw</name> = (<name>XtermWidget</name>) <name>w</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><call><name>XtParent</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("getXtermWidget %p -&gt; %p\n", <name>w</name>, <name>xw</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>xw</name></expr>;</return>
}</block></function>
</unit>
