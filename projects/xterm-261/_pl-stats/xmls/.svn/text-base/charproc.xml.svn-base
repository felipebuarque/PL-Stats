<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" dir="" filename="charproc.c"><comment type="block">/* $XTermId: charproc.c,v 1.1071 2010/06/28 09:03:42 tom Exp $ */</comment>

<comment type="block">/*

Copyright 1999-2009,2010 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

Copyright 1988  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/</comment>
<comment type="block">/*
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */</comment>

<comment type="block">/* charproc.c */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;version.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xatom.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xutil.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/cursorfont.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/Atoms.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/CharSet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xmu/Converters.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIB_XAW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xaw/XawImP.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIB_XAW3D</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xaw3d/XawImP.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIB_NEXTAW</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/neXtaw/XawImP.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIB_XAWPLUS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/XawPlus/XawImP.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wcwidth.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;precompose.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LANGINFO_CODESET</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;langinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Xlocale.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SCHED_YIELD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sched.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;VTparse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;data.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;error.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;menu.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;main.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fontutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xcharmouse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;charclass.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xstrings.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
}</block></struct></type> <name>FlagList</name>;</typedef>

<typedef>typedef <function_decl><type><name>void</name></type> (*<name>BitFunc</name>) <parameter_list>(<param><decl><type><name>unsigned</name> *</type></decl></param> <comment type="block">/* p */</comment> ,
			 <param><decl><type><name>unsigned</name></type></decl></param> <comment type="block">/* mask */</comment> )</parameter_list>;</function_decl></typedef>

<function_decl><type><name>static</name> <name>IChar</name></type> <name>doinput</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>int</name></type> <name>set_character_class</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param> <comment type="block">/*s */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>FromAlternate</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>RequestResize</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
			  <param><decl><type><name>int</name></type></decl></param> <comment type="block">/* rows */</comment> ,
			  <param><decl><type><name>int</name></type></decl></param> <comment type="block">/* cols */</comment> ,
			  <param><decl><type><name>Bool</name></type></decl></param> <comment type="block">/* text */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>SwitchBufs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
		       <param><decl><type><name>int</name></type></decl></param> <comment type="block">/* toBuf */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>ToAlternate</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>ansi_modes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>termw</name></decl></param>,
		       <param><decl><type><name>BitFunc</name></type></decl></param> <comment type="block">/* func */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>bitclr</name><parameter_list>(<param><decl><type><name>unsigned</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>mask</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>bitcpy</name><parameter_list>(<param><decl><type><name>unsigned</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>q</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>mask</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>bitset</name><parameter_list>(<param><decl><type><name>unsigned</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>mask</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>dpmodes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
		    <param><decl><type><name>BitFunc</name></type></decl></param> <comment type="block">/* func */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>restoremodes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>savemodes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>window_ops</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> )</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>DoStartBlinking</name>(s) ((s)-&gt;cursor_blink ^ (s)-&gt;cursor_blink_esc)</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name> || <name>OPT_BLINK_TEXT</name></expr></cpp:if>
<function_decl><type><name>static</name> <name>void</name></type> <name>SetCursorBlink</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type></decl></param> <comment type="block">/* screen */</comment> ,
			   <param><decl><type><name>Bool</name></type></decl></param> <comment type="block">/* enable */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>HandleBlinking</name><parameter_list>(<param><decl><type><name>XtPointer</name></type></decl></param> <comment type="block">/* closure */</comment> ,
			   <param><decl><type><name>XtIntervalId</name> *</type></decl></param> <comment type="block">/* id */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>StartBlinking</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type></decl></param> <comment type="block">/* screen */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>StopBlinking</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type></decl></param> <comment type="block">/* screen */</comment> )</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>StartBlinking</name>(screen)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>StopBlinking</name>(screen)</cpp:define>	<comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
<function_decl><type><name>static</name> <name>void</name></type> <name>PreeditPosition</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive>	<name>DEFAULT</name>		-1</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>BELLSUPPRESSMSEC</name> 200</cpp:define>

<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>nparam</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>ANSI</name></type> <name>reply</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name><name>param</name><index>[<expr><name>NPARAM</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>static</name> <name>jmp_buf</name></type> <name>vtjmpbuf</name></decl>;</decl_stmt>

<comment type="block">/* event handlers */</comment>
<decl_stmt><decl><type><name>static</name> <name>void</name> <name>HandleBell</name></type> <name>PROTO_XT_ACTIONS_ARGS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>void</name> <name>HandleIgnore</name></type> <name>PROTO_XT_ACTIONS_ARGS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>void</name> <name>HandleKeymapChange</name></type> <name>PROTO_XT_ACTIONS_ARGS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>void</name> <name>HandleVisualBell</name></type> <name>PROTO_XT_ACTIONS_ARGS</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HANDLE_STRUCT_NOTIFY</name></expr></cpp:if>
<decl_stmt><decl><type><name>static</name> <name>void</name> <name>HandleStructNotify</name></type> <name>PROTO_XT_EV_HANDLER_ARGS</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * NOTE: VTInitialize zeros out the entire ".screen" component of the
 * XtermWidget, so make sure to add an assignment statement in VTInitialize()
 * for each new ".screen" field added to this resource list.
 */</comment>

<comment type="block">/* Defaults */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>

<comment type="block">/*
 * If we default to colorMode enabled, compile-in defaults for the ANSI colors.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DFT_COLORMODE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DFT_COLOR</name>(name) name</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DFT_COLOR</name>(name) XtDefaultForeground</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>static</name> <name>String</name></type> <name>_Font_Selected_</name> =<init> <expr>"yes"</expr></init></decl>;</decl_stmt>	<comment type="block">/* string is arbitrary */</comment>

<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>defaultTranslations</name><index>[]</index></name> =<init>
<expr>"\
          Shift &lt;KeyPress&gt; Prior:scroll-back(1,halfpage) \n\
           Shift &lt;KeyPress&gt; Next:scroll-forw(1,halfpage) \n\
         Shift &lt;KeyPress&gt; Select:select-cursor-start() select-cursor-end(SELECT, CUT_BUFFER0) \n\
         Shift &lt;KeyPress&gt; Insert:insert-selection(SELECT, CUT_BUFFER0) \n\
"
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
"\
        &lt;KeyRelease&gt; Scroll_Lock:scroll-lock() \n\
"
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
"\
    Shift~Ctrl &lt;KeyPress&gt; KP_Add:larger-vt-font() \n\
    Shift Ctrl &lt;KeyPress&gt; KP_Add:smaller-vt-font() \n\
    Shift &lt;KeyPress&gt; KP_Subtract:smaller-vt-font() \n\
"
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
"\
                ~Meta &lt;KeyPress&gt;:insert-seven-bit() \n\
                 Meta &lt;KeyPress&gt;:insert-eight-bit() \n\
                !Ctrl &lt;Btn1Down&gt;:popup-menu(mainMenu) \n\
           !Lock Ctrl &lt;Btn1Down&gt;:popup-menu(mainMenu) \n\
 !Lock Ctrl @Num_Lock &lt;Btn1Down&gt;:popup-menu(mainMenu) \n\
     ! @Num_Lock Ctrl &lt;Btn1Down&gt;:popup-menu(mainMenu) \n\
                ~Meta &lt;Btn1Down&gt;:select-start() \n\
              ~Meta &lt;Btn1Motion&gt;:select-extend() \n\
                !Ctrl &lt;Btn2Down&gt;:popup-menu(vtMenu) \n\
           !Lock Ctrl &lt;Btn2Down&gt;:popup-menu(vtMenu) \n\
 !Lock Ctrl @Num_Lock &lt;Btn2Down&gt;:popup-menu(vtMenu) \n\
     ! @Num_Lock Ctrl &lt;Btn2Down&gt;:popup-menu(vtMenu) \n\
          ~Ctrl ~Meta &lt;Btn2Down&gt;:ignore() \n\
                 Meta &lt;Btn2Down&gt;:clear-saved-lines() \n\
            ~Ctrl ~Meta &lt;Btn2Up&gt;:insert-selection(SELECT, CUT_BUFFER0) \n\
                !Ctrl &lt;Btn3Down&gt;:popup-menu(fontMenu) \n\
           !Lock Ctrl &lt;Btn3Down&gt;:popup-menu(fontMenu) \n\
 !Lock Ctrl @Num_Lock &lt;Btn3Down&gt;:popup-menu(fontMenu) \n\
     ! @Num_Lock Ctrl &lt;Btn3Down&gt;:popup-menu(fontMenu) \n\
          ~Ctrl ~Meta &lt;Btn3Down&gt;:start-extend() \n\
              ~Meta &lt;Btn3Motion&gt;:select-extend() \n\
                 Ctrl &lt;Btn4Down&gt;:scroll-back(1,halfpage,m) \n\
            Lock Ctrl &lt;Btn4Down&gt;:scroll-back(1,halfpage,m) \n\
  Lock @Num_Lock Ctrl &lt;Btn4Down&gt;:scroll-back(1,halfpage,m) \n\
       @Num_Lock Ctrl &lt;Btn4Down&gt;:scroll-back(1,halfpage,m) \n\
                      &lt;Btn4Down&gt;:scroll-back(5,line,m)     \n\
                 Ctrl &lt;Btn5Down&gt;:scroll-forw(1,halfpage,m) \n\
            Lock Ctrl &lt;Btn5Down&gt;:scroll-forw(1,halfpage,m) \n\
  Lock @Num_Lock Ctrl &lt;Btn5Down&gt;:scroll-forw(1,halfpage,m) \n\
       @Num_Lock Ctrl &lt;Btn5Down&gt;:scroll-forw(1,halfpage,m) \n\
                      &lt;Btn5Down&gt;:scroll-forw(5,line,m)     \n\
                         &lt;BtnUp&gt;:select-end(SELECT, CUT_BUFFER0) \n\
                       &lt;BtnDown&gt;:ignore() \
"</expr></init></decl>;</decl_stmt>				<comment type="block">/* PROCURA added "Meta &lt;Btn2Down&gt;:clear-saved-lines()" */</comment>
<comment type="block">/* *INDENT-OFF* */</comment>
<decl_stmt><decl><type><name>static</name> <name>XtActionsRec</name></type> <name><name>actionsList</name><index>[]</index></name> =<init> <expr><block>{
    <expr><block>{ <expr>"allow-send-events"</expr>,	<expr><name>HandleAllowSends</name></expr> }</block></expr>,
    <expr><block>{ <expr>"bell"</expr>,			<expr><name>HandleBell</name></expr> }</block></expr>,
    <expr><block>{ <expr>"clear-saved-lines"</expr>,	<expr><name>HandleClearSavedLines</name></expr> }</block></expr>,
    <expr><block>{ <expr>"create-menu"</expr>,		<expr><name>HandleCreateMenu</name></expr> }</block></expr>,
    <expr><block>{ <expr>"delete-is-del"</expr>,		<expr><name>HandleDeleteIsDEL</name></expr> }</block></expr>,
    <expr><block>{ <expr>"dired-button"</expr>,		<expr><name>DiredButton</name></expr> }</block></expr>,
    <expr><block>{ <expr>"hard-reset"</expr>,		<expr><name>HandleHardReset</name></expr> }</block></expr>,
    <expr><block>{ <expr>"ignore"</expr>,			<expr><name>HandleIgnore</name></expr> }</block></expr>,
    <expr><block>{ <expr>"insert"</expr>,			<expr><name>HandleKeyPressed</name></expr> }</block></expr>,  <comment type="block">/* alias for insert-seven-bit */</comment>
    <expr><block>{ <expr>"insert-eight-bit"</expr>,	<expr><name>HandleEightBitKeyPressed</name></expr> }</block></expr>,
    <expr><block>{ <expr>"insert-selection"</expr>,	<expr><name>HandleInsertSelection</name></expr> }</block></expr>,
    <expr><block>{ <expr>"insert-seven-bit"</expr>,	<expr><name>HandleKeyPressed</name></expr> }</block></expr>,
    <expr><block>{ <expr>"interpret"</expr>,		<expr><name>HandleInterpret</name></expr> }</block></expr>,
    <expr><block>{ <expr>"keymap"</expr>,			<expr><name>HandleKeymapChange</name></expr> }</block></expr>,
    <expr><block>{ <expr>"popup-menu"</expr>,		<expr><name>HandlePopupMenu</name></expr> }</block></expr>,
    <expr><block>{ <expr>"print"</expr>,			<expr><name>HandlePrintScreen</name></expr> }</block></expr>,
    <expr><block>{ <expr>"print-everything"</expr>,	<expr><name>HandlePrintEverything</name></expr> }</block></expr>,
    <expr><block>{ <expr>"print-redir"</expr>,		<expr><name>HandlePrintControlMode</name></expr> }</block></expr>,
    <expr><block>{ <expr>"quit"</expr>,			<expr><name>HandleQuit</name></expr> }</block></expr>,
    <expr><block>{ <expr>"redraw"</expr>,			<expr><name>HandleRedraw</name></expr> }</block></expr>,
    <expr><block>{ <expr>"scroll-back"</expr>,		<expr><name>HandleScrollBack</name></expr> }</block></expr>,
    <expr><block>{ <expr>"scroll-forw"</expr>,		<expr><name>HandleScrollForward</name></expr> }</block></expr>,
    <expr><block>{ <expr>"secure"</expr>,			<expr><name>HandleSecure</name></expr> }</block></expr>,
    <expr><block>{ <expr>"select-cursor-end"</expr>,	<expr><name>HandleKeyboardSelectEnd</name></expr> }</block></expr>,
    <expr><block>{ <expr>"select-cursor-extend"</expr>,   <expr><name>HandleKeyboardSelectExtend</name></expr> }</block></expr>,
    <expr><block>{ <expr>"select-cursor-start"</expr>,	<expr><name>HandleKeyboardSelectStart</name></expr> }</block></expr>,
    <expr><block>{ <expr>"select-end"</expr>,		<expr><name>HandleSelectEnd</name></expr> }</block></expr>,
    <expr><block>{ <expr>"select-extend"</expr>,		<expr><name>HandleSelectExtend</name></expr> }</block></expr>,
    <expr><block>{ <expr>"select-set"</expr>,		<expr><name>HandleSelectSet</name></expr> }</block></expr>,
    <expr><block>{ <expr>"select-start"</expr>,		<expr><name>HandleSelectStart</name></expr> }</block></expr>,
    <expr><block>{ <expr>"send-signal"</expr>,		<expr><name>HandleSendSignal</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-8-bit-control"</expr>,	<expr><name>Handle8BitControl</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-allow132"</expr>,		<expr><name>HandleAllow132</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-altscreen"</expr>,		<expr><name>HandleAltScreen</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-appcursor"</expr>,		<expr><name>HandleAppCursor</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-appkeypad"</expr>,		<expr><name>HandleAppKeypad</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-autolinefeed"</expr>,	<expr><name>HandleAutoLineFeed</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-autowrap"</expr>,		<expr><name>HandleAutoWrap</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-backarrow"</expr>,		<expr><name>HandleBackarrow</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-bellIsUrgent"</expr>,	<expr><name>HandleBellIsUrgent</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-cursesemul"</expr>,		<expr><name>HandleCursesEmul</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-jumpscroll"</expr>,		<expr><name>HandleJumpscroll</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-keep-selection"</expr>,	<expr><name>HandleKeepSelection</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-marginbell"</expr>,		<expr><name>HandleMarginBell</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-old-function-keys"</expr>,	<expr><name>HandleOldFunctionKeys</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-pop-on-bell"</expr>,	<expr><name>HandleSetPopOnBell</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-reverse-video"</expr>,	<expr><name>HandleReverseVideo</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-reversewrap"</expr>,	<expr><name>HandleReverseWrap</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-scroll-on-key"</expr>,	<expr><name>HandleScrollKey</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-scroll-on-tty-output"</expr>, <expr><name>HandleScrollTtyOutput</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-scrollbar"</expr>,		<expr><name>HandleScrollbar</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-select"</expr>,		<expr><name>HandleSetSelect</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-sun-keyboard"</expr>,	<expr><name>HandleSunKeyboard</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-titeInhibit"</expr>,	<expr><name>HandleTiteInhibit</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-visual-bell"</expr>,	<expr><name>HandleSetVisualBell</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-vt-font"</expr>,		<expr><name>HandleSetFont</name></expr> }</block></expr>,
    <expr><block>{ <expr>"soft-reset"</expr>,		<expr><name>HandleSoftReset</name></expr> }</block></expr>,
    <expr><block>{ <expr>"start-cursor-extend"</expr>,	<expr><name>HandleKeyboardStartExtend</name></expr> }</block></expr>,
    <expr><block>{ <expr>"start-extend"</expr>,		<expr><name>HandleStartExtend</name></expr> }</block></expr>,
    <expr><block>{ <expr>"string"</expr>,			<expr><name>HandleStringEvent</name></expr> }</block></expr>,
    <expr><block>{ <expr>"vi-button"</expr>,		<expr><name>ViButton</name></expr> }</block></expr>,
    <expr><block>{ <expr>"visual-bell"</expr>,		<expr><name>HandleVisualBell</name></expr> }</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
    <expr><block>{ <expr>"set-logging"</expr>,		<expr><name>HandleLogging</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ALLOW_XXX_OPS</name></expr></cpp:if>
    <expr><block>{ <expr>"allow-color-ops"</expr>,	<expr><name>HandleAllowColorOps</name></expr> }</block></expr>,
    <expr><block>{ <expr>"allow-font-ops"</expr>,		<expr><name>HandleAllowFontOps</name></expr> }</block></expr>,
    <expr><block>{ <expr>"allow-tcap-ops"</expr>,		<expr><name>HandleAllowTcapOps</name></expr> }</block></expr>,
    <expr><block>{ <expr>"allow-title-ops"</expr>,	<expr><name>HandleAllowTitleOps</name></expr> }</block></expr>,
    <expr><block>{ <expr>"allow-window-ops"</expr>,	<expr><name>HandleAllowWindowOps</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
    <expr><block>{ <expr>"set-cursorblink"</expr>,	<expr><name>HandleCursorBlink</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BOX_CHARS</name></expr></cpp:if>
    <expr><block>{ <expr>"set-font-linedrawing"</expr>,	<expr><name>HandleFontBoxChars</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-font-packed"</expr>,	<expr><name>HandleFontPacked</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DABBREV</name></expr></cpp:if>
    <expr><block>{ <expr>"dabbrev-expand"</expr>,		<expr><name>HandleDabbrevExpand</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <expr><block>{ <expr>"set-font-doublesize"</expr>,	<expr><name>HandleFontDoublesize</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_SOFTFONT</name></expr></cpp:if>
    <expr><block>{ <expr>"set-font-loading"</expr>,	<expr><name>HandleFontLoading</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXEC_XTERM</name></expr></cpp:if>
    <expr><block>{ <expr>"spawn-new-terminal"</expr>,	<expr><name>HandleSpawnTerminal</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HP_FUNC_KEYS</name></expr></cpp:if>
    <expr><block>{ <expr>"set-hp-function-keys"</expr>,	<expr><name>HandleHpFunctionKeys</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_LOAD_VTFONTS</name></expr></cpp:if>
    <expr><block>{ <expr>"load-vt-fonts"</expr>,		<expr><name>HandleLoadVTFonts</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MAXIMIZE</name></expr></cpp:if>
    <expr><block>{ <expr>"deiconify"</expr>,		<expr><name>HandleDeIconify</name></expr> }</block></expr>,
    <expr><block>{ <expr>"iconify"</expr>,		<expr><name>HandleIconify</name></expr> }</block></expr>,
    <expr><block>{ <expr>"maximize"</expr>,		<expr><name>HandleMaximize</name></expr> }</block></expr>,
    <expr><block>{ <expr>"restore"</expr>,		<expr><name>HandleRestoreSize</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <expr><block>{ <expr>"alt-sends-escape"</expr>,	<expr><name>HandleAltEsc</name></expr> }</block></expr>,
    <expr><block>{ <expr>"meta-sends-escape"</expr>,	<expr><name>HandleMetaEsc</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-num-lock"</expr>,		<expr><name>HandleNumLock</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
    <expr><block>{ <expr>"readline-button"</expr>,	<expr><name>ReadLineButton</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
    <expr><block>{ <expr>"set-render-font"</expr>,	<expr><name>HandleRenderFont</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCO_FUNC_KEYS</name></expr></cpp:if>
    <expr><block>{ <expr>"set-sco-function-keys"</expr>,	<expr><name>HandleScoFunctionKeys</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
    <expr><block>{ <expr>"scroll-lock"</expr>,		<expr><name>HandleScrollLock</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
    <expr><block>{ <expr>"larger-vt-font"</expr>,		<expr><name>HandleLargerFont</name></expr> }</block></expr>,
    <expr><block>{ <expr>"smaller-vt-font"</expr>,	<expr><name>HandleSmallerFont</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUN_FUNC_KEYS</name></expr></cpp:if>
    <expr><block>{ <expr>"set-sun-function-keys"</expr>,	<expr><name>HandleSunFunctionKeys</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <expr><block>{ <expr>"set-terminal-type"</expr>,	<expr><name>HandleSetTerminalType</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-visibility"</expr>,		<expr><name>HandleVisibility</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-tek-text"</expr>,		<expr><name>HandleSetTekText</name></expr> }</block></expr>,
    <expr><block>{ <expr>"tek-page"</expr>,		<expr><name>HandleTekPage</name></expr> }</block></expr>,
    <expr><block>{ <expr>"tek-reset"</expr>,		<expr><name>HandleTekReset</name></expr> }</block></expr>,
    <expr><block>{ <expr>"tek-copy"</expr>,		<expr><name>HandleTekCopy</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
    <expr><block>{ <expr>"set-toolbar"</expr>,		<expr><name>HandleToolbar</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr><block>{ <expr>"set-utf8-mode"</expr>,		<expr><name>HandleUTF8Mode</name></expr> }</block></expr>,
    <expr><block>{ <expr>"set-utf8-title"</expr>,		<expr><name>HandleUTF8Title</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* *INDENT-ON* */</comment>

<decl_stmt><decl><type><name>static</name> <name>XtResource</name></type> <name><name>xterm_resources</name><index>[]</index></name> =<init>
<expr><block>{
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowSendEvents</name></expr></argument>, <argument><expr><name>XtCAllowSendEvents</name></expr></argument>, <argument><expr><name>screen</name>.<name>allowSendEvent0</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowColorOps</name></expr></argument>, <argument><expr><name>XtCAllowColorOps</name></expr></argument>, <argument><expr><name>screen</name>.<name>allowColorOp0</name></expr></argument>, <argument><expr><name>DEF_ALLOW_COLOR</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowFontOps</name></expr></argument>, <argument><expr><name>XtCAllowFontOps</name></expr></argument>, <argument><expr><name>screen</name>.<name>allowFontOp0</name></expr></argument>, <argument><expr><name>DEF_ALLOW_FONT</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowTcapOps</name></expr></argument>, <argument><expr><name>XtCAllowTcapOps</name></expr></argument>, <argument><expr><name>screen</name>.<name>allowTcapOp0</name></expr></argument>, <argument><expr><name>DEF_ALLOW_TCAP</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowTitleOps</name></expr></argument>, <argument><expr><name>XtCAllowTitleOps</name></expr></argument>, <argument><expr><name>screen</name>.<name>allowTitleOp0</name></expr></argument>, <argument><expr><name>DEF_ALLOW_TITLE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowWindowOps</name></expr></argument>, <argument><expr><name>XtCAllowWindowOps</name></expr></argument>, <argument><expr><name>screen</name>.<name>allowWindowOp0</name></expr></argument>, <argument><expr><name>DEF_ALLOW_WINDOW</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNaltIsNotMeta</name></expr></argument>, <argument><expr><name>XtCAltIsNotMeta</name></expr></argument>, <argument><expr><name>screen</name>.<name>alt_is_not_meta</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNaltSendsEscape</name></expr></argument>, <argument><expr><name>XtCAltSendsEscape</name></expr></argument>, <argument><expr><name>screen</name>.<name>alt_sends_esc</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNalwaysBoldMode</name></expr></argument>, <argument><expr><name>XtCAlwaysBoldMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>always_bold_mode</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNalwaysHighlight</name></expr></argument>, <argument><expr><name>XtCAlwaysHighlight</name></expr></argument>, <argument><expr><name>screen</name>.<name>always_highlight</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNappcursorDefault</name></expr></argument>, <argument><expr><name>XtCAppcursorDefault</name></expr></argument>, <argument><expr><name>misc</name>.<name>appcursorDefault</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNappkeypadDefault</name></expr></argument>, <argument><expr><name>XtCAppkeypadDefault</name></expr></argument>, <argument><expr><name>misc</name>.<name>appkeypadDefault</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNautoWrap</name></expr></argument>, <argument><expr><name>XtCAutoWrap</name></expr></argument>, <argument><expr><name>misc</name>.<name>autoWrap</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNawaitInput</name></expr></argument>, <argument><expr><name>XtCAwaitInput</name></expr></argument>, <argument><expr><name>screen</name>.<name>awaitInput</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNfreeBoldBox</name></expr></argument>, <argument><expr><name>XtCFreeBoldBox</name></expr></argument>, <argument><expr><name>screen</name>.<name>free_bold_box</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNbackarrowKey</name></expr></argument>, <argument><expr><name>XtCBackarrowKey</name></expr></argument>, <argument><expr><name>screen</name>.<name>backarrow_key</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNbellIsUrgent</name></expr></argument>, <argument><expr><name>XtCBellIsUrgent</name></expr></argument>, <argument><expr><name>screen</name>.<name>bellIsUrgent</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNbellOnReset</name></expr></argument>, <argument><expr><name>XtCBellOnReset</name></expr></argument>, <argument><expr><name>screen</name>.<name>bellOnReset</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNboldMode</name></expr></argument>, <argument><expr><name>XtCBoldMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>bold_mode</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNbrokenSelections</name></expr></argument>, <argument><expr><name>XtCBrokenSelections</name></expr></argument>, <argument><expr><name>screen</name>.<name>brokenSelections</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNc132</name></expr></argument>, <argument><expr><name>XtCC132</name></expr></argument>, <argument><expr><name>screen</name>.<name>c132</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcurses</name></expr></argument>, <argument><expr><name>XtCCurses</name></expr></argument>, <argument><expr><name>screen</name>.<name>curses</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcutNewline</name></expr></argument>, <argument><expr><name>XtCCutNewline</name></expr></argument>, <argument><expr><name>screen</name>.<name>cutNewline</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcutToBeginningOfLine</name></expr></argument>, <argument><expr><name>XtCCutToBeginningOfLine</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>cutToBeginningOfLine</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNdeleteIsDEL</name></expr></argument>, <argument><expr><name>XtCDeleteIsDEL</name></expr></argument>, <argument><expr><name>screen</name>.<name>delete_is_del</name></expr></argument>, <argument><expr><name>DEFDELETE_DEL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNdynamicColors</name></expr></argument>, <argument><expr><name>XtCDynamicColors</name></expr></argument>, <argument><expr><name>misc</name>.<name>dynamicColors</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNeightBitControl</name></expr></argument>, <argument><expr><name>XtCEightBitControl</name></expr></argument>, <argument><expr><name>screen</name>.<name>control_eight_bits</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNeightBitInput</name></expr></argument>, <argument><expr><name>XtCEightBitInput</name></expr></argument>, <argument><expr><name>screen</name>.<name>input_eight_bits</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNeightBitOutput</name></expr></argument>, <argument><expr><name>XtCEightBitOutput</name></expr></argument>, <argument><expr><name>screen</name>.<name>output_eight_bits</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNhighlightSelection</name></expr></argument>, <argument><expr><name>XtCHighlightSelection</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>highlight_selection</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNhpLowerleftBugCompat</name></expr></argument>, <argument><expr><name>XtCHpLowerleftBugCompat</name></expr></argument>, <argument><expr><name>screen</name>.<name>hp_ll_bc</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNi18nSelections</name></expr></argument>, <argument><expr><name>XtCI18nSelections</name></expr></argument>, <argument><expr><name>screen</name>.<name>i18nSelections</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNfastScroll</name></expr></argument>, <argument><expr><name>XtCFastScroll</name></expr></argument>, <argument><expr><name>screen</name>.<name>fastscroll</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNjumpScroll</name></expr></argument>, <argument><expr><name>XtCJumpScroll</name></expr></argument>, <argument><expr><name>screen</name>.<name>jumpscroll</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNkeepSelection</name></expr></argument>, <argument><expr><name>XtCKeepSelection</name></expr></argument>, <argument><expr><name>screen</name>.<name>keepSelection</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNloginShell</name></expr></argument>, <argument><expr><name>XtCLoginShell</name></expr></argument>, <argument><expr><name>misc</name>.<name>login_shell</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNmarginBell</name></expr></argument>, <argument><expr><name>XtCMarginBell</name></expr></argument>, <argument><expr><name>screen</name>.<name>marginbell</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNmetaSendsEscape</name></expr></argument>, <argument><expr><name>XtCMetaSendsEscape</name></expr></argument>, <argument><expr><name>screen</name>.<name>meta_sends_esc</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNmultiScroll</name></expr></argument>, <argument><expr><name>XtCMultiScroll</name></expr></argument>, <argument><expr><name>screen</name>.<name>multiscroll</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNoldXtermFKeys</name></expr></argument>, <argument><expr><name>XtCOldXtermFKeys</name></expr></argument>, <argument><expr><name>screen</name>.<name>old_fkeys</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNpopOnBell</name></expr></argument>, <argument><expr><name>XtCPopOnBell</name></expr></argument>, <argument><expr><name>screen</name>.<name>poponbell</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNprinterAutoClose</name></expr></argument>, <argument><expr><name>XtCPrinterAutoClose</name></expr></argument>, <argument><expr><name>screen</name>.<name>printer_autoclose</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNprinterExtent</name></expr></argument>, <argument><expr><name>XtCPrinterExtent</name></expr></argument>, <argument><expr><name>screen</name>.<name>printer_extent</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNprinterFormFeed</name></expr></argument>, <argument><expr><name>XtCPrinterFormFeed</name></expr></argument>, <argument><expr><name>screen</name>.<name>printer_formfeed</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNprinterNewLine</name></expr></argument>, <argument><expr><name>XtCPrinterNewLine</name></expr></argument>, <argument><expr><name>screen</name>.<name>printer_newline</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNquietGrab</name></expr></argument>, <argument><expr><name>XtCQuietGrab</name></expr></argument>, <argument><expr><name>screen</name>.<name>quiet_grab</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNreverseVideo</name></expr></argument>, <argument><expr><name>XtCReverseVideo</name></expr></argument>, <argument><expr><name>misc</name>.<name>re_verse</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNreverseWrap</name></expr></argument>, <argument><expr><name>XtCReverseWrap</name></expr></argument>, <argument><expr><name>misc</name>.<name>reverseWrap</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNscrollBar</name></expr></argument>, <argument><expr><name>XtCScrollBar</name></expr></argument>, <argument><expr><name>misc</name>.<name>scrollbar</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNscrollKey</name></expr></argument>, <argument><expr><name>XtCScrollCond</name></expr></argument>, <argument><expr><name>screen</name>.<name>scrollkey</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNscrollTtyOutput</name></expr></argument>, <argument><expr><name>XtCScrollCond</name></expr></argument>, <argument><expr><name>screen</name>.<name>scrollttyoutput</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNselectToClipboard</name></expr></argument>, <argument><expr><name>XtCSelectToClipboard</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>selectToClipboard</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNsignalInhibit</name></expr></argument>, <argument><expr><name>XtCSignalInhibit</name></expr></argument>, <argument><expr><name>misc</name>.<name>signalInhibit</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNtiteInhibit</name></expr></argument>, <argument><expr><name>XtCTiteInhibit</name></expr></argument>, <argument><expr><name>misc</name>.<name>titeInhibit</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNtiXtraScroll</name></expr></argument>, <argument><expr><name>XtCTiXtraScroll</name></expr></argument>, <argument><expr><name>misc</name>.<name>tiXtraScroll</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNtrimSelection</name></expr></argument>, <argument><expr><name>XtCTrimSelection</name></expr></argument>, <argument><expr><name>screen</name>.<name>trim_selection</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNunderLine</name></expr></argument>, <argument><expr><name>XtCUnderLine</name></expr></argument>, <argument><expr><name>screen</name>.<name>underline</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNvisualBell</name></expr></argument>, <argument><expr><name>XtCVisualBell</name></expr></argument>, <argument><expr><name>screen</name>.<name>visualbell</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,

    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNbellSuppressTime</name></expr></argument>, <argument><expr><name>XtCBellSuppressTime</name></expr></argument>, <argument><expr><name>screen</name>.<name>bellSuppressTime</name></expr></argument>, <argument><expr><name>BELLSUPPRESSMSEC</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNfontWarnings</name></expr></argument>, <argument><expr><name>XtCFontWarnings</name></expr></argument>, <argument><expr><name>misc</name>.<name>fontWarnings</name></expr></argument>, <argument><expr><name>fwResource</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNinternalBorder</name></expr></argument>, <argument><expr><name>XtCBorderWidth</name></expr></argument>, <argument><expr><name>screen</name>.<name>border</name></expr></argument>, <argument><expr><name>DEFBORDER</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNlimitResize</name></expr></argument>, <argument><expr><name>XtCLimitResize</name></expr></argument>, <argument><expr><name>misc</name>.<name>limit_resize</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmultiClickTime</name></expr></argument>, <argument><expr><name>XtCMultiClickTime</name></expr></argument>, <argument><expr><name>screen</name>.<name>multiClickTime</name></expr></argument>, <argument><expr><name>MULTICLICKTIME</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNnMarginBell</name></expr></argument>, <argument><expr><name>XtCColumn</name></expr></argument>, <argument><expr><name>screen</name>.<name>nmarginbell</name></expr></argument>, <argument><expr><name>N_MARGINBELL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNpointerMode</name></expr></argument>, <argument><expr><name>XtCPointerMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>pointer_mode</name></expr></argument>, <argument><expr><name>DEF_POINTER_MODE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNprinterControlMode</name></expr></argument>, <argument><expr><name>XtCPrinterControlMode</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>printer_controlmode</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNtitleModes</name></expr></argument>, <argument><expr><name>XtCTitleModes</name></expr></argument>, <argument><expr><name>screen</name>.<name>title_modes</name></expr></argument>, <argument><expr><name>DEF_TITLE_MODES</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNvisualBellDelay</name></expr></argument>, <argument><expr><name>XtCVisualBellDelay</name></expr></argument>, <argument><expr><name>screen</name>.<name>visualBellDelay</name></expr></argument>, <argument><expr>100</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNsaveLines</name></expr></argument>, <argument><expr><name>XtCSaveLines</name></expr></argument>, <argument><expr><name>screen</name>.<name>savelines</name></expr></argument>, <argument><expr><name>SAVELINES</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNscrollBarBorder</name></expr></argument>, <argument><expr><name>XtCScrollBarBorder</name></expr></argument>, <argument><expr><name>screen</name>.<name>scrollBarBorder</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNscrollLines</name></expr></argument>, <argument><expr><name>XtCScrollLines</name></expr></argument>, <argument><expr><name>screen</name>.<name>scrolllines</name></expr></argument>, <argument><expr><name>SCROLLLINES</name></expr></argument>)</argument_list></call></expr>,

    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNinitialFont</name></expr></argument>, <argument><expr><name>XtCInitialFont</name></expr></argument>, <argument><expr><name>screen</name>.<name>initial_font</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfont1</name></expr></argument>, <argument><expr><name>XtCFont1</name></expr></argument>, <argument><expr><name>screen</name>.<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_font1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfont2</name></expr></argument>, <argument><expr><name>XtCFont2</name></expr></argument>, <argument><expr><name>screen</name>.<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_font2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfont3</name></expr></argument>, <argument><expr><name>XtCFont3</name></expr></argument>, <argument><expr><name>screen</name>.<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_font3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfont4</name></expr></argument>, <argument><expr><name>XtCFont4</name></expr></argument>, <argument><expr><name>screen</name>.<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_font4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfont5</name></expr></argument>, <argument><expr><name>XtCFont5</name></expr></argument>, <argument><expr><name>screen</name>.<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_font5</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfont6</name></expr></argument>, <argument><expr><name>XtCFont6</name></expr></argument>, <argument><expr><name>screen</name>.<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_font6</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,

    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNanswerbackString</name></expr></argument>, <argument><expr><name>XtCAnswerbackString</name></expr></argument>, <argument><expr><name>screen</name>.<name>answer_back</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNboldFont</name></expr></argument>, <argument><expr><name>XtCBoldFont</name></expr></argument>, <argument><expr><name>misc</name>.<name>default_font</name>.<name>f_b</name></expr></argument>, <argument><expr><name>DEFBOLDFONT</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNcharClass</name></expr></argument>, <argument><expr><name>XtCCharClass</name></expr></argument>, <argument><expr><name>screen</name>.<name>charClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNdecTerminalID</name></expr></argument>, <argument><expr><name>XtCDecTerminalID</name></expr></argument>, <argument><expr><name>screen</name>.<name>term_id</name></expr></argument>, <argument><expr><name>DFT_DECID</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNdefaultString</name></expr></argument>, <argument><expr><name>XtCDefaultString</name></expr></argument>, <argument><expr><name>screen</name>.<name>default_string</name></expr></argument>, <argument><expr>"#"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNdisallowedColorOps</name></expr></argument>, <argument><expr><name>XtCDisallowedColorOps</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>disallowedColorOps</name></expr></argument>, <argument><expr><name>DEF_DISALLOWED_COLOR</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNdisallowedFontOps</name></expr></argument>, <argument><expr><name>XtCDisallowedFontOps</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>disallowedFontOps</name></expr></argument>, <argument><expr><name>DEF_DISALLOWED_FONT</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNdisallowedTcapOps</name></expr></argument>, <argument><expr><name>XtCDisallowedTcapOps</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>disallowedTcapOps</name></expr></argument>, <argument><expr><name>DEF_DISALLOWED_TCAP</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNdisallowedWindowOps</name></expr></argument>, <argument><expr><name>XtCDisallowedWindowOps</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>disallowedWinOps</name></expr></argument>, <argument><expr><name>DEF_DISALLOWED_WINDOW</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNeightBitSelectTypes</name></expr></argument>, <argument><expr><name>XtCEightBitSelectTypes</name></expr></argument>,
	 <argument><expr><name>screen</name>.<name>eightbit_select_types</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfont</name></expr></argument>, <argument><expr><name>XtCFont</name></expr></argument>, <argument><expr><name>misc</name>.<name>default_font</name>.<name>f_n</name></expr></argument>, <argument><expr><name>DEFFONT</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNgeometry</name></expr></argument>, <argument><expr><name>XtCGeometry</name></expr></argument>, <argument><expr><name>misc</name>.<name>geo_metry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNkeyboardDialect</name></expr></argument>, <argument><expr><name>XtCKeyboardDialect</name></expr></argument>, <argument><expr><name>screen</name>.<name>keyboard_dialect</name></expr></argument>, <argument><expr><name>DFT_KBD_DIALECT</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNprinterCommand</name></expr></argument>, <argument><expr><name>XtCPrinterCommand</name></expr></argument>, <argument><expr><name>screen</name>.<name>printer_command</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNtekGeometry</name></expr></argument>, <argument><expr><name>XtCGeometry</name></expr></argument>, <argument><expr><name>misc</name>.<name>T_geometry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,

    <expr><call><name>Tres</name><argument_list>(<argument><expr><name>XtNcursorColor</name></expr></argument>, <argument><expr><name>XtCCursorColor</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>, <argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Tres</name><argument_list>(<argument><expr><name>XtNforeground</name></expr></argument>, <argument><expr><name>XtCForeground</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>, <argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Tres</name><argument_list>(<argument><expr><name>XtNpointerColor</name></expr></argument>, <argument><expr><name>XtCPointerColor</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>, <argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Tres</name><argument_list>(<argument><expr><name>XtNbackground</name></expr></argument>, <argument><expr><name>XtCBackground</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>, <argument><expr><name>XtDefaultBackground</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Tres</name><argument_list>(<argument><expr><name>XtNpointerColorBackground</name></expr></argument>, <argument><expr><name>XtCBackground</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>, <argument><expr><name>XtDefaultBackground</name></expr></argument>)</argument_list></call></expr>,

    <expr><block>{<expr><name>XtNresizeGravity</name></expr>, <expr><name>XtCResizeGravity</name></expr>, <expr><name>XtRGravity</name></expr>, <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>XtGravity</name></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>XtermWidgetRec</name></expr></argument>, <argument><expr><name>misc</name>.<name>resizeGravity</name></expr></argument>)</argument_list></call></expr>,
     <expr><name>XtRImmediate</name></expr>, <expr>(<name>XtPointer</name>) <name>SouthWestGravity</name></expr>}</block></expr>,

    <expr><block>{<expr><name>XtNpointerShape</name></expr>, <expr><name>XtCCursor</name></expr>, <expr><name>XtRCursor</name></expr>, <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Cursor</name></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>XtermWidgetRec</name></expr></argument>, <argument><expr><name>screen</name>.<name>pointer_cursor</name></expr></argument>)</argument_list></call></expr>,
     <expr><name>XtRString</name></expr>, <expr>(<name>XtPointer</name>) "xterm"</expr>}</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNlogInhibit</name></expr></argument>, <argument><expr><name>XtCLogInhibit</name></expr></argument>, <argument><expr><name>misc</name>.<name>logInhibit</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNlogging</name></expr></argument>, <argument><expr><name>XtCLogging</name></expr></argument>, <argument><expr><name>misc</name>.<name>log_on</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNlogFile</name></expr></argument>, <argument><expr><name>XtCLogfile</name></expr></argument>, <argument><expr><name>screen</name>.<name>logfile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <expr><call><name>Bres</name><argument_list>(<argument><expr>"activeIcon"</expr></argument>, <argument><expr>"ActiveIcon"</expr></argument>, <argument><expr><name>misc</name>.<name>active_icon</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr>"iconBorderWidth"</expr></argument>, <argument><expr><name>XtCBorderWidth</name></expr></argument>, <argument><expr><name>misc</name>.<name>icon_border_width</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Fres</name><argument_list>(<argument><expr>"iconFont"</expr></argument>, <argument><expr>"IconFont"</expr></argument>, <argument><expr><name>screen</name>.<name>fnt_icon</name>.<name>fs</name></expr></argument>, <argument><expr><name>XtDefaultFont</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Cres</name><argument_list>(<argument><expr>"iconBorderColor"</expr></argument>, <argument><expr><name>XtCBorderColor</name></expr></argument>, <argument><expr><name>misc</name>.<name>icon_border_pixel</name></expr></argument>, <argument><expr><name>XtDefaultBackground</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* NO_ACTIVE_ICON */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcursorBlink</name></expr></argument>, <argument><expr><name>XtCCursorBlink</name></expr></argument>, <argument><expr><name>screen</name>.<name>cursor_blink</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcursorUnderline</name></expr></argument>, <argument><expr><name>XtCCursorUnderline</name></expr></argument>, <argument><expr><name>screen</name>.<name>cursor_underline</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_TEXT</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNshowBlinkAsBold</name></expr></argument>, <argument><expr><name>XtCCursorBlink</name></expr></argument>, <argument><expr><name>screen</name>.<name>blink_as_bold</name></expr></argument>, <argument><expr><name>DEFBLINKASBOLD</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name> || <name>OPT_BLINK_TEXT</name></expr></cpp:if>
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNcursorOnTime</name></expr></argument>, <argument><expr><name>XtCCursorOnTime</name></expr></argument>, <argument><expr><name>screen</name>.<name>blink_on</name></expr></argument>, <argument><expr>600</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNcursorOffTime</name></expr></argument>, <argument><expr><name>XtCCursorOffTime</name></expr></argument>, <argument><expr><name>screen</name>.<name>blink_off</name></expr></argument>, <argument><expr>300</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BOX_CHARS</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNforceBoxChars</name></expr></argument>, <argument><expr><name>XtCForceBoxChars</name></expr></argument>, <argument><expr><name>screen</name>.<name>force_box_chars</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNforcePackedFont</name></expr></argument>, <argument><expr><name>XtCForcePackedFont</name></expr></argument>, <argument><expr><name>screen</name>.<name>force_packed</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNshowMissingGlyphs</name></expr></argument>, <argument><expr><name>XtCShowMissingGlyphs</name></expr></argument>, <argument><expr><name>screen</name>.<name>force_all_chars</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BROKEN_OSC</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNbrokenLinuxOSC</name></expr></argument>, <argument><expr><name>XtCBrokenLinuxOSC</name></expr></argument>, <argument><expr><name>screen</name>.<name>brokenLinuxOSC</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BROKEN_ST</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNbrokenStringTerm</name></expr></argument>, <argument><expr><name>XtCBrokenStringTerm</name></expr></argument>, <argument><expr><name>screen</name>.<name>brokenStringTerm</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_C1_PRINT</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowC1Printable</name></expr></argument>, <argument><expr><name>XtCAllowC1Printable</name></expr></argument>, <argument><expr><name>screen</name>.<name>c1_printable</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_CLIP_BOLD</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNuseClipping</name></expr></argument>, <argument><expr><name>XtCUseClipping</name></expr></argument>, <argument><expr><name>screen</name>.<name>use_clipping</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNfontDoublesize</name></expr></argument>, <argument><expr><name>XtCFontDoublesize</name></expr></argument>, <argument><expr><name>screen</name>.<name>font_doublesize</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNcacheDoublesize</name></expr></argument>, <argument><expr><name>XtCCacheDoublesize</name></expr></argument>, <argument><expr><name>screen</name>.<name>cache_doublesize</name></expr></argument>, <argument><expr><name>NUM_CHRSET</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <expr><call><name>Tres</name><argument_list>(<argument><expr><name>XtNhighlightColor</name></expr></argument>, <argument><expr><name>XtCHighlightColor</name></expr></argument>, <argument><expr><name>HIGHLIGHT_BG</name></expr></argument>, <argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Tres</name><argument_list>(<argument><expr><name>XtNhighlightTextColor</name></expr></argument>, <argument><expr><name>XtCHighlightTextColor</name></expr></argument>, <argument><expr><name>HIGHLIGHT_FG</name></expr></argument>, <argument><expr><name>XtDefaultBackground</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNhighlightReverse</name></expr></argument>, <argument><expr><name>XtCHighlightReverse</name></expr></argument>, <argument><expr><name>screen</name>.<name>hilite_reverse</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNhighlightColorMode</name></expr></argument>, <argument><expr><name>XtCHighlightColorMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>hilite_color</name></expr></argument>, <argument><expr><name>Maybe</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* OPT_HIGHLIGHT_COLOR */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNopenIm</name></expr></argument>, <argument><expr><name>XtCOpenIm</name></expr></argument>, <argument><expr><name>misc</name>.<name>open_im</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNinputMethod</name></expr></argument>, <argument><expr><name>XtCInputMethod</name></expr></argument>, <argument><expr><name>misc</name>.<name>input_method</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNpreeditType</name></expr></argument>, <argument><expr><name>XtCPreeditType</name></expr></argument>, <argument><expr><name>misc</name>.<name>preedit_type</name></expr></argument>,
	 <argument><expr>"OverTheSpot,Root"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNretryInputMethod</name></expr></argument>, <argument><expr><name>XtCRetryInputMethod</name></expr></argument>, <argument><expr><name>misc</name>.<name>retry_im</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNboldColors</name></expr></argument>, <argument><expr><name>XtCColorMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>boldColors</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNveryBoldColors</name></expr></argument>, <argument><expr><name>XtCVeryBoldColors</name></expr></argument>, <argument><expr><name>screen</name>.<name>veryBoldColors</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcolorMode</name></expr></argument>, <argument><expr><name>XtCColorMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>colorMode</name></expr></argument>, <argument><expr><name>DFT_COLORMODE</name></expr></argument>)</argument_list></call></expr>,

    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcolorAttrMode</name></expr></argument>, <argument><expr><name>XtCColorAttrMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>colorAttrMode</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcolorBDMode</name></expr></argument>, <argument><expr><name>XtCColorAttrMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>colorBDMode</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcolorBLMode</name></expr></argument>, <argument><expr><name>XtCColorAttrMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>colorBLMode</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcolorRVMode</name></expr></argument>, <argument><expr><name>XtCColorAttrMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>colorRVMode</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcolorULMode</name></expr></argument>, <argument><expr><name>XtCColorAttrMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>colorULMode</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNitalicULMode</name></expr></argument>, <argument><expr><name>XtCColorAttrMode</name></expr></argument>, <argument><expr><name>screen</name>.<name>italicULMode</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,

    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"0"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_0</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"black"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_1</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"red3"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"2"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_2</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"green3"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"3"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_3</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"yellow3"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"4"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_4</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr><name>DEF_COLOR4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"5"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_5</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"magenta3"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"6"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_6</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"cyan3"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"7"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_7</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"gray90"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"8"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_8</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"gray50"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"9"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_9</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"red"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"10"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_10</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"green"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"11"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_11</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"yellow"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"12"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_12</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr><name>DEF_COLOR12</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"13"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_13</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"magenta"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"14"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_14</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"cyan"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"15"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_15</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr>"white"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"BD"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_BD</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"BL"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_BL</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"UL"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_UL</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>COLOR_RES</name><argument_list>(<argument><expr>"RV"</expr></argument>, <argument><expr><name>screen</name>.<name><name>Acolors</name><index>[<expr><name>COLOR_RV</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>DFT_COLOR</name><argument_list>(<argument><expr><name>XtDefaultForeground</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_COLOR_RES2</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_256_COLORS</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;256colres.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OPT_88_COLORS</name></expr></cpp:elif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;88colres.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* !OPT_COLOR_RES2 */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* OPT_ISO_COLORS */</comment>

    <expr><call><name>CLICK_RES</name><argument_list>(<argument><expr>"2"</expr></argument>, <argument><expr><name>screen</name>.<name><name>onClick</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"word"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>CLICK_RES</name><argument_list>(<argument><expr>"3"</expr></argument>, <argument><expr><name>screen</name>.<name><name>onClick</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>"line"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>CLICK_RES</name><argument_list>(<argument><expr>"4"</expr></argument>, <argument><expr><name>screen</name>.<name><name>onClick</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>CLICK_RES</name><argument_list>(<argument><expr>"5"</expr></argument>, <argument><expr><name>screen</name>.<name><name>onClick</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmodifyCursorKeys</name></expr></argument>, <argument><expr><name>XtCModifyCursorKeys</name></expr></argument>,
	 <argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>cursor_keys</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmodifyFunctionKeys</name></expr></argument>, <argument><expr><name>XtCModifyFunctionKeys</name></expr></argument>,
	 <argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>function_keys</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmodifyKeypadKeys</name></expr></argument>, <argument><expr><name>XtCModifyKeypadKeys</name></expr></argument>,
	 <argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>keypad_keys</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmodifyOtherKeys</name></expr></argument>, <argument><expr><name>XtCModifyOtherKeys</name></expr></argument>,
	 <argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>other_keys</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmodifyStringKeys</name></expr></argument>, <argument><expr><name>XtCModifyStringKeys</name></expr></argument>,
	 <argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>string_keys</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNformatOtherKeys</name></expr></argument>, <argument><expr><name>XtCFormatOtherKeys</name></expr></argument>,
	 <argument><expr><name>keyboard</name>.<name>format_keys</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNalwaysUseMods</name></expr></argument>, <argument><expr><name>XtCAlwaysUseMods</name></expr></argument>, <argument><expr><name>misc</name>.<name>alwaysUseMods</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNnumLock</name></expr></argument>, <argument><expr><name>XtCNumLock</name></expr></argument>, <argument><expr><name>misc</name>.<name>real_NumLock</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PRINT_COLORS</name></expr></cpp:if>
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNprintAttributes</name></expr></argument>, <argument><expr><name>XtCPrintAttributes</name></expr></argument>, <argument><expr><name>screen</name>.<name>print_attributes</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNshiftFonts</name></expr></argument>, <argument><expr><name>XtCShiftFonts</name></expr></argument>, <argument><expr><name>misc</name>.<name>shift_fonts</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNctrlFKeys</name></expr></argument>, <argument><expr><name>XtCCtrlFKeys</name></expr></argument>, <argument><expr><name>misc</name>.<name>ctrl_fkeys</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNtekInhibit</name></expr></argument>, <argument><expr><name>XtCTekInhibit</name></expr></argument>, <argument><expr><name>misc</name>.<name>tekInhibit</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNtekSmall</name></expr></argument>, <argument><expr><name>XtCTekSmall</name></expr></argument>, <argument><expr><name>misc</name>.<name>tekSmall</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNtekStartup</name></expr></argument>, <argument><expr><name>XtCTekStartup</name></expr></argument>, <argument><expr><name>misc</name>.<name>TekEmu</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
    <expr><call><name>Wres</name><argument_list>(<argument><expr><name>XtNmenuBar</name></expr></argument>, <argument><expr><name>XtCMenuBar</name></expr></argument>, <argument><expr><call><name>VT100_TB_INFO</name><argument_list>(<argument><expr><name>menu_bar</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmenuHeight</name></expr></argument>, <argument><expr><name>XtCMenuHeight</name></expr></argument>, <argument><expr><call><name>VT100_TB_INFO</name><argument_list>(<argument><expr><name>menu_height</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>25</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNcjkWidth</name></expr></argument>, <argument><expr><name>XtCCjkWidth</name></expr></argument>, <argument><expr><name>misc</name>.<name>cjk_width</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNmkWidth</name></expr></argument>, <argument><expr><name>XtCMkWidth</name></expr></argument>, <argument><expr><name>misc</name>.<name>mk_width</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNutf8Latin1</name></expr></argument>, <argument><expr><name>XtCUtf8Latin1</name></expr></argument>, <argument><expr><name>screen</name>.<name>utf8_latin1</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNutf8Title</name></expr></argument>, <argument><expr><name>XtCUtf8Title</name></expr></argument>, <argument><expr><name>screen</name>.<name>utf8_title</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNvt100Graphics</name></expr></argument>, <argument><expr><name>XtCVT100Graphics</name></expr></argument>, <argument><expr><name>screen</name>.<name>vt100_graphics</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNwideChars</name></expr></argument>, <argument><expr><name>XtCWideChars</name></expr></argument>, <argument><expr><name>screen</name>.<name>wide_chars</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNcombiningChars</name></expr></argument>, <argument><expr><name>XtCCombiningChars</name></expr></argument>, <argument><expr><name>screen</name>.<name>max_combining</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmkSamplePass</name></expr></argument>, <argument><expr><name>XtCMkSamplePass</name></expr></argument>, <argument><expr><name>misc</name>.<name>mk_samplepass</name></expr></argument>, <argument><expr>256</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNmkSampleSize</name></expr></argument>, <argument><expr><name>XtCMkSampleSize</name></expr></argument>, <argument><expr><name>misc</name>.<name>mk_samplesize</name></expr></argument>, <argument><expr>1024</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNutf8</name></expr></argument>, <argument><expr><name>XtCUtf8</name></expr></argument>, <argument><expr><name>screen</name>.<name>utf8_mode</name></expr></argument>, <argument><expr><name>uDefault</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNwideBoldFont</name></expr></argument>, <argument><expr><name>XtCWideBoldFont</name></expr></argument>, <argument><expr><name>misc</name>.<name>default_font</name>.<name>f_wb</name></expr></argument>, <argument><expr><name>DEFWIDEBOLDFONT</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNwideFont</name></expr></argument>, <argument><expr><name>XtCWideFont</name></expr></argument>, <argument><expr><name>misc</name>.<name>default_font</name>.<name>f_w</name></expr></argument>, <argument><expr><name>DEFWIDEFONT</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNutf8SelectTypes</name></expr></argument>, <argument><expr><name>XtCUtf8SelectTypes</name></expr></argument>, <argument><expr><name>screen</name>.<name>utf8_select_types</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_LUIT_PROG</name></expr></cpp:if>
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNlocale</name></expr></argument>, <argument><expr><name>XtCLocale</name></expr></argument>, <argument><expr><name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"medium"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNlocaleFilter</name></expr></argument>, <argument><expr><name>XtCLocaleFilter</name></expr></argument>, <argument><expr><name>misc</name>.<name>localefilter</name></expr></argument>, <argument><expr><name>DEFLOCALEFILTER</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNximFont</name></expr></argument>, <argument><expr><name>XtCXimFont</name></expr></argument>, <argument><expr><name>misc</name>.<name>f_x</name></expr></argument>, <argument><expr><name>DEFXIMFONT</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNallowScrollLock</name></expr></argument>, <argument><expr><name>XtCAllowScrollLock</name></expr></argument>, <argument><expr><name>screen</name>.<name>allowScrollLock0</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_XMC_GLITCH</name></expr></cpp:if>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNxmcInline</name></expr></argument>, <argument><expr><name>XtCXmcInline</name></expr></argument>, <argument><expr><name>screen</name>.<name>xmc_inline</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNxmcMoveSGR</name></expr></argument>, <argument><expr><name>XtCXmcMoveSGR</name></expr></argument>, <argument><expr><name>screen</name>.<name>move_sgr_ok</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNxmcAttributes</name></expr></argument>, <argument><expr><name>XtCXmcAttributes</name></expr></argument>, <argument><expr><name>screen</name>.<name>xmc_attributes</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Ires</name><argument_list>(<argument><expr><name>XtNxmcGlitch</name></expr></argument>, <argument><expr><name>XtCXmcGlitch</name></expr></argument>, <argument><expr><name>screen</name>.<name>xmc_glitch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCROLLBAR_RIGHT</name></cpp:ifdef>
    <expr><call><name>Bres</name><argument_list>(<argument><expr><name>XtNrightScrollBar</name></expr></argument>, <argument><expr><name>XtCRightScrollBar</name></expr></argument>, <argument><expr><name>misc</name>.<name>useRight</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>RES_FACESIZE</name>(n) Dres(XtNfaceSize #n, XtCFaceSize #n, misc.face_size[n], "0.0")</cpp:define>
    <expr><call><name>RES_FACESIZE</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>RES_FACESIZE</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>RES_FACESIZE</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>RES_FACESIZE</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>RES_FACESIZE</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>RES_FACESIZE</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Dres</name><argument_list>(<argument><expr><name>XtNfaceSize</name></expr></argument>, <argument><expr><name>XtCFaceSize</name></expr></argument>, <argument><expr><name>misc</name>.<name><name>face_size</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>DEFFACESIZE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfaceName</name></expr></argument>, <argument><expr><name>XtCFaceName</name></expr></argument>, <argument><expr><name>misc</name>.<name>face_name</name></expr></argument>, <argument><expr><name>DEFFACENAME</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNfaceNameDoublesize</name></expr></argument>, <argument><expr><name>XtCFaceNameDoublesize</name></expr></argument>, <argument><expr><name>misc</name>.<name>face_wide_name</name></expr></argument>, <argument><expr><name>DEFFACENAME</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>Sres</name><argument_list>(<argument><expr><name>XtNrenderFont</name></expr></argument>, <argument><expr><name>XtCRenderFont</name></expr></argument>, <argument><expr><name>misc</name>.<name>render_font_s</name></expr></argument>, <argument><expr>"default"</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><name>static</name> <name>Boolean</name></type> <name>VTSetValues</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>cur</name></decl></param>, <param><decl><type><name>Widget</name></type> <name>request</name></decl></param>, <param><decl><type><name>Widget</name></type> <name>new_arg</name></decl></param>,
			   <param><decl><type><name>ArgList</name></type> <name>args</name></decl></param>, <param><decl><type><name>Cardinal</name> *</type><name>num_args</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>VTClassInit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>VTDestroy</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>VTExpose</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>, <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>, <param><decl><type><name>Region</name></type> <name>region</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>VTInitialize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>wrequest</name></decl></param>, <param><decl><type><name>Widget</name></type> <name>new_arg</name></decl></param>, <param><decl><type><name>ArgList</name></type> <name>args</name></decl></param>,
			 <param><decl><type><name>Cardinal</name> *</type><name>num_args</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>VTRealize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>, <param><decl><type><name>XtValueMask</name> *</type> <name>valuemask</name></decl></param>,
		      <param><decl><type><name>XSetWindowAttributes</name> *</type> <name>values</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>VTResize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_I18N_SUPPORT</name> &amp;&amp; <name>OPT_INPUT_METHOD</name></expr></cpp:if>
<function_decl><type><name>static</name> <name>void</name></type> <name>VTInitI18N</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<macro><name>globaldef</name></macro> <block>{
    <expr_stmt><expr>"xtermclassrec"</expr></expr_stmt>
}</block> <decl_stmt><decl><type><name>noshare</name>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>static</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* VMS */</comment>
<name>WidgetClassRec</name> <name>xtermClassRec</name> =<init>
<expr><block>{
    <expr><block>{
	<comment type="block">/* core_class fields */</comment>
	<expr>(<name>WidgetClass</name>) &amp; <name>widgetClassRec</name></expr>,		<comment type="block">/* superclass   */</comment>
	<expr>"VT100"</expr>,		<comment type="block">/* class_name                   */</comment>
	<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>XtermWidgetRec</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* widget_size                  */</comment>
	<expr><name>VTClassInit</name></expr>,		<comment type="block">/* class_initialize             */</comment>
	<expr><name>NULL</name></expr>,			<comment type="block">/* class_part_initialize        */</comment>
	<expr><name>False</name></expr>,			<comment type="block">/* class_inited                 */</comment>
	<expr><name>VTInitialize</name></expr>,		<comment type="block">/* initialize                   */</comment>
	<expr><name>NULL</name></expr>,			<comment type="block">/* initialize_hook              */</comment>
	<expr><name>VTRealize</name></expr>,		<comment type="block">/* realize                      */</comment>
	<expr><name>actionsList</name></expr>,		<comment type="block">/* actions                      */</comment>
	<expr><call><name>XtNumber</name><argument_list>(<argument><expr><name>actionsList</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* num_actions                  */</comment>
	<expr><name>xterm_resources</name></expr>,	<comment type="block">/* resources                    */</comment>
	<expr><call><name>XtNumber</name><argument_list>(<argument><expr><name>xterm_resources</name></expr></argument>)</argument_list></call></expr>,	<comment type="block">/* num_resources        */</comment>
	<expr><name>NULLQUARK</name></expr>,		<comment type="block">/* xrm_class                    */</comment>
	<expr><name>True</name></expr>,			<comment type="block">/* compress_motion              */</comment>
	<expr><name>False</name></expr>,			<comment type="block">/* compress_exposure            */</comment>
	<expr><name>True</name></expr>,			<comment type="block">/* compress_enterleave          */</comment>
	<expr><name>False</name></expr>,			<comment type="block">/* visible_interest             */</comment>
	<expr><name>VTDestroy</name></expr>,		<comment type="block">/* destroy                      */</comment>
	<expr><name>VTResize</name></expr>,		<comment type="block">/* resize                       */</comment>
	<expr><name>VTExpose</name></expr>,		<comment type="block">/* expose                       */</comment>
	<expr><name>VTSetValues</name></expr>,		<comment type="block">/* set_values                   */</comment>
	<expr><name>NULL</name></expr>,			<comment type="block">/* set_values_hook              */</comment>
	<expr><name>XtInheritSetValuesAlmost</name></expr>,	<comment type="block">/* set_values_almost    */</comment>
	<expr><name>NULL</name></expr>,			<comment type="block">/* get_values_hook              */</comment>
	<expr><name>NULL</name></expr>,			<comment type="block">/* accept_focus                 */</comment>
	<expr><name>XtVersion</name></expr>,		<comment type="block">/* version                      */</comment>
	<expr><name>NULL</name></expr>,			<comment type="block">/* callback_offsets             */</comment>
	<expr><name>defaultTranslations</name></expr>,	<comment type="block">/* tm_table                     */</comment>
	<expr><name>XtInheritQueryGeometry</name></expr>,	<comment type="block">/* query_geometry               */</comment>
	<expr><name>XtInheritDisplayAccelerator</name></expr>,	<comment type="block">/* display_accelerator  */</comment>
	<expr><name>NULL</name></expr>			<comment type="block">/* extension                    */</comment>
    }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<macro><name>globaldef</name></macro> <block>{
    <expr_stmt><expr>"xtermwidgetclass"</expr></expr_stmt>
}</block>
<decl_stmt><decl><type><name>noshare</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>
<name>WidgetClass</name></type> <name>xtermWidgetClass</name> =<init> <expr>(<name>WidgetClass</name>) &amp; <name>xtermClassRec</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Add input-actions for widgets that are overlooked (scrollbar and toolbar):
 *
 *	a) Sometimes the scrollbar passes through translations, sometimes it
 *	   doesn't.  We add the KeyPress translations here, just to be sure.
 *	b) In the normal (non-toolbar) configuration, the xterm widget covers
 *	   almost all of the window.  With a toolbar, there's a relatively
 *	   large area that the user would expect to enter keystrokes since the
 *	   program can get the focus.
 */</comment>
<function><type><name>void</name></type>
<name>xtermAddInput</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* *INDENT-OFF* */</comment>
    <decl_stmt><decl><type><name>XtActionsRec</name></type> <name><name>input_actions</name><index>[]</index></name> =<init> <expr><block>{
	<expr><block>{ <expr>"insert"</expr>,		    <expr><name>HandleKeyPressed</name></expr> }</block></expr>, <comment type="block">/* alias */</comment>
	<expr><block>{ <expr>"insert-eight-bit"</expr>,	    <expr><name>HandleEightBitKeyPressed</name></expr> }</block></expr>,
	<expr><block>{ <expr>"insert-seven-bit"</expr>,	    <expr><name>HandleKeyPressed</name></expr> }</block></expr>,
	<expr><block>{ <expr>"secure"</expr>,		    <expr><name>HandleSecure</name></expr> }</block></expr>,
	<expr><block>{ <expr>"string"</expr>,		    <expr><name>HandleStringEvent</name></expr> }</block></expr>,
	<expr><block>{ <expr>"scroll-back"</expr>,	    <expr><name>HandleScrollBack</name></expr> }</block></expr>,
	<expr><block>{ <expr>"scroll-forw"</expr>,	    <expr><name>HandleScrollForward</name></expr> }</block></expr>,
	<expr><block>{ <expr>"select-cursor-end"</expr>,	    <expr><name>HandleKeyboardSelectEnd</name></expr> }</block></expr>,
	<expr><block>{ <expr>"select-cursor-extend"</expr>,   <expr><name>HandleKeyboardSelectExtend</name></expr> }</block></expr>,
	<expr><block>{ <expr>"select-cursor-start"</expr>,    <expr><name>HandleKeyboardSelectStart</name></expr> }</block></expr>,
	<expr><block>{ <expr>"insert-selection"</expr>,	    <expr><name>HandleInsertSelection</name></expr> }</block></expr>,
	<expr><block>{ <expr>"select-start"</expr>,	    <expr><name>HandleSelectStart</name></expr> }</block></expr>,
	<expr><block>{ <expr>"select-extend"</expr>,	    <expr><name>HandleSelectExtend</name></expr> }</block></expr>,
	<expr><block>{ <expr>"start-extend"</expr>,	    <expr><name>HandleStartExtend</name></expr> }</block></expr>,
	<expr><block>{ <expr>"select-end"</expr>,		    <expr><name>HandleSelectEnd</name></expr> }</block></expr>,
	<expr><block>{ <expr>"clear-saved-lines"</expr>,	    <expr><name>HandleClearSavedLines</name></expr> }</block></expr>,
	<expr><block>{ <expr>"popup-menu"</expr>,		    <expr><name>HandlePopupMenu</name></expr> }</block></expr>,
	<expr><block>{ <expr>"bell"</expr>,		    <expr><name>HandleBell</name></expr> }</block></expr>,
	<expr><block>{ <expr>"ignore"</expr>,		    <expr><name>HandleIgnore</name></expr> }</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DABBREV</name></expr></cpp:if>
	<expr><block>{ <expr>"dabbrev-expand"</expr>,	    <expr><name>HandleDabbrevExpand</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
	<expr><block>{ <expr>"scroll-lock"</expr>,	    <expr><name>HandleScrollLock</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
	<expr><block>{ <expr>"larger-vt-font"</expr>,	    <expr><name>HandleLargerFont</name></expr> }</block></expr>,
	<expr><block>{ <expr>"smaller-vt-font"</expr>,	    <expr><name>HandleSmallerFont</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr></init></decl>;</decl_stmt>
    <comment type="block">/* *INDENT-ON* */</comment>

    <expr_stmt><expr><call><name>TRACE_TRANS</name><argument_list>(<argument><expr>"BEFORE"</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtAppAddActions</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>, <argument><expr><name>input_actions</name></expr></argument>, <argument><expr><call><name>XtNumber</name><argument_list>(<argument><expr><name>input_actions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtAugmentTranslations</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><call><name>XtParseTranslationTable</name><argument_list>(<argument><expr><name>defaultTranslations</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_TRANS</name><argument_list>(<argument><expr>"AFTER:"</expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXTRA_PASTE</name></expr></cpp:if>
    <if>if <condition>(<expr><name>term</name> &amp;&amp; <name>term</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>XtOverrideTranslations</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>term</name></expr></argument>, <argument><expr><call><name>XtParseTranslationTable</name><argument_list>(<argument><expr><name>term</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXP_BOGUS_FG</name></cpp:ifdef>
<function><type><name>static</name> <name>Bool</name></type>
<name>CheckBogusForeground</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>tag</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr>-1</expr>, <expr><name>col</name> = -1</expr>, <expr><name>pass</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>isClear</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>) <name>tag</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>pass</name> = 0</expr>;</init> <condition><expr><name>pass</name> &lt; 2</expr>;</condition> <incr><expr>++<name>pass</name></expr></incr>) <block>{
	<expr_stmt><expr><name>row</name> = <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt>
	<for>for (<init>;</init> <condition><expr><name>isClear</name> &amp;&amp; (<name>row</name> &lt;= <name>screen</name>-&gt;<name>max_row</name>)</expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
	    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call>-&gt;</expr></init></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>ld</name> != 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Char</name> *</type><name>attribs</name> =<init> <expr><name>ld</name>-&gt;<name>attribs</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>col</name> = (<name>row</name> == <name>screen</name>-&gt;<name>cur_row</name>) ? <name>screen</name>-&gt;<name>cur_col</name> : 0</expr>;</expr_stmt>
		<for>for (<init>;</init> <condition><expr><name>isClear</name> &amp;&amp; (<name>col</name> &lt;= <name>screen</name>-&gt;<name>max_col</name>)</expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
		    <decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> =<init> <expr><name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		    <if>if <condition>(<expr><name>pass</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>flags</name> &amp;= ~<name>FG_COLOR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> = (<name>Char</name>) <name>flags</name></expr>;</expr_stmt>
		    }</block></then> <else>else <if>if <condition>(<expr>(<name>flags</name> &amp; <name>BG_COLOR</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>isClear</name> = <name>False</name></expr>;</expr_stmt>
		    }</block></then> <else>else <if>if <condition>(<expr>(<name>flags</name> &amp; <name>FG_COLOR</name>)</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>unsigned</name></type> <name>ch</name> =<init> <expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>isClear</name> = ((<name>ch</name> == ' ') || (<name>ch</name> == 0))</expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><name>isClear</name> = <name>False</name></expr>;</expr_stmt>
		    }</block></else></if></else></if></else></if>
		}</block></for>
	    }</block></then></if>
	}</block></for>
    }</block></for>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s checked %d,%d to %d,%d %s pass %d\n",
	   <name>tag</name>, <name>screen</name>-&gt;<name>cur_row</name>, <name>screen</name>-&gt;<name>cur_col</name>,
	   <name>row</name>, <name>col</name>,
	   <name>isClear</name> &amp;&amp; <name>pass</name> ? "cleared" : "unchanged",
	   <name>pass</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>isClear</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The terminal's foreground and background colors are set via two mechanisms:
 *	text (cur_foreground, cur_background values that are passed down to
 *		XDrawImageString and XDrawString)
 *	area (X11 graphics context used in XClearArea and XFillRectangle)
 */</comment>
<function><type><name>void</name></type>
<name>SGR_Foreground</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>color</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>color</name> &gt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>UIntSet</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>FG_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>FG_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>fg</name> = <call><name>getXtermForeground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>cur_foreground</name> = <name>color</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcBold</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcBoldReverse</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXP_BOGUS_FG</name></cpp:ifdef>
    <comment type="block">/*
     * If we've just turned off the foreground color, check for blank cells
     * which have no background color, but do have foreground color.  This
     * could happen due to setting the foreground color just before scrolling.
     *
     * Those cells look uncolored, but will confuse ShowCursor(), which looks
     * for the colors in the current cell, and will see the foreground color.
     * In that case, remove the foreground color from the blank cells.
     */</comment>
    <if>if <condition>(<expr><name>color</name> &lt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>CheckBogusForeground</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>"SGR_Foreground"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name>SGR_Background</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>color</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg</name></decl>;</decl_stmt>

    <comment type="block">/*
     * An indexing operation may have set screen-&gt;scroll_amt, which would
     * normally result in calling FlushScroll() in WriteText().  However,
     * if we're changing the background color now, then the new value
     * should not apply to the pending blank lines.
     */</comment>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name> &amp;&amp; (<name>color</name> != <name>xw</name>-&gt;<name>cur_background</name>)</expr>)</condition><then>
	<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>color</name> &gt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>UIntSet</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>BG_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>BG_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>bg</name> = <call><name>getXtermBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>cur_background</name> = <name>color</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcBold</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcBoldReverse</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Invoked after updating bold/underline flags, computes the extended color
 * index to use for foreground.  (See also 'extract_fg()').
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>setExtendedFG</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fg</name> =<init> <expr><name>xw</name>-&gt;<name>sgr_foreground</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>colorAttrMode</name>
	|| (<name>fg</name> &lt; 0)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>fg</name> = <call><name>MapToColorMode</name><argument_list>(<argument><expr><name>fg</name></expr></argument>, <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* This implements the IBM PC-style convention of 8-colors, with one
     * bit for bold, thus mapping the 0-7 codes to 8-15.  It won't make
     * much sense for 16-color applications, but we keep it to retain
     * compatiblity with ANSI-color applications.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PC_COLORS</name></expr></cpp:if>		<comment type="block">/* XXXJTL should be settable at runtime (resource or OSC?) */</comment>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>boldColors</name>
	&amp;&amp; (!<name>xw</name>-&gt;<name>sgr_extended</name>)
	&amp;&amp; (<name>fg</name> &gt;= 0)
	&amp;&amp; (<name>fg</name> &lt; 8)
	&amp;&amp; (<name>xw</name>-&gt;<name>flags</name> &amp; <name>BOLD</name>)</expr>)</condition><then>
	<expr_stmt><expr><name>fg</name> |= 8</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>SGR_Foreground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Invoked after updating inverse flag, computes the extended color
 * index to use for background.  (See also 'extract_bg()').
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>setExtendedBG</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>bg</name> =<init> <expr><name>xw</name>-&gt;<name>sgr_background</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>colorAttrMode</name>
	|| (<name>bg</name> &lt; 0)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>colorRVMode</name> &amp;&amp; (<name>xw</name>-&gt;<name>flags</name> &amp; <name>INVERSE</name>)</expr>)</condition><then>
	    <expr_stmt><expr><name>bg</name> = <name>COLOR_RV</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>SGR_Background</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>reset_SGR_Foreground</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>xw</name>-&gt;<name>sgr_foreground</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>sgr_extended</name> = <name>False</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setExtendedFG</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>reset_SGR_Background</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>xw</name>-&gt;<name>sgr_background</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setExtendedBG</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>reset_SGR_Colors</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>reset_SGR_Foreground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>reset_SGR_Background</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_ISO_COLORS */</comment>

<function><type><name>void</name></type>
<name>resetCharsets</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("resetCharsets\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>0</expr>]</index></name> = 'B'</expr>;</expr_stmt>	<comment type="block">/* ASCII_G              */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>1</expr>]</index></name> = 'B'</expr>;</expr_stmt>	<comment type="block">/* ASCII_G              */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>2</expr>]</index></name> = 'B'</expr>;</expr_stmt>	<comment type="block">/* ASCII_G              */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>3</expr>]</index></name> = 'B'</expr>;</expr_stmt>	<comment type="block">/* ASCII_G              */</comment>

    <expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = 0</expr>;</expr_stmt>		<comment type="block">/* G0 =&gt; GL.            */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>curgr</name> = 2</expr>;</expr_stmt>		<comment type="block">/* G2 =&gt; GR.            */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>curss</name> = 0</expr>;</expr_stmt>		<comment type="block">/* No single shift.     */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>1</expr>]</index></name> = '0'</expr>;</expr_stmt></then></if>	<comment type="block">/* Graphics             */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
 * VT300 and up support three ANSI conformance levels, defined according to
 * the dpANSI X3.134.1 standard.  DEC's manuals equate levels 1 and 2, and
 * are unclear.  This code is written based on the manuals.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>set_ansi_conformance</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_ansi_conformance(%d) terminal_id %d, ansi_level %d\n",
	   <name>level</name>,
	   <name>screen</name>-&gt;<name>terminal_id</name>,
	   <name>screen</name>-&gt;<name>ansi_level</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> &gt;= 3</expr>)</condition><then> <block>{
	<switch>switch <condition>(<expr><name>screen</name>-&gt;<name>ansi_level</name> = <name>level</name></expr>)</condition> <block>{
	<case>case <expr>1</expr>:
	    <comment type="block">/* FALLTHRU */</comment>
	</case><case>case <expr>2</expr>:
	    <expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>0</expr>]</index></name> = 'B'</expr>;</expr_stmt>	<comment type="block">/* G0 is ASCII */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>1</expr>]</index></name> = 'B'</expr>;</expr_stmt>	<comment type="block">/* G1 is ISO Latin-1 (FIXME) */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgr</name> = 1</expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>3</expr>:
	    <expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr>0</expr>]</index></name> = 'B'</expr>;</expr_stmt>	<comment type="block">/* G0 is ASCII */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = 0</expr>;</expr_stmt>
	    <break>break;</break>
	</case>}</block></switch>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Set scrolling margins.  VTxxx terminals require that the top/bottom are
 * different, so we have at least two lines in the scrolling region.
 */</comment>
<function><type><name>void</name></type>
<name>set_tb_margins</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>top</name></decl></param>, <param><decl><type><name>int</name></type> <name>bottom</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_tb_margins %d..%d, prior %d..%d\n",
	   <name>top</name>, <name>bottom</name>,
	   <name>screen</name>-&gt;<name>top_marg</name>,
	   <name>screen</name>-&gt;<name>bot_marg</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bottom</name> &gt; <name>top</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>top_marg</name> = <name>top</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>bot_marg</name> = <name>bottom</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>top_marg</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>top_marg</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>bot_marg</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>bot_marg</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>set_max_col</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>cols</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_max_col %d, prior %d\n", <name>cols</name>, <name>screen</name>-&gt;<name>max_col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cols</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>cols</name> = 0</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>max_col</name> = <name>cols</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>set_max_row</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>rows</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_max_row %d, prior %d\n", <name>rows</name>, <name>screen</name>-&gt;<name>max_row</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rows</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>rows</name> = 0</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>max_row</name> = <name>rows</name></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>set_mod_fkeys</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>which</name></decl></param>, <param><decl><type><name>int</name></type> <name>what</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>enabled</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>SET_MOD_FKEYS</name>(field) \
    xw-&gt;keyboard.modify_now.field = ((what == DEFAULT) &amp;&amp; enabled) \
				     ? xw-&gt;keyboard.modify_1st.field \
				     : what; \
    TRACE(("set modify_now.%s to %d\n", #field, \
	   xw-&gt;keyboard.modify_now.field));</cpp:define>

    <switch>switch <condition>(<expr><name>which</name></expr>)</condition> <block>{
    <case>case <expr>1</expr>:
	<expr_stmt><expr><call><name>SET_MOD_FKEYS</name><argument_list>(<argument><expr><name>cursor_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>2</expr>:
	<expr_stmt><expr><call><name>SET_MOD_FKEYS</name><argument_list>(<argument><expr><name>function_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>3</expr>:
	<expr_stmt><expr><call><name>SET_MOD_FKEYS</name><argument_list>(<argument><expr><name>keypad_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>4</expr>:
	<expr_stmt><expr><call><name>SET_MOD_FKEYS</name><argument_list>(<argument><expr><name>other_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr>5</expr>:
	<expr_stmt><expr><call><name>SET_MOD_FKEYS</name><argument_list>(<argument><expr><name>string_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MOD_FKEYS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHICH_TABLE</name>(name) if (table == name) result = #name</cpp:define>
<function><type><name>static</name> <name>const</name> <name>char</name> *</type>
<name>which_table</name><parameter_list>(<param><decl><type><name>Const</name> <name>PARSE_T</name> *</type> <name>table</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>result</name> =<init> <expr>"?"</expr></init></decl>;</decl_stmt>
    <comment type="block">/* *INDENT-OFF* */</comment>
    <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>ansi_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>cigtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi2_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi_ex_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi_quo_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>dec2_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>dec3_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>dec_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>eigtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>esc_sp_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>esc_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>scrtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>scs96table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>scstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>sos_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi_sp_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi_tick_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_RECTOPS</name></expr></cpp:if>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi_dollar_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>csi_star_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>esc_pct_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>vt52_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>vt52_esc_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <else>else <expr_stmt><expr><call><name>WHICH_TABLE</name> <argument_list>(<argument><expr><name>vt52_ignore_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* *INDENT-ON* */</comment>

    <return>return <expr><name>result</name></expr>;</return>
</else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else></else>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* allocate larger buffer if needed/possible */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>SafeAlloc</name>(type, area, used, size) \
		type *new_string = area; \
		size_t new_length = size; \
		if (new_length == 0) { \
		    new_length = 256; \
		    new_string = TypeMallocN(type, new_length); \
		} else if (used+1 &gt;= new_length) { \
		    new_length = size * 2; \
		    new_string = TypeMallocN(type, new_length); \
		    if (new_string != 0 \
		     &amp;&amp; area != 0 \
		     &amp;&amp; used != 0) \
			memcpy(new_string, area, used * sizeof(type)); \
		}</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>WriteNow</name>() {						\
	    unsigned single = 0;				\
								\
	    if (screen-&gt;curss) {				\
		dotext(xw,					\
		       screen-&gt;gsets[(int) (screen-&gt;curss)],	\
		       sp-&gt;print_area,				\
		       (Cardinal) 1);				\
		screen-&gt;curss = 0;				\
		single++;					\
	    }							\
	    if (sp-&gt;print_used &gt; single) {			\
		dotext(xw,					\
		       screen-&gt;gsets[(int) (screen-&gt;curgl)],	\
		       sp-&gt;print_area + single,			\
		       (Cardinal) (sp-&gt;print_used - single));	\
	    }							\
	    sp-&gt;print_used = 0;					\
	}							\

struct ParseState {</cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Bool</name></type> <name>vt52_cup</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>Const</name> <name>PARSE_T</name> *</type><name>groundtable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <name>PARSE_T</name> *</type><name>parsestate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scstype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scssize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>private_function</name></decl>;</decl_stmt>	<comment type="block">/* distinguish private-mode from standard */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>string_mode</name></decl>;</decl_stmt>		<comment type="block">/* nonzero iff we're processing a string */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lastchar</name></decl>;</decl_stmt>		<comment type="block">/* positive iff we had a graphic character */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nextstate</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>last_was_wide</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Buffer for processing printable text */</comment>
    <decl_stmt><decl><type><name>IChar</name> *</type><name>print_area</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>print_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>print_used</name></decl>;</decl_stmt>
    <comment type="block">/* Buffer for processing strings (e.g., OSC ... ST) */</comment>
    <decl_stmt><decl><type><name>Char</name> *</type><name>string_area</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>string_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>string_used</name></decl>;</decl_stmt>
};

<decl_stmt><decl><type><name>static</name> struct <name>ParseState</name></type> <name>myState</name></decl>;</decl_stmt>

<function><type><name>static</name> <name>void</name></type>
<name>init_groundtable</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type>struct <name>ParseState</name> *</type><name>sp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>(<name>void</name>) <name>screen</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
    <if>if <condition>(<expr>!(<name>screen</name>-&gt;<name>vtXX_level</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>sp</name>-&gt;<name>groundtable</name> = <name>vt52_table</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 100</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
	<expr_stmt><expr><name>sp</name>-&gt;<name>groundtable</name> = <name>ansi_table</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>select_charset</name><parameter_list>(<param><decl><type>struct <name>ParseState</name> *</type><name>sp</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("select_charset %#x %d\n", <name>type</name>, <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name>-&gt;<name>scstype</name> = <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name>-&gt;<name>scssize</name> = <name>size</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>size</name> == 94</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>scstable</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>scs96table</name></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>zero_if_default</name><parameter_list>(<param><decl><type><name>int</name></type> <name>which</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>(<name>nparam</name> &gt; <name>which</name>) ? <name><name>param</name><index>[<expr><name>which</name></expr>]</index></name> : 0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>result</name> &lt;= 0</expr>)</condition><then>
	<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>one_if_default</name><parameter_list>(<param><decl><type><name>int</name></type> <name>which</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>(<name>nparam</name> &gt; <name>which</name>) ? <name><name>param</name><index>[<expr><name>which</name></expr>]</index></name> : 0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>result</name> &lt;= 0</expr>)</condition><then>
	<expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_C1_PRINT</name> || <name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ParseSOS</name>(screen) ((screen)-&gt;c1_printable == 0)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ParseSOS</name>(screen) 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>ResetState</name>(sp) (sp)-&gt;parsestate = (sp)-&gt;groundtable</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>illegal_parse</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>c</name></decl></param>, <param><decl><type>struct <name>ParseState</name> *</type><name>sp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = <name>sp</name>-&gt;<name><name>parsestate</name><index>[<expr><call><name>E2A</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>Boolean</name></type>
<name>doparsing</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>c</name></decl></param>, <param><decl><type>struct <name>ParseState</name> *</type><name>sp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>laststate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>thischar</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XTermRect</name></type> <name>myRect</name></decl>;</decl_stmt>

    <do>do <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>this_is_wide</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle zero-width combining characters.  Make it faster by noting
	 * that according to the Unicode charts, the majority of Western
	 * character sets do not use this feature.  There are some unassigned
	 * codes at 0x242, but no zero-width characters until past 0x300.
	 */</comment>
	<if>if <condition>(<expr><name>c</name> &gt;= 0x300 &amp;&amp; <name>screen</name>-&gt;<name>wide_chars</name>
	    &amp;&amp; <call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>int</name>) <name>c</name></expr></argument>)</argument_list></call> == 0
	    &amp;&amp; !<call><name>isWideControl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>prev</name>, <name>precomposed</name></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>WriteNow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><name>prev</name> = (<name>int</name>) <call><name>XTERM_CELL</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>last_written_row</name></expr></argument>,
				    <argument><expr><name>screen</name>-&gt;<name>last_written_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>precomposed</name> = <call><name>do_precomposition</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr>(<name>int</name>) <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("do_precomposition (U+%04X [%d], U+%04X [%d]) -&gt; U+%04X [%d]\n",
		   <name>prev</name>, <call><name>my_wcwidth</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call>,
		   (<name>int</name>) <name>c</name>, <call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>int</name>) <name>c</name></expr></argument>)</argument_list></call>,
		   <name>precomposed</name>, <call><name>my_wcwidth</name><argument_list>(<argument><expr><name>precomposed</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* substitute combined character with precomposed character
	     * only if it does not change the width of the base character
	     */</comment>
	    <if>if <condition>(<expr><name>precomposed</name> != -1 &amp;&amp; <call><name>my_wcwidth</name><argument_list>(<argument><expr><name>precomposed</name></expr></argument>)</argument_list></call> == <call><name>my_wcwidth</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>putXtermCell</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
			     <argument><expr><name>screen</name>-&gt;<name>last_written_row</name></expr></argument>,
			     <argument><expr><name>screen</name>-&gt;<name>last_written_col</name></expr></argument>, <argument><expr><name>precomposed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>addXtermCombining</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
				  <argument><expr><name>screen</name>-&gt;<name>last_written_row</name></expr></argument>,
				  <argument><expr><name>screen</name>-&gt;<name>last_written_col</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>

	    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>ScrnUpdate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>last_written_row</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>last_written_col</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <continue>continue;</continue>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Intercept characters for printer controller mode */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>printer_controlmode</name> == 2</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr>(<name>c</name> = (<name>unsigned</name>) <call><name>xtermPrinterControl</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>int</name>) <name>c</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
		<continue>continue;</continue></then></if>
	}</block></then></if>

	<comment type="block">/*
	 * VT52 is a little ugly in the one place it has a parameterized
	 * control sequence, since the parameter falls after the character
	 * that denotes the type of sequence.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	<if>if <condition>(<expr><name>sp</name>-&gt;<name>vt52_cup</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>nparam</name> &lt; <name>NPARAM</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>param</name><index>[<expr><name>nparam</name>++</expr>]</index></name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>c</name> &amp; 0x7f</expr></argument>)</argument_list></call> - 32</expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>nparam</name> &lt; 2</expr>)</condition><then>
		<continue>continue;</continue></then></if>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>vt52_cup</name> = <name>False</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 0</expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr>(<name>col</name> = <name><name>param</name><index>[<expr>1</expr>]</index></name>) &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>col</name> = 0</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>vt52_table</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>param</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>param</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>laststate</name> = <name>sp</name>-&gt;<name>nextstate</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>c</name> == <name>ANSI_DEL</name>
	    &amp;&amp; <name>sp</name>-&gt;<name>parsestate</name> == <name>sp</name>-&gt;<name>groundtable</name>
	    &amp;&amp; <name>sp</name>-&gt;<name>scssize</name> == 96
	    &amp;&amp; <name>sp</name>-&gt;<name>scstype</name> != 0</expr>)</condition><then> <block>{
	    <comment type="block">/*
	     * Handle special case of shifts for 96-character sets by checking
	     * if we have a DEL.  The other special case for SPACE will always
	     * be printable.
	     */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = <name>CASE_PRINT</name></expr>;</expr_stmt>
	}</block></then> <else>else
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>c</name> &gt; 255</expr>)</condition><then> <block>{
	    <comment type="block">/*
	     * The parsing tables all have 256 entries.  If we're supporting
	     * wide characters, we handle them by treating them the same as
	     * printing characters.
	     */</comment>
	    <if>if <condition>(<expr><name>sp</name>-&gt;<name>parsestate</name> == <name>sp</name>-&gt;<name>groundtable</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = <name>CASE_PRINT</name></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr><name>sp</name>-&gt;<name>parsestate</name> == <name>sos_table</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> &amp;= 0xffff</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> &gt; 255</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Found code &gt; 255 while in SOS state: %04X\n", <name>c</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>c</name> = '?'</expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = <name>CASE_GROUND_STATE</name></expr>;</expr_stmt>
	    }</block></else></if></else></if>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = <name>sp</name>-&gt;<name><name>parsestate</name><index>[<expr><call><name>E2A</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></else></if></else></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BROKEN_OSC</name></expr></cpp:if>
	<comment type="block">/*
	 * Linux console palette escape sequences start with an OSC, but do
	 * not terminate correctly.  Some scripts do not check before writing
	 * them, making xterm appear to hang (it's awaiting a valid string
	 * terminator).  Just ignore these if we see them - there's no point
	 * in emulating bad code.
	 */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>brokenLinuxOSC</name>
	    &amp;&amp; <name>sp</name>-&gt;<name>parsestate</name> == <name>sos_table</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>sp</name>-&gt;<name>string_used</name></expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><name>sp</name>-&gt;<name><name>string_area</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
		<case>case <expr>'P'</expr>:
		    <if>if <condition>(<expr><name>sp</name>-&gt;<name>string_used</name> &lt;= 7</expr>)</condition><then>
			<break>break;</break></then></if>
		    <comment type="block">/* FALLTHRU */</comment>
		</case><case>case <expr>'R'</expr>:
		    <expr_stmt><expr><call><name>illegal_parse</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Reset to ground state (brokenLinuxOSC)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case>}</block></switch>
	    }</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BROKEN_ST</name></expr></cpp:if>
	<comment type="block">/*
	 * Before patch #171, carriage control embedded within an OSC string
	 * would terminate it.  Some (buggy, of course) applications rely on
	 * this behavior.  Accommodate them by allowing one to compile xterm
	 * and emulate the old behavior.
	 */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>brokenStringTerm</name>
	    &amp;&amp; <name>sp</name>-&gt;<name>parsestate</name> == <name>sos_table</name>
	    &amp;&amp; <name>c</name> &lt; 32</expr>)</condition><then> <block>{
	    <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
	    <case>case <expr><name>ANSI_EOT</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_BS</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_HT</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_LF</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_VT</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_FF</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_CR</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_SO</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_SI</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_XON</name></expr>:	<comment type="block">/* FALLTHRU */</comment>
	    </case><case>case <expr><name>ANSI_CAN</name></expr>:
		<expr_stmt><expr><call><name>illegal_parse</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Reset to ground state (brokenStringTerm)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    </case>}</block></switch>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_C1_PRINT</name></expr></cpp:if>
	<comment type="block">/*
	 * This is not completely foolproof, but will allow an application
	 * with values in the C1 range to use them as printable characters,
	 * provided that they are not intermixed with an escape sequence.
	 */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>c1_printable</name>
	    &amp;&amp; (<name>c</name> &gt;= 128 &amp;&amp; <name>c</name> &lt; 160)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = (<name>sp</name>-&gt;<name>parsestate</name> == <name>esc_table</name>
			     ? <name>CASE_ESC_IGNORE</name>
			     : <name>sp</name>-&gt;<name><name>parsestate</name><index>[<expr><call><name>E2A</name><argument_list>(<argument><expr>160</expr></argument>)</argument_list></call></expr>]</index></name>)</expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<comment type="block">/*
	 * If we have a C1 code and the c1_printable flag is not set, simply
	 * ignore it when it was translated from UTF-8.  That is because the
	 * value could not have been present as-is in the UTF-8.
	 *
	 * To see that CASE_IGNORE is a consistent value, note that it is
	 * always used for NUL and other uninteresting C0 controls.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_C1_PRINT</name></expr></cpp:if>
	<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>c1_printable</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name>
		&amp;&amp; (<name>c</name> &gt;= 128 &amp;&amp; <name>c</name> &lt; 160)</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = <name>CASE_IGNORE</name></expr>;</expr_stmt>
	    }</block></then></if></then></if>

	<comment type="block">/*
	 * If this character is a different width than the last one, put the
	 * previous text into the buffer and draw it now.
	 */</comment>
	<expr_stmt><expr><name>this_is_wide</name> = <call><name>isWide</name><argument_list>(<argument><expr>(<name>int</name>) <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>this_is_wide</name> != <name>sp</name>-&gt;<name>last_was_wide</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>WriteNow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Accumulate string for printable text.  This may be 8/16-bit
	 * characters.
	 */</comment>
	<if>if <condition>(<expr><name>sp</name>-&gt;<name>nextstate</name> == <name>CASE_PRINT</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>SafeAlloc</name><argument_list>(<argument><expr><name>IChar</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>print_area</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>print_used</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>print_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>new_string</name> == 0</expr>)</condition><then> <block>{
		<macro><name>fprintf</name><argument_list>(<argument>stderr</argument>,
			<argument>"Cannot allocate %lu bytes for printable text\n"</argument>,
			<argument>(unsigned long) new_length</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<continue>continue;</continue>
	    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	    <comment type="block">/*
	     * Strip output text to 7-bits for VT52.  We should do this for
	     * VT100 also (which is a 7-bit device), but xterm has been
	     * doing this for so long we shouldn't change this behavior.
	     */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>c</name> &amp;= 0x7f</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>print_area</name> = <name>new_string</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>print_size</name> = <name>new_length</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name><name>print_area</name><index>[<expr><name>sp</name>-&gt;<name>print_used</name>++</expr>]</index></name> = (<name>IChar</name>) <name>c</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>lastchar</name> = <name>thischar</name> = (<name>int</name>) <name>c</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>last_was_wide</name> = <name>this_is_wide</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr><call><name>morePtyData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>VTbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<continue>continue;</continue>
	    }</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>sp</name>-&gt;<name>nextstate</name> == <name>CASE_PRINT</name>
	    || (<name>laststate</name> == <name>CASE_PRINT</name> &amp;&amp; <name>sp</name>-&gt;<name>print_used</name>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>WriteNow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/*
	 * Accumulate string for APC, DCS, PM, OSC, SOS controls
	 * This should always be 8-bit characters.
	 */</comment>
	<if>if <condition>(<expr><name>sp</name>-&gt;<name>parsestate</name> == <name>sos_table</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>SafeAlloc</name><argument_list>(<argument><expr><name>Char</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_area</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_used</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>new_string</name> == 0</expr>)</condition><then> <block>{
		<macro><name>fprintf</name><argument_list>(<argument>stderr</argument>,
			<argument>"Cannot allocate %lu bytes for string mode %d\n"</argument>,
			<argument>(unsigned long) new_length</argument>, <argument>sp-&gt;string_mode</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<continue>continue;</continue>
	    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <comment type="block">/*
	     * We cannot display codes above 255, but let's try to
	     * accommodate the application a little by not aborting the
	     * string.
	     */</comment>
	    <if>if <condition>(<expr>(<name>c</name> &amp; 0xffff) &gt; 255</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>nextstate</name> = <name>CASE_PRINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> = '?'</expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>string_area</name> = <name>new_string</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>string_size</name> = <name>new_length</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name><name>string_area</name><index>[<expr>(<name>sp</name>-&gt;<name>string_used</name>)++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>sp</name>-&gt;<name>parsestate</name> != <name>esc_table</name></expr>)</condition><then> <block>{
	    <comment type="block">/* if we were accumulating, we're not any more */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>string_mode</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>string_used</name> = 0</expr>;</expr_stmt>
	}</block></then></if></else></if>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("parse %04X -&gt; %d %s\n", <name>c</name>, <name>sp</name>-&gt;<name>nextstate</name>, <call><name>which_table</name><argument_list>(<argument><expr><name>sp</name>-&gt;<name>parsestate</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>sp</name>-&gt;<name>nextstate</name></expr>)</condition> <block>{
	<case>case <expr><name>CASE_PRINT</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_PRINT - printable characters\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_GROUND_STATE</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_GROUND_STATE - exit ignore mode\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_IGNORE</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_IGNORE - Ignore character %02X\n", <name>c</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ENQ</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_ENQ - answerback\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>count</name> = 0</expr>;</init> <condition><expr><name>screen</name>-&gt;<name><name>answer_back</name><index>[<expr><name>count</name></expr>]</index></name> != 0</expr>;</condition> <incr><expr><name>count</name>++</expr></incr>)
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name><name>answer_back</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	    <expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_BELL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_BELL - bell\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>sp</name>-&gt;<name>string_mode</name> == <name>ANSI_OSC</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>sp</name>-&gt;<name>string_used</name></expr>)</condition><then>
		    <expr_stmt><expr><name>sp</name>-&gt;<name><name>string_area</name><index>[<expr>--(<name>sp</name>-&gt;<name>string_used</name>)</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>do_osc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_area</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_used</name></expr></argument>, <argument><expr>(<name>int</name>) <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<comment type="block">/* bell */</comment>
		<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_TerminalBell</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_BS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_BS - backspace\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CR</name></expr>:
	    <comment type="block">/* CR */</comment>
	    <expr_stmt><expr><call><name>CarriageReturn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ESC</name></expr>:
	    <macro><name>if_OPT_VT52_MODE</name><argument_list>(<argument>screen</argument>, <argument>{
		sp-&gt;parsestate = vt52_esc_table;
		break;
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>esc_table</name></expr>;</expr_stmt>
	    <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_VT52_CUP</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_VT52_CUP - VT52 cursor addressing\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>vt52_cup</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>nparam</name> = 0</expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_VT52_IGNORE</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_VT52_IGNORE - VT52 ignore-character\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>vt52_ignore_table</name></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><case>case <expr><name>CASE_VMOT</name></expr>:
	    <comment type="block">/*
	     * form feed, line feed, vertical tab
	     */</comment>
	    <expr_stmt><expr><call><name>xtermAutoPrint</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermIndex</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>LINEFEED</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>CarriageReturn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><call><name>do_xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CBT</name></expr>:
	    <comment type="block">/* cursor backward tabulation */</comment>
	    <if>if <condition>(<expr>(<name>count</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) == <name>DEFAULT</name></expr>)</condition><then>
		<expr_stmt><expr><name>count</name> = 1</expr>;</expr_stmt></then></if>
	    <while>while <condition>(<expr>(<name>count</name>-- &gt; 0)
		   &amp;&amp; (<call><name>TabToPrevStop</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>)</expr>)</condition> <empty_stmt>;</empty_stmt></while>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CHT</name></expr>:
	    <comment type="block">/* cursor forward tabulation */</comment>
	    <if>if <condition>(<expr>(<name>count</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) == <name>DEFAULT</name></expr>)</condition><then>
		<expr_stmt><expr><name>count</name> = 1</expr>;</expr_stmt></then></if>
	    <while>while <condition>(<expr>(<name>count</name>-- &gt; 0)
		   &amp;&amp; (<call><name>TabToNextStop</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>)</expr>)</condition> <empty_stmt>;</empty_stmt></while>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_TAB</name></expr>:
	    <comment type="block">/* tab */</comment>
	    <expr_stmt><expr><call><name>TabToNextStop</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SI</name></expr>:
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = 0</expr>;</expr_stmt>
	    <macro><name>if_OPT_VT52_MODE</name><argument_list>(<argument>screen</argument>, <argument>{
		ResetState(sp);
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SO</name></expr>:
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = 1</expr>;</expr_stmt>
	    <macro><name>if_OPT_VT52_MODE</name><argument_list>(<argument>screen</argument>, <argument>{
		ResetState(sp);
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECDHL</name></expr>:
	    <expr_stmt><expr><call><name>xterm_DECDHL</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name> == '3'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSWL</name></expr>:
	    <expr_stmt><expr><call><name>xterm_DECSWL</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECDWL</name></expr>:
	    <expr_stmt><expr><call><name>xterm_DECDWL</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCR_STATE</name></expr>:
	    <comment type="block">/* enter scr state */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>scrtable</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCS0_STATE</name></expr>:
	    <comment type="block">/* enter scs state 0 */</comment>
	    <expr_stmt><expr><call><name>select_charset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>94</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCS1_STATE</name></expr>:
	    <comment type="block">/* enter scs state 1 */</comment>
	    <expr_stmt><expr><call><name>select_charset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>94</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCS2_STATE</name></expr>:
	    <comment type="block">/* enter scs state 2 */</comment>
	    <expr_stmt><expr><call><name>select_charset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>94</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCS3_STATE</name></expr>:
	    <comment type="block">/* enter scs state 3 */</comment>
	    <expr_stmt><expr><call><name>select_charset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>94</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCS1A_STATE</name></expr>:
	    <comment type="block">/* enter scs state 1 */</comment>
	    <expr_stmt><expr><call><name>select_charset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>96</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCS2A_STATE</name></expr>:
	    <comment type="block">/* enter scs state 2 */</comment>
	    <expr_stmt><expr><call><name>select_charset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>96</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SCS3A_STATE</name></expr>:
	    <comment type="block">/* enter scs state 3 */</comment>
	    <expr_stmt><expr><call><name>select_charset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>96</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ESC_IGNORE</name></expr>:
	    <comment type="block">/* unknown escape sequence */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>eigtable</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ESC_DIGIT</name></expr>:
	    <comment type="block">/* digit in csi or dec mode */</comment>
	    <if>if <condition>(<expr><name>nparam</name> &gt; 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr><name>nparam</name> - 1</expr>]</index></name>) == <name>DEFAULT</name></expr>)</condition><then>
		    <expr_stmt><expr><name>row</name> = 0</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name><name>param</name><index>[<expr><name>nparam</name> - 1</expr>]</index></name> = (10 * <name>row</name>) + ((<name>int</name>) <name>c</name> - '0')</expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>param</name><index>[<expr><name>nparam</name> - 1</expr>]</index></name> &gt; 65535</expr>)</condition><then>
		    <expr_stmt><expr><name><name>param</name><index>[<expr><name>nparam</name> - 1</expr>]</index></name> = 65535</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>sp</name>-&gt;<name>parsestate</name> == <name>csi_table</name></expr>)</condition><then>
		    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi2_table</name></expr>;</expr_stmt></then></if>
	    }</block></then></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ESC_SEMI</name></expr>:
	    <comment type="block">/* semicolon in csi or dec mode */</comment>
	    <if>if <condition>(<expr><name>nparam</name> &lt; <name>NPARAM</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>param</name><index>[<expr><name>nparam</name>++</expr>]</index></name> = <name>DEFAULT</name></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>sp</name>-&gt;<name>parsestate</name> == <name>csi_table</name></expr>)</condition><then>
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi2_table</name></expr>;</expr_stmt></then></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DEC_STATE</name></expr>:
	    <comment type="block">/* enter dec mode */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>dec_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DEC2_STATE</name></expr>:
	    <comment type="block">/* enter dec2 mode */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>dec2_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DEC3_STATE</name></expr>:
	    <comment type="block">/* enter dec3 mode */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>dec3_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ICH</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_ICH - insert char\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>InsertChar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CUU</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CUU - cursor up\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorUp</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CUD</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CUD - cursor down\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorDown</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CUF</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CUF - cursor forward\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>col</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>col</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorForward</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CUB</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CUB - cursor backward\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>col</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>col</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CUP</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CUP - cursor position\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <macro><name>if_OPT_XMC_GLITCH</name><argument_list>(<argument>screen</argument>, <argument>{
		Jump_XMC(xw);
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>nparam</name> &lt; 2 || (<name>col</name> = <name><name>param</name><index>[<expr>1</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>col</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name> - 1</expr></argument>, <argument><expr><name>col</name> - 1</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_VPA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_VPA - vertical position\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name> - 1</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_HPA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_HPA - horizontal position\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>col</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>col</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr><name>col</name> - 1</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_HP_BUGGY_LL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_HP_BUGGY_LL\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <comment type="block">/* Some HP-UX applications have the bug that they
	       assume ESC F goes to the lower left corner of
	       the screen, regardless of what terminfo says. */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>hp_ll_bc</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ED</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_ED - erase display\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>do_erase_display</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>OFF_PROTECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_EL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_EL - erase line\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>do_erase_line</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>OFF_PROTECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ECH</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_ECH - erase char\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <comment type="block">/* ECH */</comment>
	    <expr_stmt><expr><call><name>ClearRight</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &lt; 1 ? 1 : <name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_IL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_IL - insert line\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>InsertLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DL - delete line\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>DeleteLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DCH</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DCH - delete char\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>row</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>DeleteChar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_TRACK_MOUSE</name></expr>:
	    <comment type="block">/*
	     * A single parameter other than zero is always scroll-down.
	     * A zero-parameter is used to reset the mouse mode, and is
	     * not useful for scrolling anyway.
	     */</comment>
	    <if>if <condition>(<expr><name>nparam</name> &gt; 1 || <name><name>param</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>CELL</name></type> <name>start</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_TRACK_MOUSE\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Track mouse as long as in window and between
		 * specified rows
		 */</comment>
		<expr_stmt><expr><name>start</name>.<name>row</name> = <call><name>one_if_default</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name>.<name>col</name> = <name><name>param</name><index>[<expr>1</expr>]</index></name> - 1</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TrackMouse</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>,
			   <argument><expr>&amp;<name>start</name></expr></argument>,
			   <argument><expr><name><name>param</name><index>[<expr>3</expr>]</index></name> - 1</expr></argument>, <argument><expr><name><name>param</name><index>[<expr>4</expr>]</index></name> - 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SD - scroll down\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* SD */</comment>
		<if>if <condition>(<expr>(<name>count</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		    <expr_stmt><expr><name>count</name> = 1</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>RevScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECID</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECID\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <macro><name>if_OPT_VT52_MODE</name><argument_list>(<argument>screen</argument>, <argument>{
		unparseputc(xw, ANSI_ESC);
		unparseputc(xw, '/');
		unparseputc(xw, 'Z');
		unparse_end(xw);
		ResetState(sp);
		break;
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <expr_stmt><expr><name><name>param</name><index>[<expr>0</expr>]</index></name> = <name>DEFAULT</name></expr>;</expr_stmt>	<comment type="block">/* Default ID parameter */</comment>
	    <comment type="block">/* FALLTHRU */</comment>
	</case><case>case <expr><name>CASE_DA1</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DA1\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 0</expr>)</condition><then> <block>{	<comment type="block">/* less than means DEFAULT */</comment>
		<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = '?'</expr>;</expr_stmt>

		<comment type="block">/* The first param corresponds to the highest
		 * operating level (i.e., service level) of the
		 * emulation.  A DEC terminal can be setup to
		 * respond with a different DA response, but
		 * there's no control sequence that modifies this.
		 * We set it via a resource.
		 */</comment>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &lt; 200</expr>)</condition><then> <block>{
		    <switch>switch <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name></expr>)</condition> <block>{
		    <case>case <expr>102</expr>:
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 6</expr>;</expr_stmt>	<comment type="block">/* VT102 */</comment>
			<break>break;</break>
		    </case><case>case <expr>101</expr>:
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 1</expr>;</expr_stmt>	<comment type="block">/* VT101 */</comment>
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* no options */</comment>
			<break>break;</break>
		    </case><default>default:	<comment type="block">/* VT100 */</comment>
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 1</expr>;</expr_stmt>	<comment type="block">/* VT100 */</comment>
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 2</expr>;</expr_stmt>	<comment type="block">/* AVO */</comment>
			<break>break;</break>
		    </default>}</block></switch>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr>60
							 + <name>screen</name>-&gt;<name>terminal_id</name>
							 / 100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 1</expr>;</expr_stmt>		<comment type="block">/* 132-columns */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 2</expr>;</expr_stmt>		<comment type="block">/* printer */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 6</expr>;</expr_stmt>		<comment type="block">/* selective-erase */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
		    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>type</name> == <name>keyboardIsVT220</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 8</expr>;</expr_stmt></then></if>	<comment type="block">/* user-defined-keys */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 9</expr>;</expr_stmt>		<comment type="block">/* national replacement charsets */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 15</expr>;</expr_stmt>	<comment type="block">/* technical characters */</comment>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			reply.a_param[count++] = 22;	<comment type="block">/* ANSI color, VT525 */</comment>
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 29</expr>;</expr_stmt>	<comment type="block">/* ANSI text locator */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = (<name>ParmType</name>) <name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'c'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DA2</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DA2\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 0</expr>)</condition><then> <block>{	<comment type="block">/* less than means DEFAULT */</comment>
		<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = '&gt;'</expr>;</expr_stmt>

		<if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 200</expr>)</condition><then>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 1</expr>;</expr_stmt></then>		<comment type="block">/* VT220 */</comment>
		<else>else
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 0</expr>;</expr_stmt></else></if>		<comment type="block">/* VT100 (nonstandard) */</comment>
		<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>XTERM_PATCH</name></expr>;</expr_stmt>	<comment type="block">/* Version */</comment>
		<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* options (none) */</comment>
		<expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = (<name>ParmType</name>) <name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'c'</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECRPTUI</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECRPTUI\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>screen</name>-&gt;<name>terminal_id</name> &gt;= 400)
		&amp;&amp; (<name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 0)</expr>)</condition><then> <block>{	<comment type="block">/* less than means DEFAULT */</comment>
		<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_DCS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'!'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'|'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_TBC</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_TBC - tab clear\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt;= 0</expr>)</condition><then>	<comment type="block">/* less than means default */</comment>
		<expr_stmt><expr><call><name>TabClear</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>tabs</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr><name>row</name> == 3</expr>)</condition><then>
		<expr_stmt><expr><call><name>TabZonk</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>tabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SET</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SET - set mode\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ansi_modes</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>bitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_RST</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_RST - reset mode\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ansi_modes</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>bitclr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SGR</name></expr>:
	    <for>for (<init><expr><name>row</name> = 0</expr>;</init> <condition><expr><name>row</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
		<macro><name>if_OPT_XMC_GLITCH</name><argument_list>(<argument>screen</argument>, <argument>{
		    Mark_XMC(xw, param[row]);
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SGR %d\n", <name><name>param</name><index>[<expr><name>row</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>param</name><index>[<expr><name>row</name></expr>]</index></name></expr>)</condition> <block>{
		<case>case <expr><name>DEFAULT</name></expr>:
		</case><case>case <expr>0</expr>:
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>,
			    <argument><expr>(<name>INVERSE</name> | <name>BOLD</name> | <name>BLINK</name> | <name>UNDERLINE</name> | <name>INVISIBLE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			reset_SGR_Colors(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>1</expr>:	<comment type="block">/* Bold                 */</comment>
		    <expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> |= <name>BOLD</name></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>5</expr>:	<comment type="block">/* Blink                */</comment>
		    <expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> |= <name>BLINK</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>StartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>4</expr>:	<comment type="block">/* Underscore           */</comment>
		    <expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> |= <name>UNDERLINE</name></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>7</expr>:
		    <expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> |= <name>INVERSE</name></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedBG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>8</expr>:
		    <expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> |= <name>INVISIBLE</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>22</expr>:	<comment type="block">/* reset 'bold' */</comment>
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>BOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>24</expr>:
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>UNDERLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>25</expr>:	<comment type="block">/* reset 'blink' */</comment>
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>BLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>27</expr>:
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>INVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			setExtendedBG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>28</expr>:
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>INVISIBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>30</expr>:
		</case><case>case <expr>31</expr>:
		</case><case>case <expr>32</expr>:
		</case><case>case <expr>33</expr>:
		</case><case>case <expr>34</expr>:
		</case><case>case <expr>35</expr>:
		</case><case>case <expr>36</expr>:
		</case><case>case <expr>37</expr>:
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			xw-&gt;sgr_foreground = (param[row] - 30);
			xw-&gt;sgr_extended = False;
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>38</expr>:
		    <comment type="block">/* This is more complicated than I'd
		       like, but it should properly eat all
		       the parameters for unsupported modes
		     */</comment>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			row++;
			if (row &lt; nparam) {
			    switch (param[row]) {
			    case 5:
				row++;
				if (row &lt; nparam &amp;&amp;
				    param[row] &lt; NUM_ANSI_COLORS) {
				    xw-&gt;sgr_foreground = param[row];
				    xw-&gt;sgr_extended = True;
				    setExtendedFG(xw);
				}
				break;
			    default:
				row += 7;
				break;
			    }
			}
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>39</expr>:
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			reset_SGR_Foreground(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>40</expr>:
		</case><case>case <expr>41</expr>:
		</case><case>case <expr>42</expr>:
		</case><case>case <expr>43</expr>:
		</case><case>case <expr>44</expr>:
		</case><case>case <expr>45</expr>:
		</case><case>case <expr>46</expr>:
		</case><case>case <expr>47</expr>:
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			xw-&gt;sgr_background = (param[row] - 40);
			setExtendedBG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>48</expr>:
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			row++;
			if (row &lt; nparam) {
			    switch (param[row]) {
			    case 5:
				row++;
				if (row &lt; nparam &amp;&amp;
				    param[row] &lt; NUM_ANSI_COLORS) {
				    xw-&gt;sgr_background = param[row];
				    setExtendedBG(xw);
				}
				break;
			    default:
				row += 7;
				break;
			    }
			}
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>49</expr>:
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			reset_SGR_Background(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>90</expr>:
		</case><case>case <expr>91</expr>:
		</case><case>case <expr>92</expr>:
		</case><case>case <expr>93</expr>:
		</case><case>case <expr>94</expr>:
		</case><case>case <expr>95</expr>:
		</case><case>case <expr>96</expr>:
		</case><case>case <expr>97</expr>:
		    <macro><name>if_OPT_AIX_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			xw-&gt;sgr_foreground = (param[row] - 90 + 8);
			xw-&gt;sgr_extended = False;
			setExtendedFG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case><case>case <expr>100</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_AIX_COLORS</name></expr></cpp:if>
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			reset_SGR_Foreground(xw);
			reset_SGR_Background(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><case>case <expr>101</expr>:
		</case><case>case <expr>102</expr>:
		</case><case>case <expr>103</expr>:
		</case><case>case <expr>104</expr>:
		</case><case>case <expr>105</expr>:
		</case><case>case <expr>106</expr>:
		</case><case>case <expr>107</expr>:
		    <macro><name>if_OPT_AIX_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			xw-&gt;sgr_background = (param[row] - 100 + 8);
			setExtendedBG(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		    <break>break;</break>
		</case>}</block></switch>
	    }</block></for>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	    <comment type="block">/* DSR (except for the '?') is a superset of CPR */</comment>
	</case><case>case <expr><name>CASE_DSR</name></expr>:
	    <expr_stmt><expr><name>sp</name>-&gt;<name>private_function</name> = <name>True</name></expr>;</expr_stmt>

	    <comment type="block">/* FALLTHRU */</comment>
	</case><case>case <expr><name>CASE_CPR</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CPR - cursor position\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>sp</name>-&gt;<name>private_function</name> ? '?' : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'n'</expr>;</expr_stmt>

	    <switch>switch <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
	    <case>case <expr>5</expr>:
		<comment type="block">/* operating status */</comment>
		<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* (no malfunction ;-) */</comment>
		<break>break;</break>
	    </case><case>case <expr>6</expr>:
		<comment type="block">/* CPR */</comment>
		<comment type="block">/* DECXCPR (with page=0) */</comment>
		<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_row</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_col</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'R'</expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr>15</expr>:
		<comment type="block">/* printer status */</comment>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 200</expr>)</condition><then> <block>{	<comment type="block">/* VT220 */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 13</expr>;</expr_stmt>	<comment type="block">/* implement printer */</comment>
		}</block></then></if>
		<break>break;</break>
	    </case><case>case <expr>25</expr>:
		<comment type="block">/* UDK status */</comment>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 200</expr>)</condition><then> <block>{	<comment type="block">/* VT220 */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 20</expr>;</expr_stmt>	<comment type="block">/* UDK always unlocked */</comment>
		}</block></then></if>
		<break>break;</break>
	    </case><case>case <expr>26</expr>:
		<comment type="block">/* keyboard status */</comment>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 200</expr>)</condition><then> <block>{	<comment type="block">/* VT220 */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 27</expr>;</expr_stmt>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 1</expr>;</expr_stmt>		<comment type="block">/* North American */</comment>
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 400</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* ready */</comment>
			<expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* LK201 */</comment>
		    }</block></then></if>
		}</block></then></if>
		<break>break;</break>
	    </case><case>case <expr>53</expr>:
		<comment type="block">/* Locator status */</comment>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 200</expr>)</condition><then> <block>{	<comment type="block">/* VT220 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 50</expr>;</expr_stmt>	<comment type="block">/* locator ready */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr><name>count</name>++</expr>]</index></name> = 53</expr>;</expr_stmt>	<comment type="block">/* no locator */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></then></if>
		<break>break;</break>
	    </case><default>default:
		<break>break;</break>
	    </default>}</block></switch>

	    <if>if <condition>(<expr>(<name>reply</name>.<name>a_nparam</name> = (<name>ParmType</name>) <name>count</name>) != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>private_function</name> = <name>False</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_MC</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_MC - media control\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermMediaControl</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DEC_MC</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DEC_MC - DEC media control\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermMediaControl</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_HP_MEM_LOCK</name></expr>:
	</case><case>case <expr><name>CASE_HP_MEM_UNLOCK</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s\n", ((<name>sp</name>-&gt;<name><name>parsestate</name><index>[<expr><name>c</name></expr>]</index></name> == <name>CASE_HP_MEM_LOCK</name>)
			    ? "CASE_HP_MEM_LOCK"
			    : "CASE_HP_MEM_UNLOCK"))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>sp</name>-&gt;<name><name>parsestate</name><index>[<expr><name>c</name></expr>]</index></name> == <name>CASE_HP_MEM_LOCK</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>set_tb_margins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>bot_marg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><call><name>set_tb_margins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>bot_marg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSTBM</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSTBM - set scrolling region\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>top</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>top</name> = 1</expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>nparam</name> &lt; 2 || (<name>bot</name> = <name><name>param</name><index>[<expr>1</expr>]</index></name>) == <name>DEFAULT</name>
		|| <name>bot</name> &gt; <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
		|| <name>bot</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>bot</name> = <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <if>if <condition>(<expr><name>bot</name> &gt; <name>top</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>set_tb_margins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>top</name> - 1</expr></argument>, <argument><expr><name>bot</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECREQTPARM</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECREQTPARM\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &lt; 200</expr>)</condition><then> <block>{	<comment type="block">/* VT102 */</comment>
		<if>if <condition>(<expr>(<name>row</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) == <name>DEFAULT</name></expr>)</condition><then>
		    <expr_stmt><expr><name>row</name> = 0</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>row</name> == 0 || <name>row</name> == 1</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = 0</expr>;</expr_stmt>
		    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 7</expr>;</expr_stmt>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr><name>row</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = 1</expr>;</expr_stmt>	<comment type="block">/* no parity */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = 1</expr>;</expr_stmt>	<comment type="block">/* eight bits */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>3</expr>]</index></name> = 128</expr>;</expr_stmt>	<comment type="block">/* transmit 38.4k baud */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>4</expr>]</index></name> = 128</expr>;</expr_stmt>	<comment type="block">/* receive 38.4k baud */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>5</expr>]</index></name> = 1</expr>;</expr_stmt>	<comment type="block">/* clock multiplier ? */</comment>
		    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>6</expr>]</index></name> = 0</expr>;</expr_stmt>	<comment type="block">/* STP flags ? */</comment>
		    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
		    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 'x'</expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSET</name></expr>:
	    <comment type="block">/* DECSET */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> != 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>dpmodes</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>bitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	    <if>if <condition>(<expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>False</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECRST</name></expr>:
	    <comment type="block">/* DECRST */</comment>
	    <expr_stmt><expr><call><name>dpmodes</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>bitclr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>init_groundtable</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECALN</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECALN - alignment test\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>set_tb_margins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnFillRectangle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>, <argument><expr>'E'</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_GSETS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_GSETS(%d) = '%c'\n", <name>sp</name>-&gt;<name>scstype</name>, <name>c</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> != 0</expr>)</condition><then>
		<expr_stmt><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr><name>sp</name>-&gt;<name>scstype</name></expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSC</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSC - save cursor\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorSave</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECRC</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECRC - restore cursor\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorRestore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
		setExtendedFG(xw);
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECKPAM</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECKPAM\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> |= <name>MODE_DECKPAM</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_appkeypad</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECKPNM</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECKPNM\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>, <argument><expr><name>MODE_DECKPAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_appkeypad</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CSI_QUOTE_STATE</name></expr>:
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi_quo_table</name></expr>;</expr_stmt>
	    <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_CSI_SPACE_STATE</name></expr>:
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi_sp_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSCUSR</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSCUSR\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <block>{
		<decl_stmt><decl><type><name>Boolean</name></type> <name>change</name> =<init> <expr><name>True</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Boolean</name></type> <name>blinks</name> =<init> <expr><name>screen</name>-&gt;<name>cursor_blink</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
		<case>case <expr>0</expr>:
		</case><case>case <expr>1</expr>:
		</case><case>case <expr><name>DEFAULT</name></expr>:
		    <comment type="block">/* blinking block */</comment>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_underline</name> = <name>False</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>blinks</name> = <name>True</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>2</expr>:
		    <comment type="block">/* steady block */</comment>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_underline</name> = <name>False</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>blinks</name> = <name>False</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>3</expr>:
		    <comment type="block">/* blinking underline */</comment>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_underline</name> = <name>True</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>blinks</name> = <name>True</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>4</expr>:
		    <comment type="block">/* steady underline */</comment>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_underline</name> = <name>True</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>blinks</name> = <name>False</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><default>default:
		    <expr_stmt><expr><name>change</name> = <name>False</name></expr>;</expr_stmt>
		    <break>break;</break>
		</default>}</block></switch>

		<if>if <condition>(<expr><name>change</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>xtermSetCursorBox</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>SetCursorBlink</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>blinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_DECLL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECLL\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>nparam</name> &gt; 0</expr>)</condition><then> <block>{
		<for>for (<init><expr><name>count</name> = 0</expr>;</init> <condition><expr><name>count</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>count</name></expr></incr>) <block>{
		    <switch>switch <condition>(<expr><name><name>param</name><index>[<expr><name>count</name></expr>]</index></name></expr>)</condition> <block>{
		    <case>case <expr>0</expr>:
		    </case><case>case <expr><name>DEFAULT</name></expr>:
			<expr_stmt><expr><call><name>xtermClearLEDs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		    </case><case>case <expr>1</expr>:
		    </case><case>case <expr>2</expr>:
		    </case><case>case <expr>3</expr>:
			<expr_stmt><expr><call><name>xtermShowLED</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>Cardinal</name>) <name><name>param</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		    </case><case>case <expr>21</expr>:
		    </case><case>case <expr>22</expr>:
		    </case><case>case <expr>23</expr>:
			<expr_stmt><expr><call><name>xtermShowLED</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name><name>param</name><index>[<expr><name>count</name></expr>]</index></name> - 20</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		    </case>}</block></switch>
		}</block></for>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>xtermClearLEDs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_VT52_FINISH</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_VT52_FINISH terminal_id %d, vtXX_level %d\n",
		   <name>screen</name>-&gt;<name>terminal_id</name>,
		   <name>screen</name>-&gt;<name>vtXX_level</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 100
		&amp;&amp; <name>screen</name>-&gt;<name>vtXX_level</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>groundtable</name> =
		    <name>sp</name>-&gt;<name>parsestate</name> = <name>ansi_table</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>vtXX_level</name> = <name>screen</name>-&gt;<name>vt52_save_level</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = <name>screen</name>-&gt;<name>vt52_save_curgl</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>curgr</name> = <name>screen</name>-&gt;<name>vt52_save_curgr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>curss</name> = <name>screen</name>-&gt;<name>vt52_save_curss</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>gsets</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>vt52_save_gsets</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>gsets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><case>case <expr><name>CASE_ANSI_LEVEL_1</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_ANSI_LEVEL_1\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_ansi_conformance</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ANSI_LEVEL_2</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_ANSI_LEVEL_2\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_ansi_conformance</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ANSI_LEVEL_3</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_ANSI_LEVEL_3\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_ansi_conformance</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSCL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSCL(%d,%d)\n", <name><name>param</name><index>[<expr>0</expr>]</index></name>, <name><name>param</name><index>[<expr>1</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &gt;= 61 &amp;&amp; <name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 65</expr>)</condition><then> <block>{
		<comment type="block">/*
		 * VT300, VT420, VT520 manuals claim that DECSCL does a hard
		 * reset (RIS).  VT220 manual states that it is a soft reset.
		 * Perhaps both are right (unlikely).  Kermit says it's soft.
		 */</comment>
		<expr_stmt><expr><call><name>VTReset</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>vtXX_level</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name> - 60</expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &gt; 61</expr>)</condition><then> <block>{
		    <switch>switch <condition>(<expr><call><name>zero_if_default</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition> <block>{
		    <case>case <expr>1</expr>:
			<expr_stmt><expr><call><name>show_8bit_control</name><argument_list>(<argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		    </case><case>case <expr>0</expr>:
		    </case><case>case <expr>2</expr>:
			<expr_stmt><expr><call><name>show_8bit_control</name><argument_list>(<argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		    </case>}</block></switch>
		}</block></then></if>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSCA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSCA\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>DEC_PROTECT</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 0 || <name><name>param</name><index>[<expr>0</expr>]</index></name> == 2</expr>)</condition><then>
		<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>PROTECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> == 1</expr>)</condition><then>
		<expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> |= <name>PROTECTED</name></expr>;</expr_stmt></then></if></else></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSED</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSED\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>do_erase_display</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>DEC_PROTECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSEL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSEL\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>do_erase_line</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>DEC_PROTECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ST</name></expr>:
	    <macro><name>TRACE</name><argument_list>(<argument>("CASE_ST: End of String (%lu bytes)\n", (unsigned long) sp-&gt;string_used)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<name>sp</name>-&gt;<name>string_used</name></expr>)</condition><then>
		<break>break;</break></then></if>
	    <expr_stmt><expr><name>sp</name>-&gt;<name><name>string_area</name><index>[<expr>--(<name>sp</name>-&gt;<name>string_used</name>)</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	    <switch>switch <condition>(<expr><name>sp</name>-&gt;<name>string_mode</name></expr>)</condition> <block>{
	    <case>case <expr><name>ANSI_APC</name></expr>:
		<comment type="block">/* ignored */</comment>
		<break>break;</break>
	    </case><case>case <expr><name>ANSI_DCS</name></expr>:
		<expr_stmt><expr><call><name>do_dcs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_area</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr><name>ANSI_OSC</name></expr>:
		<expr_stmt><expr><call><name>do_osc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_area</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>string_used</name></expr></argument>, <argument><expr><name>ANSI_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr><name>ANSI_PM</name></expr>:
		<comment type="block">/* ignored */</comment>
		<break>break;</break>
	    </case><case>case <expr><name>ANSI_SOS</name></expr>:
		<comment type="block">/* ignored */</comment>
		<break>break;</break>
	    </case>}</block></switch>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SOS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SOS: Start of String\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>ParseSOS</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>string_mode</name> = <name>ANSI_SOS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>sos_table</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>illegal_parse</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_PM</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_PM: Privacy Message\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>ParseSOS</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>string_mode</name> = <name>ANSI_PM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>sos_table</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>illegal_parse</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DCS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DCS: Device Control String\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>string_mode</name> = <name>ANSI_DCS</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>sos_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_APC</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_APC: Application Program Command\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>ParseSOS</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>string_mode</name> = <name>ANSI_APC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>sos_table</name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>illegal_parse</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SPA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SPA - start protected area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>ISO_PROTECT</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> |= <name>PROTECTED</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_EPA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_EPA - end protected area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>PROTECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SU</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SU - scroll up\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>count</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>count</name> = 1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>xtermScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_IND</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_IND - index\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermIndex</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>do_xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CPL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CPL - cursor prev line\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorPrevLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CNL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_CNL - cursor next line\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorNextLine</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_NEL</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_NEL\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermIndex</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CarriageReturn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_HTS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_HTS - horizontal tab set\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TabSet</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>tabs</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_RI</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_RI - reverse index\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>RevIndex</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SS2</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SS2\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curss</name> = 2</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SS3</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SS3\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curss</name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CSI_STATE</name></expr>:
	    <comment type="block">/* enter csi state */</comment>
	    <expr_stmt><expr><name>nparam</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>param</name><index>[<expr>0</expr>]</index></name> = <name>DEFAULT</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_ESC_SP_STATE</name></expr>:
	    <comment type="block">/* esc space */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>esc_sp_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CSI_EX_STATE</name></expr>:
	    <comment type="block">/* csi exclamation */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi_ex_table</name></expr>;</expr_stmt>
	    <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_LOCATOR</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_CSI_TICK_STATE</name></expr>:
	    <comment type="block">/* csi tick (') */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi_tick_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECEFR</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECEFR - Enable Filter Rectangle\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>DEC_LOCATOR</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>screen</name>-&gt;<name>loc_filter_top</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_top</name> = <name>LOC_FILTER_POS</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>nparam</name> &lt; 2 || (<name>screen</name>-&gt;<name>loc_filter_left</name> = <name><name>param</name><index>[<expr>1</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_left</name> = <name>LOC_FILTER_POS</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>nparam</name> &lt; 3 || (<name>screen</name>-&gt;<name>loc_filter_bottom</name> = <name><name>param</name><index>[<expr>2</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_bottom</name> = <name>LOC_FILTER_POS</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>nparam</name> &lt; 4 || (<name>screen</name>-&gt;<name>loc_filter_right</name> = <name><name>param</name><index>[<expr>3</expr>]</index></name>) &lt; 1</expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter_right</name> = <name>LOC_FILTER_POS</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>InitLocatorFilter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECELR</name></expr>:
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 0 || <name><name>param</name><index>[<expr>0</expr>]</index></name> &gt; 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DECELR - Disable Locator Reports\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DECELR - Enable Locator Reports\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>DEC_LOCATOR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xtermShowPointer</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> == 2</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>screen</name>-&gt;<name>locator_reset</name> = <name>True</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><name>screen</name>-&gt;<name>locator_reset</name> = <name>False</name></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>nparam</name> &lt; 2 || <name><name>param</name><index>[<expr>1</expr>]</index></name> != 1</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>screen</name>-&gt;<name>locator_pixels</name> = <name>False</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><name>screen</name>-&gt;<name>locator_pixels</name> = <name>True</name></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter</name> = <name>False</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSLE</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DECSLE - Select Locator Events\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>count</name> = 0</expr>;</init> <condition><expr><name>count</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>count</name></expr></incr>) <block>{
		<switch>switch <condition>(<expr><name><name>param</name><index>[<expr><name>count</name></expr>]</index></name></expr>)</condition> <block>{
		<case>case <expr><name>DEFAULT</name></expr>:
		</case><case>case <expr>0</expr>:
		    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>loc_filter</name> = <name>False</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>locator_events</name> = 0</expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>1</expr>:
		    <expr_stmt><expr><name>screen</name>-&gt;<name>locator_events</name> |= <name>LOC_BTNS_DN</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>2</expr>:
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>locator_events</name></expr></argument>, <argument><expr><name>LOC_BTNS_DN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>3</expr>:
		    <expr_stmt><expr><name>screen</name>-&gt;<name>locator_events</name> |= <name>LOC_BTNS_UP</name></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>4</expr>:
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>locator_events</name></expr></argument>, <argument><expr><name>LOC_BTNS_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case>}</block></switch>
	    }</block></for>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECRQLP</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DECRQLP - Request Locator Position\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &lt; 2</expr>)</condition><then> <block>{
		<comment type="block">/* Issue DECLRP Locator Position Report */</comment>
		<expr_stmt><expr><call><name>GetLocatorPosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_LOCATOR */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_RECTOPS</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_CSI_DOLLAR_STATE</name></expr>:
	    <comment type="block">/* csi dollar ($) */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> &gt;= 4</expr>)</condition><then>
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi_dollar_table</name></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>eigtable</name></expr>;</expr_stmt></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CSI_STAR_STATE</name></expr>:
	    <comment type="block">/* csi dollar (*) */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> &gt;= 4</expr>)</condition><then>
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>csi_star_table</name></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>eigtable</name></expr>;</expr_stmt></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECCRA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECCRA - Copy rectangular area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>nparam</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnCopyRectangle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>, <argument><expr><name>nparam</name> - 5</expr></argument>, <argument><expr><name>param</name> + 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECERA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECERA - Erase rectangular area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>nparam</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnFillRectangle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>, <argument><expr>' '</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECFRA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECFRA - Fill rectangular area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>nparam</name> &gt; 0
		&amp;&amp; ((<name><name>param</name><index>[<expr>0</expr>]</index></name> &gt;= 32 &amp;&amp; <name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 126)
		    || (<name><name>param</name><index>[<expr>0</expr>]</index></name> &gt;= 160 &amp;&amp; <name><name>param</name><index>[<expr>0</expr>]</index></name> &lt;= 255))</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>nparam</name> - 1</expr></argument>, <argument><expr><name>param</name> + 1</expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScrnFillRectangle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSERA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSERA - Selective erase rectangular area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>nparam</name> &gt; 4 ? 4 : <name>nparam</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnWipeRectangle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSACE</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSACE - Select attribute change extent\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>cur_decsace</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECCARA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECCARA - Change attributes in rectangular area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>nparam</name> &gt; 4 ? 4 : <name>nparam</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnMarkRectangle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>, <argument><expr><name>False</name></expr></argument>, <argument><expr><name>nparam</name> - 4</expr></argument>, <argument><expr><name>param</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECRARA</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECRARA - Reverse attributes in rectangular area\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>nparam</name> &gt; 4 ? 4 : <name>nparam</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ScrnMarkRectangle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>myRect</name></expr></argument>, <argument><expr><name>True</name></expr></argument>, <argument><expr><name>nparam</name> - 4</expr></argument>, <argument><expr><name>param</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	</case><case>case <expr><name>CASE_CSI_DOLLAR_STATE</name></expr>:
	    <comment type="block">/* csi dollar ($) */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>eigtable</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CSI_STAR_STATE</name></expr>:
	    <comment type="block">/* csi dollar (*) */</comment>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>eigtable</name></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_RECTOPS */</comment>

	</case><case>case <expr><name>CASE_S7C1T</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_S7C1T\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>show_8bit_control</name><argument_list>(<argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_S8C1T</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_S8C1T\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>vtXX_level</name> &lt;= 1</expr>)</condition><then>
		<break>break;</break></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><call><name>show_8bit_control</name><argument_list>(<argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_OSC</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_OSC: Operating System Command\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>sos_table</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>string_mode</name> = <name>ANSI_OSC</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_RIS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_RIS\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>VTReset</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSTR</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSTR\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>VTReset</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_REP</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_REP\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>sp</name>-&gt;<name>lastchar</name> &gt;= 0 &amp;&amp;
		<name>sp</name>-&gt;<name>lastchar</name> &lt; 256 &amp;&amp;
		<name>sp</name>-&gt;<name><name>groundtable</name><index>[<expr><call><name>E2A</name><argument_list>(<argument><expr><name>sp</name>-&gt;<name>lastchar</name></expr></argument>)</argument_list></call></expr>]</index></name> == <name>CASE_PRINT</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>IChar</name></type> <name><name>repeated</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><name>count</name> = (<name><name>param</name><index>[<expr>0</expr>]</index></name> &lt; 1) ? 1 : <name><name>param</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repeated</name><index>[<expr>0</expr>]</index></name> = (<name>IChar</name>) <name>sp</name>-&gt;<name>lastchar</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>count</name>-- &gt; 0</expr>)</condition> <block>{
		    <expr_stmt><expr><call><name>dotext</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name><name>gsets</name><index>[<expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>curgl</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>,
			   <argument><expr><name>repeated</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_LS2</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_LS2\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = 2</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_LS3</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_LS3\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgl</name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_LS3R</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_LS3R\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgr</name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_LS2R</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_LS2R\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgr</name> = 2</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_LS1R</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_LS1R\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>curgr</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_XTERM_SAVE</name></expr>:
	    <expr_stmt><expr><call><name>savemodes</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_XTERM_RESTORE</name></expr>:
	    <expr_stmt><expr><call><name>restoremodes</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_XTERM_WINOPS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_XTERM_WINOPS\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>window_ops</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_ESC_PERCENT</name></expr>:
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>esc_pct_table</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_UTF8</name></expr>:
	    <comment type="block">/* If we did not set UTF-8 mode from resource or the
	     * command-line, allow it to be enabled/disabled by
	     * control sequence.
	     */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name>
		&amp;&amp; <name>screen</name>-&gt;<name>utf8_mode</name> != <name>uAlways</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>WriteNow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>ChangeToWide</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>switchPtyData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>c</name> == 'G'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("UTF8 mode %s\n",
		       <call><name>BtoS</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>utf8_mode</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("UTF8 mode NOT turned %s (%s)\n",
		       <call><name>BtoS</name><argument_list>(<argument><expr><name>c</name> == 'G'</expr></argument>)</argument_list></call>,
		       (<name>screen</name>-&gt;<name>utf8_mode</name> == <name>uAlways</name>)
		       ? "UTF-8 mode set from command-line"
		       : "wideChars resource was not set")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
	</case><case>case <expr><name>CASE_SET_MOD_FKEYS</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SET_MOD_FKEYS\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>nparam</name> &gt;= 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_mod_fkeys</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>nparam</name> &gt; 1 ? <name><name>param</name><index>[<expr>1</expr>]</index></name> : <name>DEFAULT</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<for>for (<init><expr><name>row</name> = 1</expr>;</init> <condition><expr><name>row</name> &lt;= 5</expr>;</condition> <incr><expr>++<name>row</name></expr></incr>)
		    <expr_stmt><expr><call><name>set_mod_fkeys</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>DEFAULT</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	    }</block></else></if>
	    <break>break;</break>
	</case><case>case <expr><name>CASE_SET_MOD_FKEYS0</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SET_MOD_FKEYS0\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>nparam</name> &gt;= 1 &amp;&amp; <name><name>param</name><index>[<expr>0</expr>]</index></name> != <name>DEFAULT</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_mod_fkeys</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>modify_now</name>.<name>function_keys</name> = -1</expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr><name>CASE_HIDE_POINTER</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_HIDE_POINTER\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>nparam</name> &gt;= 1 &amp;&amp; <name><name>param</name><index>[<expr>0</expr>]</index></name> != <name>DEFAULT</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>pointer_mode</name> = <name><name>param</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>pointer_mode</name> = <name>DEF_POINTER_MODE</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_SM_TITLE</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_SM_TITLE\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>nparam</name> &gt;= 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		    <if>if <condition>(<expr><name><name>param</name><index>[<expr><name>n</name></expr>]</index></name> != <name>DEFAULT</name></expr>)</condition><then>
			<expr_stmt><expr><name>screen</name>-&gt;<name>title_modes</name> |= (1 &lt;&lt; <name><name>param</name><index>[<expr><name>n</name></expr>]</index></name>)</expr>;</expr_stmt></then></if>
		}</block></for>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>title_modes</name> = <name>DEF_TITLE_MODES</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...title_modes %#x\n", <name>screen</name>-&gt;<name>title_modes</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_RM_TITLE</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_RM_TITLE\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>nparam</name> &gt;= 1</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		    <if>if <condition>(<expr><name><name>param</name><index>[<expr><name>n</name></expr>]</index></name> != <name>DEFAULT</name></expr>)</condition><then>
			<expr_stmt><expr><name>screen</name>-&gt;<name>title_modes</name> &amp;= ~(1 &lt;&lt; <name><name>param</name><index>[<expr><name>n</name></expr>]</index></name>)</expr>;</expr_stmt></then></if>
		}</block></for>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>title_modes</name> = <name>DEF_TITLE_MODES</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...title_modes %#x\n", <name>screen</name>-&gt;<name>title_modes</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_CSI_IGNORE</name></expr>:
	    <expr_stmt><expr><name>sp</name>-&gt;<name>parsestate</name> = <name>cigtable</name></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSWBV</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSWBV\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <switch>switch <condition>(<expr>(<name>nparam</name> &gt;= 1) ? <name><name>param</name><index>[<expr>0</expr>]</index></name> : <name>DEFAULT</name></expr>)</condition> <block>{
	    <case>case <expr>2</expr>:
	    </case><case>case <expr>3</expr>:
	    </case><case>case <expr>4</expr>:
		<expr_stmt><expr><name>screen</name>-&gt;<name>warningVolume</name> = <name>bvLow</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr>5</expr>:
	    </case><case>case <expr>6</expr>:
	    </case><case>case <expr>7</expr>:
	    </case><case>case <expr>8</expr>:
		<expr_stmt><expr><name>screen</name>-&gt;<name>warningVolume</name> = <name>bvHigh</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><default>default:
		<expr_stmt><expr><name>screen</name>-&gt;<name>warningVolume</name> = <name>bvOff</name></expr>;</expr_stmt>
		<break>break;</break>
	    </default>}</block></switch>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...warningVolume %d\n", <name>screen</name>-&gt;<name>warningVolume</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr><name>CASE_DECSMBV</name></expr>:
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("CASE_DECSMBV\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <switch>switch <condition>(<expr>(<name>nparam</name> &gt;= 1) ? <name><name>param</name><index>[<expr>0</expr>]</index></name> : <name>DEFAULT</name></expr>)</condition> <block>{
	    <case>case <expr>2</expr>:
	    </case><case>case <expr>3</expr>:
	    </case><case>case <expr>4</expr>:
		<expr_stmt><expr><name>screen</name>-&gt;<name>marginVolume</name> = <name>bvLow</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><case>case <expr>0</expr>:
	    </case><case>case <expr><name>DEFAULT</name></expr>:
	    </case><case>case <expr>5</expr>:
	    </case><case>case <expr>6</expr>:
	    </case><case>case <expr>7</expr>:
	    </case><case>case <expr>8</expr>:
		<expr_stmt><expr><name>screen</name>-&gt;<name>marginVolume</name> = <name>bvHigh</name></expr>;</expr_stmt>
		<break>break;</break>
	    </case><default>default:
		<expr_stmt><expr><name>screen</name>-&gt;<name>marginVolume</name> = <name>bvOff</name></expr>;</expr_stmt>
		<break>break;</break>
	    </default>}</block></switch>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...marginVolume %d\n", <name>screen</name>-&gt;<name>marginVolume</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ResetState</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case>}</block></switch>
	<if>if <condition>(<expr><name>sp</name>-&gt;<name>parsestate</name> == <name>sp</name>-&gt;<name>groundtable</name></expr>)</condition><then>
	    <expr_stmt><expr><name>sp</name>-&gt;<name>lastchar</name> = <name>thischar</name></expr>;</expr_stmt></then></if>
    }</block> while <condition>(<expr>0</expr>)</condition>;</do>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_inparse</name> = <call>(<name>Boolean</name>) <argument_list>(<argument><expr>(<name>screen</name>-&gt;<name>utf8_mode</name> != <name>uFalse</name>)
				      &amp;&amp; (<name>sp</name>-&gt;<name>parsestate</name> != <name>sos_table</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>True</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>VTparse</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name></decl>;</decl_stmt>

    <comment type="block">/* We longjmp back to this point in VTReset() */</comment>
    <expr_stmt><expr>(<name>void</name>) <call><name>setjmp</name><argument_list>(<argument><expr><name>vtjmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>myState</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>myState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>myState</name>.<name>scssize</name> = 94</expr>;</expr_stmt>	<comment type="block">/* number of printable/nonspace ASCII */</comment>
    <expr_stmt><expr><name>myState</name>.<name>lastchar</name> = -1</expr>;</expr_stmt>	<comment type="block">/* not a legal IChar */</comment>
    <expr_stmt><expr><name>myState</name>.<name>nextstate</name> = -1</expr>;</expr_stmt>	<comment type="block">/* not a legal state */</comment>

    <expr_stmt><expr><call><name>init_groundtable</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;<name>myState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>myState</name>.<name>parsestate</name> = <name>myState</name>.<name>groundtable</name></expr>;</expr_stmt>

    <do>do <block>{
    }</block> while <condition>(<expr><call><name>doparsing</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>doinput</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>myState</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
}</block></function>

<decl_stmt><decl><type><name>static</name> <name>Char</name> *</type><name>v_buffer</name></decl>;</decl_stmt>		<comment type="block">/* pointer to physical buffer */</comment>
<decl_stmt><decl><type><name>static</name> <name>Char</name> *</type><name>v_bufstr</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* beginning of area to write */</comment>
<decl_stmt><decl><type><name>static</name> <name>Char</name> *</type><name>v_bufptr</name></decl>;</decl_stmt>		<comment type="block">/* end of area to write */</comment>
<decl_stmt><decl><type><name>static</name> <name>Char</name> *</type><name>v_bufend</name></decl>;</decl_stmt>		<comment type="block">/* end of physical buffer */</comment>

<comment type="block">/* Write data to the pty as typed by the user, pasted with the mouse,
   or generated by us in response to a query ESC sequence. */</comment>

<function><type><name>void</name></type>
<name>v_write</name><parameter_list>(<param><decl><type><name>int</name></type> <name>f</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>data</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>riten</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("v_write(%d:%s)\n", <name>len</name>, <call><name>visibleChars</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>v_bufstr</name> == <name>NULL</name> &amp;&amp; <name>len</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>v_buffer</name> = (<name>Char</name> *) <call><name>XtMalloc</name><argument_list>(<argument><expr>(<name>Cardinal</name>) <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_bufstr</name> = <name>v_buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_bufptr</name> = <name>v_buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_bufend</name> = <name>v_buffer</name> + <name>len</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"v_write called with %d bytes (%d left over)"</expr></argument>,
		<argument><expr><name>len</name></expr></argument>, <argument><expr><name>v_bufptr</name> - <name>v_bufstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>len</name> &gt; 1 &amp;&amp; <name>len</name> &lt; 10</expr>)</condition><then>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" \"%.*s\""</expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>(<name>char</name> *) <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
    <if>if <condition>(<expr>(1 &lt;&lt; <name>f</name>) != <name>pty_mask</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>tt_write</name><argument_list>(<argument><expr>(<name>char</name> *) <name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* VMS */</comment>
    <if>if <condition>(<expr>!<call><name>FD_ISSET</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>&amp;<name>pty_mask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>IGNORE_RC</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>(<name>char</name> *) <name>data</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>

    <comment type="block">/*
     * Append to the block we already have.
     * Always doing this simplifies the code, and
     * isn't too bad, either.  If this is a short
     * block, it isn't too expensive, and if this is
     * a long block, we won't be able to write it all
     * anyway.
     */</comment>

    <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DABBREV</name></expr></cpp:if>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call>-&gt;<name>dabbrev_working</name> = <name>False</name></expr>;</expr_stmt>	<comment type="block">/* break dabbrev sequence */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>v_bufend</name> &lt; <name>v_bufptr</name> + <name>len</name></expr>)</condition><then> <block>{	<comment type="block">/* we've run out of room */</comment>
	    <if>if <condition>(<expr><name>v_bufstr</name> != <name>v_buffer</name></expr>)</condition><then> <block>{
		<comment type="block">/* there is unused space, move everything down */</comment>
		<comment type="block">/* possibly overlapping memmove here */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
		<if>if <condition>(<expr><name>debug</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"moving data down %d\n"</expr></argument>,
			    <argument><expr><name>v_bufstr</name> - <name>v_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>v_buffer</name></expr></argument>, <argument><expr><name>v_bufstr</name></expr></argument>, <argument><expr><call>(<name>size_t</name>) <argument_list>(<argument><expr><name>v_bufptr</name> - <name>v_bufstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_bufptr</name> -= <name>v_bufstr</name> - <name>v_buffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_bufstr</name> = <name>v_buffer</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>v_bufend</name> &lt; <name>v_bufptr</name> + <name>len</name></expr>)</condition><then> <block>{
		<comment type="block">/* still won't fit: get more space */</comment>
		<comment type="block">/* Don't use XtRealloc because an error is not fatal. */</comment>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>size</name> =<init> <expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>v_bufptr</name> - <name>v_buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>v_buffer</name> = <call><name>TypeRealloc</name><argument_list>(<argument><expr><name>Char</name></expr></argument>, <argument><expr><name>size</name> + <name>len</name></expr></argument>, <argument><expr><name>v_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v_buffer</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
		    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"expanded buffer to %d\n"</expr></argument>,
				<argument><expr><name>size</name> + <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    <expr_stmt><expr><name>v_bufstr</name> = <name>v_buffer</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>v_bufptr</name> = <name>v_buffer</name> + <name>size</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>v_bufend</name> = <name>v_bufptr</name> + <name>len</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <comment type="block">/* no memory: ignore entire write request */</comment>
		    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: cannot allocate buffer space\n"</expr></argument>,
			    <argument><expr><name>xterm_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>v_buffer</name> = <name>v_bufstr</name></expr>;</expr_stmt>	<comment type="block">/* restore clobbered pointer */</comment>
		}</block></else></if>
	    }</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>v_bufend</name> &gt;= <name>v_bufptr</name> + <name>len</name></expr>)</condition><then> <block>{
	    <comment type="block">/* new stuff will fit */</comment>
	    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>v_bufptr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>v_bufptr</name> += <name>len</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * Write out as much of the buffer as we can.
     * Be careful not to overflow the pty's input silo.
     * We are conservative here and only write
     * a small amount at a time.
     *
     * If we can't push all the data into the pty yet, we expect write
     * to return a non-negative number less than the length requested
     * (if some data written) or -1 and set errno to EAGAIN,
     * EWOULDBLOCK, or EINTR (if no data written).
     *
     * (Not all systems do this, sigh, so the code is actually
     * a little more forgiving.)
     */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_PTY_WRITE</name> 128</cpp:define>	<comment type="block">/* 1/2 POSIX minimum MAX_INPUT */</comment>

    <if>if <condition>(<expr><name>v_bufptr</name> &gt; <name>v_bufstr</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
	<expr_stmt><expr><name>riten</name> = <call><name>tt_write</name><argument_list>(<argument><expr><name>v_bufstr</name></expr></argument>,
			 <argument><expr>((<name>v_bufptr</name> - <name>v_bufstr</name> &lt;= <name>VMS_TERM_BUFFER_SIZE</name>)
			  ? <name>v_bufptr</name> - <name>v_bufstr</name>
			  : <name>VMS_TERM_BUFFER_SIZE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>riten</name> == 0</expr>)</condition><then>
	    <return>return <expr>(<name>riten</name>)</expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* VMS */</comment>
	<expr_stmt><expr><name>riten</name> = (<name>int</name>) <call><name>write</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>v_bufstr</name></expr></argument>,
			    <argument><expr><call>(<name>size_t</name>) <argument_list>(<argument><expr>(<name>v_bufptr</name> - <name>v_bufstr</name> &lt;= <name>MAX_PTY_WRITE</name>)
				      ? <name>v_bufptr</name> - <name>v_bufstr</name>
				      : <name>MAX_PTY_WRITE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>riten</name> &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>
	<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"write"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><name>riten</name> = 0</expr>;</expr_stmt>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<if>if <condition>(<expr><name>debug</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"write called with %d, wrote %d\n"</expr></argument>,
		    <argument><expr><name>v_bufptr</name> - <name>v_bufstr</name> &lt;= <name>MAX_PTY_WRITE</name> ?
		    <name>v_bufptr</name> - <name>v_bufstr</name> : <name>MAX_PTY_WRITE</name></expr></argument>,
		    <argument><expr><name>riten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>v_bufstr</name> += <name>riten</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v_bufstr</name> &gt;= <name>v_bufptr</name></expr>)</condition><then>	<comment type="block">/* we wrote it all */</comment>
	    <expr_stmt><expr><name>v_bufstr</name> = <name>v_bufptr</name> = <name>v_buffer</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <comment type="block">/*
     * If we have lots of unused memory allocated, return it
     */</comment>
    <if>if <condition>(<expr><name>v_bufend</name> - <name>v_bufptr</name> &gt; 1024</expr>)</condition><then> <block>{	<comment type="block">/* arbitrary hysteresis */</comment>
	<comment type="block">/* save pointers across realloc */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>v_bufstr</name> - <name>v_buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>v_bufptr</name> - <name>v_buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>allocsize</name> =<init> <expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>size</name> ? <name>size</name> : 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>v_buffer</name> = <call><name>TypeRealloc</name><argument_list>(<argument><expr><name>Char</name></expr></argument>, <argument><expr><name>allocsize</name></expr></argument>, <argument><expr><name>v_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v_buffer</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>v_bufstr</name> = <name>v_buffer</name> + <name>start</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>v_bufptr</name> = <name>v_buffer</name> + <name>size</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>v_bufend</name> = <name>v_buffer</name> + <name>allocsize</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"shrunk buffer to %d\n"</expr></argument>, <argument><expr><name>allocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
	    <comment type="block">/* should we print a warning if couldn't return memory? */</comment>
	    <expr_stmt><expr><name>v_buffer</name> = <name>v_bufstr</name> - <name>start</name></expr>;</expr_stmt>	<comment type="block">/* restore clobbered pointer */</comment>
	}</block></else></if>
    }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive>	<name>ptymask</name>()	(v_bufptr &gt; v_bufstr ? pty_mask : 0)</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>in_put</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>PtySelect</name></type> <name>select_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>PtySelect</name></type> <name>write_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>update</name> =<init> <expr><name>VTbuffer</name>-&gt;<name>update</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Dimension</name></type> <name>replyWidth</name>, <name>replyHeight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtGeometryResult</name></type> <name>stat</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>select_mask</name> = <name>pty_mask</name></expr>;</expr_stmt>	<comment type="block">/* force initial read */</comment>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{

	<comment type="block">/* if the terminal changed size, resize the widget */</comment>
	<if>if <condition>(<expr><name>tt_changed</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>tt_changed</name> = <name>False</name></expr>;</expr_stmt>

	    <expr_stmt><expr><name>stat</name> = <call><name>REQ_RESIZE</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>,
			      <argument><expr>((<name>Dimension</name>) <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
			       * (<name>tt_width</name>)
			       + 2 * <name>screen</name>-&gt;<name>border</name>
			       + <name>screen</name>-&gt;<name>fullVwin</name>.<name>sb_info</name>.<name>width</name>)</expr></argument>,
			      <argument><expr>((<name>Dimension</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
			       * (<name>tt_length</name>)
			       + 2 * <name>screen</name>-&gt;<name>border</name>)</expr></argument>,
			      <argument><expr>&amp;<name>replyWidth</name></expr></argument>, <argument><expr>&amp;<name>replyHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><name>stat</name> == <name>XtGeometryYes</name> || <name>stat</name> == <name>XtGeometryDone</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>xw</name>-&gt;<name>core</name>.<name>width</name> = <name>replyWidth</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xw</name>-&gt;<name>core</name>.<name>height</name> = <name>replyHeight</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScreenResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>replyWidth</name></expr></argument>, <argument><expr><name>replyHeight</name></expr></argument>, <argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><call><name>repairSizeHints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> == <name>NORMAL</name>
	    &amp;&amp; <call><name>readPtyData</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>, <argument><expr><name>VTbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scrollWidget</name>
		&amp;&amp; <name>screen</name>-&gt;<name>scrollttyoutput</name>
		&amp;&amp; <name>screen</name>-&gt;<name>topline</name> &lt; 0</expr>)</condition><then>
		<comment type="block">/* Scroll to bottom */</comment>
		<expr_stmt><expr><call><name>WindowScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <break>break;</break>
	}</block></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_set</name> &amp;&amp; <call><name>CursorMoved</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>ShowCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
	    <expr_stmt><expr><call><name>PreeditPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_set</name> != <name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_set</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>ShowCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if></else></if>

	<if>if <condition>(<expr><call><name>QLength</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>select_mask</name> = <name>X_mask</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>write_mask</name> = <call><name>ptymask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XFlush</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>select_mask</name> = <name>Select_mask</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> != <name>NORMAL</name></expr>)</condition><then>
		<expr_stmt><expr><name>select_mask</name> = <name>X_mask</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>write_mask</name> &amp; <call><name>ptymask</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* flush buffer */</comment>
	}</block></then></if>

	<if>if <condition>(<expr><name>select_mask</name> &amp; <name>X_mask</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>VTbuffer</name>-&gt;<name>update</name> != <name>update</name></expr>)</condition><then>
		<break>break;</break></then></if>
	}</block></then></if>
    }</block></for>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* VMS */</comment>

<function><type><name>static</name> <name>void</name></type>
<name>in_put</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>PtySelect</name></type> <name>select_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>PtySelect</name></type> <name>write_mask</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>time_select</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>update</name> =<init> <expr><name>VTbuffer</name>-&gt;<name>update</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>static</name> struct <name>timeval</name></type> <name>select_timeout</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
    <comment type="block">/*
     * Compute the timeout for the blinking cursor to be much smaller than
     * the "on" or "off" interval.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>tick</name> =<init> <expr>((<name>screen</name>-&gt;<name>blink_on</name> &lt; <name>screen</name>-&gt;<name>blink_off</name>)
		? <name>screen</name>-&gt;<name>blink_on</name>
		: <name>screen</name>-&gt;<name>blink_off</name>)</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>tick</name> *= (1000 / 8)</expr>;</expr_stmt>		<comment type="block">/* 1000 for msec/usec, 8 for "much" smaller */</comment>
    <if>if <condition>(<expr><name>tick</name> &lt; 1</expr>)</condition><then>
	<expr_stmt><expr><name>tick</name> = 1</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> == <name>NORMAL</name>
	    &amp;&amp; (<name>size</name> = <call><name>readPtyData</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>, <argument><expr><name>VTbuffer</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scrollWidget</name>
		&amp;&amp; <name>screen</name>-&gt;<name>scrollttyoutput</name>
		&amp;&amp; <name>screen</name>-&gt;<name>topline</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>WindowScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="block">/* Scroll to bottom */</comment>
	    <comment type="block">/* stop speed reading at some point to look for X stuff */</comment>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTbuffer uses %ld/%d\n",
		   <call>(<name>long</name>) <argument_list>(<argument><expr><name>VTbuffer</name>-&gt;<name>last</name> - <name>VTbuffer</name>-&gt;<name>buffer</name></expr></argument>)</argument_list></call>,
		   <name>BUF_SIZE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>VTbuffer</name>-&gt;<name>last</name> - <name>VTbuffer</name>-&gt;<name>buffer</name>) &gt; <name>BUF_SIZE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>FD_CLR</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SCHED_YIELD</name></expr></argument>)</argument_list></call></expr></cpp:if>
	    <comment type="block">/*
	     * If we've read a full (small/fragment) buffer, let the operating
	     * system have a turn, and we'll resume reading until we've either
	     * read only a fragment of the buffer, or we've filled the large
	     * buffer (see above).  Doing this helps keep up with large bursts
	     * of output.
	     */</comment>
	    <if>if <condition>(<expr><name>size</name> == <name>FRG_SIZE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>select_timeout</name>.<name>tv_sec</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> = <call><name>Select</name><argument_list>(<argument><expr><name>max_plus1</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>, <argument><expr>&amp;<name>write_mask</name></expr></argument>, <argument><expr>0</expr></argument>,
			   <argument><expr>&amp;<name>select_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>sched_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else
		    <break>break;</break></else></if>
	    }</block></then> <else>else <block>{
		<break>break;</break>
	    }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <expr_stmt><expr>(<name>void</name>) <name>size</name></expr>;</expr_stmt>	<comment type="block">/* unused in this branch */</comment>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<comment type="block">/* update the screen */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_set</name> &amp;&amp; <call><name>CursorMoved</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>ShowCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
	    <expr_stmt><expr><call><name>PreeditPosition</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_set</name> != <name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_set</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>ShowCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></then></if></else></if>

	<expr_stmt><expr><call><name>XFlush</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* always flush writes before waiting */</comment>

	<comment type="block">/* Update the masks and, unless X events are already in the queue,
	   wait for I/O to be possible. */</comment>
	<expr_stmt><expr><call><name>XFD_COPYSET</name><argument_list>(<argument><expr>&amp;<name>Select_mask</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* in selection mode xterm does not read pty */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> != <name>NORMAL</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>FD_CLR</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>v_bufptr</name> &gt; <name>v_bufstr</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XFD_COPYSET</name><argument_list>(<argument><expr>&amp;<name>pty_mask</name></expr></argument>, <argument><expr>&amp;<name>write_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else
	    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>write_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>select_timeout</name>.<name>tv_sec</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>time_select</name> = 0</expr>;</expr_stmt>

	<comment type="block">/*
	 * if there's either an XEvent or an XtTimeout pending, just take
	 * a quick peek, i.e. timeout from the select() immediately.  If
	 * there's nothing pending, let select() block a little while, but
	 * for a shorter interval than the arrow-style scrollbar timeout.
	 * The blocking is optional, because it tends to increase the load
	 * on the host.
	 */</comment>
	<if>if <condition>(<expr><call><name>XtAppPending</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>select_timeout</name>.<name>tv_usec</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>time_select</name> = 1</expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>awaitInput</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>select_timeout</name>.<name>tv_usec</name> = 50000</expr>;</expr_stmt>
	    <expr_stmt><expr><name>time_select</name> = 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
	}</block></then> <else>else <if>if <condition>(<expr>(<name>screen</name>-&gt;<name>blink_timer</name> != 0 &amp;&amp;
		    ((<name>screen</name>-&gt;<name>select</name> &amp; <name>FOCUS</name>) || <name>screen</name>-&gt;<name>always_highlight</name>)) ||
		   (<name>screen</name>-&gt;<name>cursor_state</name> == <name>BLINKED_OFF</name>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>select_timeout</name>.<name>tv_usec</name> = <name>tick</name></expr>;</expr_stmt>
	    <while>while <condition>(<expr><name>select_timeout</name>.<name>tv_usec</name> &gt; 1000000</expr>)</condition> <block>{
		<expr_stmt><expr><name>select_timeout</name>.<name>tv_usec</name> -= 1000000</expr>;</expr_stmt>
		<expr_stmt><expr><name>select_timeout</name>.<name>tv_sec</name>++</expr>;</expr_stmt>
	    }</block></while>
	    <expr_stmt><expr><name>time_select</name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SESSION_MGT</name></expr></cpp:if>
	}</block></then> <else>else <if>if <condition>(<expr><name>resource</name>.<name>sessionMgt</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>ice_fd</name> &gt;= 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>ice_fd</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if></else></if></else></if></else></if>
	<if>if <condition>(<expr><name>need_cleanup</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>Cleanup</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>i</name> = <call><name>Select</name><argument_list>(<argument><expr><name>max_plus1</name></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>, <argument><expr>&amp;<name>write_mask</name></expr></argument>, <argument><expr>0</expr></argument>,
		   <argument><expr>(<name>time_select</name> ? &amp;<name>select_timeout</name> : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>errno</name> != <name>EINTR</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <continue>continue;</continue>
	}</block></then></if>

	<comment type="block">/* if there is room to write more data to the pty, go write more */</comment>
	<if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>&amp;<name>write_mask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>v_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr>(<name>Char</name> *) 0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* flush buffer */</comment>
	}</block></then></if>

	<comment type="block">/* if there are X events already in our queue, it
	   counts as being readable */</comment>
	<if>if <condition>(<expr><call><name>XtAppPending</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>)</argument_list></call> ||
	    <call><name>FD_ISSET</name><argument_list>(<argument><expr><call><name>ConnectionNumber</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>select_mask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>VTbuffer</name>-&gt;<name>update</name> != <name>update</name></expr>)</condition><then>	<comment type="block">/* HandleInterpret */</comment>
		<break>break;</break></then></if>
	}</block></then></if>

    }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>

<function><type><name>static</name> <name>IChar</name></type>
<name>doinput</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>!<call><name>morePtyData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>VTbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<expr_stmt><expr><call><name>in_put</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <return>return <expr><call><name>nextPtyData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>VTbuffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
<comment type="block">/*
 *  For OverTheSpot, client has to inform the position for XIM preedit.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>PreeditPosition</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPoint</name></type> <name>spot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XVaNestedList</name></type> <name>list</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>xic</name>
	&amp;&amp; (<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>spot</name>.<name>x</name> = (<name>short</name>) <call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>spot</name>.<name>y</name> = <call>(<name>short</name>) <argument_list>(<argument><expr><call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>fs_ascent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>list</name> = <call><name>XVaCreateNestedList</name><argument_list>(<argument><expr>0</expr></argument>,
				   <argument><expr><name>XNSpotLocation</name></expr></argument>, <argument><expr>&amp;<name>spot</name></expr></argument>,
				   <argument><expr><name>XNForeground</name></expr></argument>, <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>XNBackground</name></expr></argument>, <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XSetICValues</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xic</name></expr></argument>, <argument><expr><name>XNPreeditAttributes</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XFree</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>void</name></type>
<name>WrapLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ld</name> != 0</expr>)</condition><then> <block>{
	<comment type="block">/* mark that we had to wrap this line */</comment>
	<expr_stmt><expr><call><name>LineSetFlag</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>LINEWRAPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermAutoPrint</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermIndex</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_cur_col</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * process a string of characters according to the character set indicated
 * by charset.  worry about end of line conditions (wraparound if selected).
 */</comment>
<function><type><name>void</name></type>
<name>dotext</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
       <param><decl><type><name>int</name></type> <name>charset</name></decl></param>,
       <param><decl><type><name>IChar</name> *</type> <name>buf</name></decl></param>,		<comment type="block">/* start of characters to process */</comment>
       <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>)</parameter_list>		<comment type="block">/* end */</comment>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>chars_chomped</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>next_col</name> =<init> <expr><name>screen</name>-&gt;<name>cur_col</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>next_col</name>, <name>last_col</name>, <name>this_col</name></decl>;</decl_stmt>	<comment type="block">/* must be signed */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>offset</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <comment type="block">/* don't translate if we use UTF-8, and are not handling legacy support
     * for line-drawing characters.
     */</comment>
    <if>if <condition>(<expr>(<name>screen</name>-&gt;<name>utf8_mode</name> == <name>uFalse</name>)
	|| (<name>screen</name>-&gt;<name>vt100_graphics</name>)</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<call><name>xtermCharSetOut</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> + <name>len</name></expr></argument>, <argument><expr><name>charset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <return>return;</return></then></if></then></if>

    <macro><name>if_OPT_XMC_GLITCH</name><argument_list>(<argument>screen</argument>, <argument>{
	Cardinal n;
	if (charset != '?') {
	    for (n = 0; n &lt; len; n++) {
		if (buf[n] == XMC_GLITCH)
		    buf[n] = XMC_GLITCH + 1;
	    }
	}
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <for>for (<init><expr><name>offset</name> = 0</expr>;</init>
	 <condition><expr><name>offset</name> &lt; <name>len</name> &amp;&amp; (<name>chars_chomped</name> &gt; 0 || <name>screen</name>-&gt;<name>do_wrap</name>)</expr>;</condition>
	 <incr><expr><name>offset</name> += <name>chars_chomped</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>width_available</name> =<init> <expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>width_here</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Boolean</name></type> <name>need_wrap</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>last_chomp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>chars_chomped</name> = 0</expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>do_wrap</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>xw</name>-&gt;<name>flags</name> &amp; <name>WRAPAROUND</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>WrapLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>width_available</name> = <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next_col</name> = <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>

	<while>while <condition>(<expr><name>width_here</name> &lt;= <name>width_available</name> &amp;&amp; <name>chars_chomped</name> &lt; (<name>len</name> - <name>offset</name>)</expr>)</condition> <block>{
	    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>utf8_mode</name>
		|| (<name>screen</name>-&gt;<name>vt100_graphics</name> &amp;&amp; <name>charset</name> == '0')</expr>)</condition><then>
		<expr_stmt><expr><name>last_chomp</name> = 1</expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>last_chomp</name> = <call><name>my_wcwidth</name><argument_list>(<argument><expr>(<name>int</name>) <name><name>buf</name><index>[<expr><name>chars_chomped</name> + <name>offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	    <expr_stmt><expr><name>width_here</name> += <name>last_chomp</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>chars_chomped</name>++</expr>;</expr_stmt>
	}</block></while>

	<if>if <condition>(<expr><name>width_here</name> &gt; <name>width_available</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>last_chomp</name> &gt; <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<break>break;</break></then></if>		<comment type="block">/* give up - it is too big */</comment>
	    <expr_stmt><expr><name>chars_chomped</name>--</expr>;</expr_stmt>
	    <expr_stmt><expr><name>width_here</name> -= <name>last_chomp</name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>chars_chomped</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>need_wrap</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>width_here</name> == <name>width_available</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>need_wrap</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>chars_chomped</name> != (<name>len</name> - <name>offset</name>)</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>need_wrap</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if></else></if></else></if>

	<comment type="block">/*
	 * Split the wide characters back into separate arrays of 8-bit
	 * characters so we can use the existing interface.
	 *
	 * FIXME:  If we rewrote this interface, it would involve
	 * rewriting all of the memory-management for the screen
	 * buffers (perhaps this is simpler).
	 */</comment>
	<if>if <condition>(<expr><name>chars_chomped</name> != 0 &amp;&amp; <name>next_col</name> &lt;= <name>screen</name>-&gt;<name>max_col</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>WriteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name> + <name>offset</name></expr></argument>, <argument><expr><name>chars_chomped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>next_col</name> += <name>width_here</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>need_wrap</name></expr>;</expr_stmt>
    }</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* ! OPT_WIDE_CHARS */</comment>

    <for>for (<init><expr><name>offset</name> = 0</expr>;</init> <condition><expr><name>offset</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>offset</name> += <name>this_col</name></expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>last_col</name> = <call><name>LineMaxCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>this_col</name> = <name>last_col</name> - <name>screen</name>-&gt;<name>cur_col</name> + 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>this_col</name> &lt;= 1</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>do_wrap</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>xw</name>-&gt;<name>flags</name> &amp; <name>WRAPAROUND</name>)</expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>WrapLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
	    <expr_stmt><expr><name>this_col</name> = 1</expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>offset</name> + <name>this_col</name> &gt; <name>len</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>this_col</name> = <name>len</name> - <name>offset</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>next_col</name> = <name>screen</name>-&gt;<name>cur_col</name> + <name>this_col</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WriteText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name> + <name>offset</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>this_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The call to WriteText updates screen-&gt;cur_col.
	 * If screen-&gt;cur_col is less than next_col, we must have
	 * hit the right margin - so set the do_wrap flag.
	 */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = (<name>screen</name>-&gt;<name>cur_col</name> &lt; <name>next_col</name>)</expr>;</expr_stmt>
    }</block></for>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_WIDE_CHARS */</comment>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<function><type><name>unsigned</name></type>
<name>visual_width</name><parameter_list>(<param><decl><type><name>IChar</name> *</type> <name>str</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* returns the visual width of a string (doublewide characters count
       as 2, normalwide characters count as 1) */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>my_len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ch</name> =<init> <expr>(<name>int</name>) *<name>str</name>++</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>isWide</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>my_len</name> += 2</expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>my_len</name>++</expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>my_len</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HANDLE_STRUCT_NOTIFY</name></expr></cpp:if>
<comment type="block">/* Flag icon name with "***" on window output when iconified.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>HandleStructNotify</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>XtPointer</name> <name>closure</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,
		   <param><decl><type><name>Boolean</name> * <name>cont</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>icon_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>Arg</name></type> <name><name>args</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr><block>{<expr><name>XtNiconName</name></expr>, <expr>(<name>XtArgVal</name>) &amp; <name>icon_name</name></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>event</name>-&gt;<name>type</name></expr>)</condition> <block>{
    <case>case <expr><name>MapNotify</name></expr>:
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleStructNotify(MapNotify)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ZICONBEEP</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>zIconBeep_flagged</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>zIconBeep_flagged</name> = <name>False</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>icon_name</name> = <name>NULL</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XtGetValues</name><argument_list>(<argument><expr><name>toplevel</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>XtNumber</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>icon_name</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> =<init> <expr><call><name>CastMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>icon_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>screen</name>-&gt;<name>zIconBeep_flagged</name> = <name>True</name></expr>;</expr_stmt>
		    <return>return;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>icon_name</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ChangeIconName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_ZICONBEEP */</comment>
	<expr_stmt><expr><name>mapstate</name> = !<name>IsUnmapped</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>UnmapNotify</name></expr>:
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleStructNotify(UnmapNotify)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapstate</name> = <name>IsUnmapped</name></expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>ConfigureNotify</name></expr>:
	<if>if <condition>(<expr><name>event</name>-&gt;<name>xconfigure</name>.<name>window</name> == <call><name>XtWindow</name><argument_list>(<argument><expr><name>toplevel</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_TOOLBAR</name></expr></cpp:if>
	    <decl_stmt><decl><type><name>int</name></type> <name>height</name>, <name>width</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>height</name> = <name>event</name>-&gt;<name>xconfigure</name>.<name>height</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>width</name> = <name>event</name>-&gt;<name>xconfigure</name>.<name>width</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleStructNotify(ConfigureNotify) %d,%d %dx%d\n",
		   <name>event</name>-&gt;<name>xconfigure</name>.<name>y</name>, <name>event</name>-&gt;<name>xconfigure</name>.<name>x</name>,
		   <name>event</name>-&gt;<name>xconfigure</name>.<name>height</name>, <name>event</name>-&gt;<name>xconfigure</name>.<name>width</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
	    <comment type="block">/*
	     * The notification is for the top-level widget, but we care about
	     * vt100 (ignore the tek4014 window).
	     */</comment>
	    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>Vshow</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>VTwin</name> *</type><name>Vwin</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TbInfo</name> *</type><name>info</name> =<init> <expr>&amp;(<name>Vwin</name>-&gt;<name>tb_info</name>)</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TbInfo</name></type> <name>save</name> =<init> <expr>*<name>info</name></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>info</name>-&gt;<name>menu_bar</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>XtVaGetValues</name><argument_list>(<argument><expr><name>info</name>-&gt;<name>menu_bar</name></expr></argument>,
				  <argument><expr><name>XtNheight</name></expr></argument>, <argument><expr>&amp;<name>info</name>-&gt;<name>menu_height</name></expr></argument>,
				  <argument><expr><name>XtNborderWidth</name></expr></argument>, <argument><expr>&amp;<name>info</name>-&gt;<name>menu_border</name></expr></argument>,
				  <argument><expr>(<name>XtPointer</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <if>if <condition>(<expr><name>save</name>.<name>menu_height</name> != <name>info</name>-&gt;<name>menu_height</name>
			|| <name>save</name>.<name>menu_border</name> != <name>info</name>-&gt;<name>menu_border</name></expr>)</condition><then> <block>{

			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...menu_height %d\n", <name>info</name>-&gt;<name>menu_height</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...menu_border %d\n", <name>info</name>-&gt;<name>menu_border</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...had height  %d, border %d\n",
			       <name>save</name>.<name>menu_height</name>,
			       <name>save</name>.<name>menu_border</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * FIXME:  Window manager still may be using the old
			 * values.  Try to fool it.
			 */</comment>
			<expr_stmt><expr><call><name>REQ_RESIZE</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>,
				   <argument><expr><name>screen</name>-&gt;<name>fullVwin</name>.<name>fullwidth</name></expr></argument>,
				   <argument><expr><call>(<name>Dimension</name>) <argument_list>(<argument><expr><name>info</name>-&gt;<name>menu_height</name>
						- <name>save</name>.<name>menu_height</name>
						+ <name>screen</name>-&gt;<name>fullVwin</name>.<name>fullheight</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>repairSizeHints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
		}</block></then></if>
	    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <if>if <condition>(<expr><name>height</name> != <name>xw</name>-&gt;<name>hints</name>.<name>height</name> || <name>width</name> != <name>xw</name>-&gt;<name>hints</name>.<name>width</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>RequestResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_TOOLBAR */</comment>
	}</block></then></if>
	<break>break;</break>
    </case><case>case <expr><name>ReparentNotify</name></expr>:
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleStructNotify(ReparentNotify)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case><default>default:
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HandleStructNotify(event %s)\n",
	       <call><name>visibleEventType</name><argument_list>(<argument><expr><name>event</name>-&gt;<name>type</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </default>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HANDLE_STRUCT_NOTIFY */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>SetCursorBlink</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>enable</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_blink</name> = (<name>Boolean</name>) <name>enable</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>DoStartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>StartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_BLINK_TEXT</name></expr></cpp:if>
	<expr_stmt><expr><call><name>StopBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
    <expr_stmt><expr><call><name>update_cursorblink</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>ToggleCursorBlink</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>SetCursorBlink</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call>(<name>Bool</name>) <argument_list>(<argument><expr>!(<name>screen</name>-&gt;<name>cursor_blink</name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * process ANSI modes set, reset
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ansi_modes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>BitFunc</name></type> <name>func</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<switch>switch <condition>(<expr><name><name>param</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
	<case>case <expr>2</expr>:		<comment type="block">/* KAM (if set, keyboard locked */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>, <argument><expr><name>MODE_KAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr>4</expr>:		<comment type="block">/* IRM                          */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr>12</expr>:		<comment type="block">/* SRM (if set, local echo      */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>, <argument><expr><name>MODE_SRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr>20</expr>:		<comment type="block">/* LNM                          */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>LINEFEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_autolinefeed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case>}</block></switch>
    }</block></for>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsSM</name>() (func == bitset)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>set_bool_mode</name>(flag) \
	flag = (Boolean) IsSM()</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>really_set_mousemode</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		     <param><decl><type><name>Bool</name></type> <name>enabled</name></decl></param>,
		     <param><decl><type><name>XtermMouseModes</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>send_mouse_pos</name> = <name>enabled</name> ? <name>mode</name> : <name>MOUSE_OFF</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>send_mouse_pos</name> != <name>MOUSE_OFF</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>xtermShowPointer</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>set_mousemode</name>(mode) really_set_mousemode(xw, IsSM(), mode)</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>set_mouseflag</name>(f)		\
	(IsSM()				\
	 ? SCREEN_FLAG_set(screen, f)	\
	 : SCREEN_FLAG_unset(screen, f))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * process DEC private modes set, reset
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>dpmodes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>BitFunc</name></type> <name>func</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>myflags</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s %d\n", <call><name>IsSM</name><argument_list>()</argument_list></call>? "DECSET" : "DECRST", <name><name>param</name><index>[<expr><name>i</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>param</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
	<case>case <expr>1</expr>:		<comment type="block">/* DECCKM                       */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>, <argument><expr><name>MODE_DECCKM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_appcursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>2</expr>:		<comment type="block">/* DECANM - ANSI/VT52 mode      */</comment>
	    <if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* ANSI (VT100) */</comment>
		<comment type="block">/*
		 * Setting DECANM should have no effect, since this function
		 * cannot be reached from vt52 mode.
		 */</comment>
		<empty_stmt>;</empty_stmt>
	    }</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_VT52_MODE</name></expr></cpp:if>
	    <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>terminal_id</name> &gt;= 100</expr>)</condition><then> <block>{	<comment type="block">/* VT52 */</comment>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DECANM terminal_id %d, vtXX_level %d\n",
		       <name>screen</name>-&gt;<name>terminal_id</name>,
		       <name>screen</name>-&gt;<name>vtXX_level</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>vt52_save_level</name> = <name>screen</name>-&gt;<name>vtXX_level</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>vtXX_level</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>vt52_save_curgl</name> = <name>screen</name>-&gt;<name>curgl</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>vt52_save_curgr</name> = <name>screen</name>-&gt;<name>curgr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>vt52_save_curss</name> = <name>screen</name>-&gt;<name>curss</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>vt52_save_gsets</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>gsets</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>gsets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetCharsets</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nparam</name> = 0</expr>;</expr_stmt>	<comment type="block">/* ignore the remaining params, if any */</comment>
	    }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <break>break;</break>
	</case><case>case <expr>3</expr>:		<comment type="block">/* DECCOLM                      */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>c132</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ClearScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>j</name> = <call><name>IsSM</name><argument_list>()</argument_list></call>? 132 : 80) !=
		    ((<name>xw</name>-&gt;<name>flags</name> &amp; <name>IN132COLUMNS</name>) ? 132 : 80) ||
		    <name>j</name> != <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><call><name>RequestResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>IN132COLUMNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
	</case><case>case <expr>4</expr>:		<comment type="block">/* DECSCLM (slow scroll)        */</comment>
	    <if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>jumpscroll</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    }</block></then> <else>else
		<expr_stmt><expr><name>screen</name>-&gt;<name>jumpscroll</name> = 1</expr>;</expr_stmt></else></if>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>SMOOTHSCROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_jumpscroll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>5</expr>:		<comment type="block">/* DECSCNM                      */</comment>
	    <expr_stmt><expr><name>myflags</name> = <name>xw</name>-&gt;<name>flags</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>REVERSE_VIDEO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>(<name>xw</name>-&gt;<name>flags</name> ^ <name>myflags</name>) &amp; <name>REVERSE_VIDEO</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>ReverseVideo</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <comment type="block">/* update_reversevideo done in RevVid */</comment>
	    <break>break;</break>

	</case><case>case <expr>6</expr>:		<comment type="block">/* DECOM                        */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr>7</expr>:		<comment type="block">/* DECAWM                       */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>WRAPAROUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_autowrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>8</expr>:		<comment type="block">/* DECARM                       */</comment>
	    <comment type="block">/* ignore autorepeat
	     * XAutoRepeatOn() and XAutoRepeatOff() can do this, but only
	     * for the whole display - not limited to a given window.
	     */</comment>
	    <break>break;</break>
	</case><case>case <expr><name>SET_X10_MOUSE</name></expr>:	<comment type="block">/* MIT bogus sequence           */</comment>
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_mousemode</name><argument_list>(<argument><expr><name>X10_MOUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
	</case><case>case <expr>10</expr>:		<comment type="block">/* rxvt */</comment>
	    <expr_stmt><expr><call><name>ShowToolbar</name><argument_list>(<argument><expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
	</case><case>case <expr>12</expr>:		<comment type="block">/* att610: Start/stop blinking cursor */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_blink_res</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cursor_blink_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetCursorBlink</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursor_blink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>18</expr>:		<comment type="block">/* DECPFF: print form feed */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>printer_formfeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>19</expr>:		<comment type="block">/* DECPEX: print extent */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>printer_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>25</expr>:		<comment type="block">/* DECTCEM: Show/hide cursor (VT200) */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cursor_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>30</expr>:		<comment type="block">/* rxvt */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>fullVwin</name>.<name>sb_info</name>.<name>width</name> != (<call><name>IsSM</name><argument_list>()</argument_list></call>? <name>ON</name> : <name>OFF</name>)</expr>)</condition><then>
		<expr_stmt><expr><call><name>ToggleScrollBar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
	</case><case>case <expr>35</expr>:		<comment type="block">/* rxvt */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>shift_fonts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>38</expr>:		<comment type="block">/* DECTEK                       */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
	    <if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call> &amp;&amp; !(<name>screen</name>-&gt;<name>inhibit</name> &amp; <name>I_TEK</name>)</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>FlushLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEK4014_ACTIVE</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call> = <name>True</name></expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <break>break;</break>
	</case><case>case <expr>40</expr>:		<comment type="block">/* 132 column mode              */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>c132</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_allow132</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>41</expr>:		<comment type="block">/* curses hack                  */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>curses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_cursesemul</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>42</expr>:		<comment type="block">/* DECNRCM national charset (VT220) */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>NATIONAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>44</expr>:		<comment type="block">/* margin bell                  */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>marginbell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>marginbell</name></expr>)</condition><then>
		<expr_stmt><expr><name>screen</name>-&gt;<name>bellArmed</name> = -1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>update_marginbell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>45</expr>:		<comment type="block">/* reverse wraparound   */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>REVERSEWRAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_reversewrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
	</case><case>case <expr>46</expr>:		<comment type="block">/* logging              */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGFILEONOFF</name></cpp:ifdef>
	    <comment type="block">/*
	     * if this feature is enabled, logging may be
	     * enabled and disabled via escape sequences.
	     */</comment>
	    <if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>StartLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><call><name>CloseLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_Info</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ALLOWLOGFILEONOFF */</comment>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1049</expr>:		<comment type="block">/* alternate buffer &amp; cursor */</comment>
	    <if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>titeInhibit</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>CursorSave</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>ToAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>ClearScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><call><name>FromAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>CursorRestore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	    }</block></then> <else>else <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>tiXtraScroll</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>xtermScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if></else></if>
	    <break>break;</break>
	</case><case>case <expr>1047</expr>:
	    <comment type="block">/* FALLTHRU */</comment>
	</case><case>case <expr>47</expr>:		<comment type="block">/* alternate buffer */</comment>
	    <if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>titeInhibit</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>ToAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>whichBuf</name>
			&amp;&amp; (<name><name>param</name><index>[<expr><name>i</name></expr>]</index></name> == 1047)</expr>)</condition><then>
			<expr_stmt><expr><call><name>ClearScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		    <expr_stmt><expr><call><name>FromAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	    }</block></then> <else>else <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>tiXtraScroll</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>xtermScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if></else></if>
	    <break>break;</break>
	</case><case>case <expr>66</expr>:		<comment type="block">/* DECNKM */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>, <argument><expr><name>MODE_DECKPAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_appkeypad</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>67</expr>:		<comment type="block">/* DECBKM */</comment>
	    <comment type="block">/* back-arrow mapped to backspace or delete(D) */</comment>
	    <expr_stmt><expr><call>(*<name>func</name>) <argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>, <argument><expr><name>MODE_DECBKM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DECSET DECBKM %s\n",
		   <call><name>BtoS</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> &amp; <name>MODE_DECBKM</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_decbkm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_VT200_MOUSE</name></expr>:	<comment type="block">/* xterm bogus sequence         */</comment>
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_mousemode</name><argument_list>(<argument><expr><name>VT200_MOUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_VT200_HIGHLIGHT_MOUSE</name></expr>:	<comment type="block">/* xterm sequence w/hilite tracking */</comment>
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_mousemode</name><argument_list>(<argument><expr><name>VT200_HIGHLIGHT_MOUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_BTN_EVENT_MOUSE</name></expr>:
	    <expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>set_mousemode</name><argument_list>(<argument><expr><name>BTN_EVENT_MOUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_ANY_EVENT_MOUSE</name></expr>:
	    <expr_stmt><expr><call><name>set_mousemode</name><argument_list>(<argument><expr><name>ANY_EVENT_MOUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>send_mouse_pos</name> == <name>MOUSE_OFF</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>MotionOff</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>MotionOn</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FOCUS_EVENT</name></expr></cpp:if>
	</case><case>case <expr><name>SET_FOCUS_EVENT_MOUSE</name></expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>send_focus_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1010</expr>:		<comment type="block">/* rxvt */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollttyoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_scrollttyoutput</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>1011</expr>:		<comment type="block">/* rxvt */</comment>
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_scrollkey</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>1034</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>input_eight_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_alt_esc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
	</case><case>case <expr>1035</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>real_NumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_num_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>1036</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>meta_sends_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_meta_esc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1037</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>delete_is_del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_delete_del</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
	</case><case>case <expr>1039</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>alt_sends_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_alt_esc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1040</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>keepSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_keepSelection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>1041</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>selectToClipboard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_selectToClipboard</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>1042</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>bellIsUrgent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_bellIsUrgent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>1043</expr>:
	    <expr_stmt><expr><call><name>set_bool_mode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>poponbell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_poponbell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>1048</expr>:
	    <if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>titeInhibit</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><call><name>CursorSave</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
		    <expr_stmt><expr><call><name>CursorRestore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	    }</block></then></if>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TCAP_FKEYS</name></expr></cpp:if>
	</case><case>case <expr>1050</expr>:
	    <expr_stmt><expr><call><name>set_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>keyboardIsTermcap</name></expr></argument>, <argument><expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUN_FUNC_KEYS</name></expr></cpp:if>
	</case><case>case <expr>1051</expr>:
	    <expr_stmt><expr><call><name>set_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>keyboardIsSun</name></expr></argument>, <argument><expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HP_FUNC_KEYS</name></expr></cpp:if>
	</case><case>case <expr>1052</expr>:
	    <expr_stmt><expr><call><name>set_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>keyboardIsHP</name></expr></argument>, <argument><expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCO_FUNC_KEYS</name></expr></cpp:if>
	</case><case>case <expr>1053</expr>:
	    <expr_stmt><expr><call><name>set_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>keyboardIsSCO</name></expr></argument>, <argument><expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1060</expr>:
	    <expr_stmt><expr><call><name>set_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>keyboardIsLegacy</name></expr></argument>, <argument><expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
	</case><case>case <expr>1061</expr>:
	    <expr_stmt><expr><call><name>set_keyboard_type</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>keyboardIsVT220</name></expr></argument>, <argument><expr><call><name>IsSM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	</case><case>case <expr><name>SET_BUTTON1_MOVE_POINT</name></expr>:
	    <expr_stmt><expr><call><name>set_mouseflag</name><argument_list>(<argument><expr><name>click1_moves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_BUTTON2_MOVE_POINT</name></expr>:
	    <expr_stmt><expr><call><name>set_mouseflag</name><argument_list>(<argument><expr><name>paste_moves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_DBUTTON3_DELETE</name></expr>:
	    <expr_stmt><expr><call><name>set_mouseflag</name><argument_list>(<argument><expr><name>dclick3_deletes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_IN_BRACKET</name></expr>:
	    <expr_stmt><expr><call><name>set_mouseflag</name><argument_list>(<argument><expr><name>paste_brackets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_QUOTE</name></expr>:
	    <expr_stmt><expr><call><name>set_mouseflag</name><argument_list>(<argument><expr><name>paste_quotes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_LITERAL_NL</name></expr>:
	    <expr_stmt><expr><call><name>set_mouseflag</name><argument_list>(<argument><expr><name>paste_literal_nl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>
	</case>}</block></switch>
    }</block></for>
}</block></function>

<comment type="block">/*
 * process xterm private modes save
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>savemodes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("savemodes %d\n", <name><name>param</name><index>[<expr><name>i</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>param</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
	<case>case <expr>1</expr>:		<comment type="block">/* DECCKM                       */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_DECCKM</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> &amp; <name>MODE_DECCKM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>3</expr>:		<comment type="block">/* DECCOLM                      */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>c132</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_DECCOLM</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>IN132COLUMNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <break>break;</break>
	</case><case>case <expr>4</expr>:		<comment type="block">/* DECSCLM (slow scroll)        */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_DECSCLM</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>SMOOTHSCROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>5</expr>:		<comment type="block">/* DECSCNM                      */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_DECSCNM</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>REVERSE_VIDEO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>6</expr>:		<comment type="block">/* DECOM                        */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_DECOM</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>7</expr>:		<comment type="block">/* DECAWM                       */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_DECAWM</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>WRAPAROUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>8</expr>:		<comment type="block">/* DECARM                       */</comment>
	    <comment type="block">/* ignore autorepeat */</comment>
	    <break>break;</break>
	</case><case>case <expr><name>SET_X10_MOUSE</name></expr>:	<comment type="block">/* mouse bogus sequence */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_X10MSE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>send_mouse_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
	</case><case>case <expr>10</expr>:		<comment type="block">/* rxvt */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_TOOLBAR</name></expr></argument>, <argument><expr><name>resource</name>.<name>toolBar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
	</case><case>case <expr>12</expr>:		<comment type="block">/* att610: Start/stop blinking cursor */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_blink_res</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_CRS_BLINK</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursor_blink_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>18</expr>:		<comment type="block">/* DECPFF: print form feed */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_PRN_FORMFEED</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>printer_formfeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>19</expr>:		<comment type="block">/* DECPEX: print extent */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_PRN_EXTENT</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>printer_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>25</expr>:		<comment type="block">/* DECTCEM: Show/hide cursor (VT200) */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_CRS_VISIBLE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursor_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>40</expr>:		<comment type="block">/* 132 column mode              */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_DECCOLM</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>c132</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>41</expr>:		<comment type="block">/* curses hack                  */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_MORE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>curses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>42</expr>:		<comment type="block">/* DECNRCM national charset (VT220) */</comment>
	    <comment type="block">/* do nothing */</comment>
	    <break>break;</break>
	</case><case>case <expr>44</expr>:		<comment type="block">/* margin bell                  */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_MARGIN</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>marginbell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>45</expr>:		<comment type="block">/* reverse wraparound   */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_REVWRAP</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>REVERSEWRAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
	</case><case>case <expr>46</expr>:		<comment type="block">/* logging              */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_LOGGING</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>logging</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1047</expr>:		<comment type="block">/* alternate buffer             */</comment>
	    <comment type="block">/* FALLTHRU */</comment>
	</case><case>case <expr>47</expr>:		<comment type="block">/* alternate buffer             */</comment>
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_ALTSCRN</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>whichBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_VT200_MOUSE</name></expr>:	<comment type="block">/* mouse bogus sequence         */</comment>
	</case><case>case <expr><name>SET_VT200_HIGHLIGHT_MOUSE</name></expr>:
	</case><case>case <expr><name>SET_BTN_EVENT_MOUSE</name></expr>:
	</case><case>case <expr><name>SET_ANY_EVENT_MOUSE</name></expr>:
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_MOUSE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>send_mouse_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FOCUS_EVENT</name></expr></cpp:if>
	</case><case>case <expr><name>SET_FOCUS_EVENT_MOUSE</name></expr>:
	    <expr_stmt><expr><call><name>DoSM</name><argument_list>(<argument><expr><name>DP_X_FOCUS</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>send_focus_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1048</expr>:
	    <if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>titeInhibit</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>CursorSave</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	</case><case>case <expr><name>SET_BUTTON1_MOVE_POINT</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_save</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>click1_moves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_BUTTON2_MOVE_POINT</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_save</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_moves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_DBUTTON3_DELETE</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_save</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dclick3_deletes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_IN_BRACKET</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_save</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_brackets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_QUOTE</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_save</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_quotes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_LITERAL_NL</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_save</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_literal_nl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>
	</case>}</block></switch>
    }</block></for>
}</block></function>

<comment type="block">/*
 * process xterm private modes restore
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>restoremodes</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("restoremodes %d\n", <name><name>param</name><index>[<expr><name>i</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>param</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
	<case>case <expr>1</expr>:		<comment type="block">/* DECCKM                       */</comment>
	    <expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>,
		   <argument><expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECCKM</name></expr>]</index></name></expr></argument>, <argument><expr><name>MODE_DECCKM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_appcursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>3</expr>:		<comment type="block">/* DECCOLM                      */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>c132</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ClearScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>j</name> = (<name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECCOLM</name></expr>]</index></name> &amp; <name>IN132COLUMNS</name>)
		     ? 132 : 80) != ((<name>xw</name>-&gt;<name>flags</name> &amp; <name>IN132COLUMNS</name>)
				     ? 132 : 80) || <name>j</name> != <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><call><name>RequestResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECCOLM</name></expr>]</index></name></expr></argument>,
		       <argument><expr><name>IN132COLUMNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
	</case><case>case <expr>4</expr>:		<comment type="block">/* DECSCLM (slow scroll)        */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECSCLM</name></expr>]</index></name> &amp; <name>SMOOTHSCROLL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>jumpscroll</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    }</block></then> <else>else
		<expr_stmt><expr><name>screen</name>-&gt;<name>jumpscroll</name> = 1</expr>;</expr_stmt></else></if>
	    <expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECSCLM</name></expr>]</index></name></expr></argument>, <argument><expr><name>SMOOTHSCROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_jumpscroll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>5</expr>:		<comment type="block">/* DECSCNM                      */</comment>
	    <if>if <condition>(<expr>(<name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECSCNM</name></expr>]</index></name> ^ <name>xw</name>-&gt;<name>flags</name>) &amp; <name>REVERSE_VIDEO</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECSCNM</name></expr>]</index></name></expr></argument>, <argument><expr><name>REVERSE_VIDEO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReverseVideo</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* update_reversevideo done in RevVid */</comment>
	    }</block></then></if>
	    <break>break;</break>
	</case><case>case <expr>6</expr>:		<comment type="block">/* DECOM                        */</comment>
	    <expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECOM</name></expr>]</index></name></expr></argument>, <argument><expr><name>ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>

	</case><case>case <expr>7</expr>:		<comment type="block">/* DECAWM                       */</comment>
	    <expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_DECAWM</name></expr>]</index></name></expr></argument>, <argument><expr><name>WRAPAROUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_autowrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>8</expr>:		<comment type="block">/* DECARM                       */</comment>
	    <comment type="block">/* ignore autorepeat */</comment>
	    <break>break;</break>
	</case><case>case <expr><name>SET_X10_MOUSE</name></expr>:	<comment type="block">/* MIT bogus sequence           */</comment>
	    <expr_stmt><expr><call><name>DoRM0</name><argument_list>(<argument><expr><name>DP_X_X10MSE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>send_mouse_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
	</case><case>case <expr>10</expr>:		<comment type="block">/* rxvt */</comment>
	    <expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_TOOLBAR</name></expr></argument>, <argument><expr><name>resource</name>.<name>toolBar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ShowToolbar</name><argument_list>(<argument><expr><name>resource</name>.<name>toolBar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
	</case><case>case <expr>12</expr>:		<comment type="block">/* att610: Start/stop blinking cursor */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_blink_res</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_CRS_BLINK</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursor_blink_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetCursorBlink</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursor_blink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>18</expr>:		<comment type="block">/* DECPFF: print form feed */</comment>
	    <expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_PRN_FORMFEED</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>printer_formfeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>19</expr>:		<comment type="block">/* DECPEX: print extent */</comment>
	    <expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_PRN_EXTENT</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>printer_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>25</expr>:		<comment type="block">/* DECTCEM: Show/hide cursor (VT200) */</comment>
	    <expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_CRS_VISIBLE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursor_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>40</expr>:		<comment type="block">/* 132 column mode              */</comment>
	    <expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_X_DECCOLM</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>c132</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_allow132</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>41</expr>:		<comment type="block">/* curses hack                  */</comment>
	    <expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_X_MORE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>curses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_cursesemul</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>44</expr>:		<comment type="block">/* margin bell                  */</comment>
	    <if>if <condition>(<expr>(<call><name>DoRM</name><argument_list>(<argument><expr><name>DP_X_MARGIN</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>marginbell</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
		<expr_stmt><expr><name>screen</name>-&gt;<name>bellArmed</name> = -1</expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>update_marginbell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>45</expr>:		<comment type="block">/* reverse wraparound   */</comment>
	    <expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_X_REVWRAP</name></expr>]</index></name></expr></argument>, <argument><expr><name>REVERSEWRAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>update_reversewrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
	</case><case>case <expr>46</expr>:		<comment type="block">/* logging              */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGFILEONOFF</name></cpp:ifdef>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_X_LOGGING</name></expr>]</index></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>StartLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><call><name>CloseLog</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ALLOWLOGFILEONOFF */</comment>
	    <comment type="block">/* update_logging done by StartLog and CloseLog */</comment>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1047</expr>:		<comment type="block">/* alternate buffer */</comment>
	    <comment type="block">/* FALLTHRU */</comment>
	</case><case>case <expr>47</expr>:		<comment type="block">/* alternate buffer */</comment>
	    <if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>titeInhibit</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_X_ALTSCRN</name></expr>]</index></name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>ToAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
		    <expr_stmt><expr><call><name>FromAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<comment type="block">/* update_altscreen done by ToAlt and FromAlt */</comment>
	    }</block></then> <else>else <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>tiXtraScroll</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name><name>save_modes</name><index>[<expr><name>DP_X_ALTSCRN</name></expr>]</index></name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>xtermScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if></else></if>
	    <break>break;</break>
	</case><case>case <expr><name>SET_VT200_MOUSE</name></expr>:	<comment type="block">/* mouse bogus sequence         */</comment>
	</case><case>case <expr><name>SET_VT200_HIGHLIGHT_MOUSE</name></expr>:
	</case><case>case <expr><name>SET_BTN_EVENT_MOUSE</name></expr>:
	</case><case>case <expr><name>SET_ANY_EVENT_MOUSE</name></expr>:
	    <expr_stmt><expr><call><name>DoRM0</name><argument_list>(<argument><expr><name>DP_X_MOUSE</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>send_mouse_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FOCUS_EVENT</name></expr></cpp:if>
	</case><case>case <expr><name>SET_FOCUS_EVENT_MOUSE</name></expr>:
	    <expr_stmt><expr><call><name>DoRM</name><argument_list>(<argument><expr><name>DP_X_FOCUS</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>send_focus_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><case>case <expr>1048</expr>:
	    <if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>titeInhibit</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>CursorRestore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_READLINE</name></expr></cpp:if>
	</case><case>case <expr><name>SET_BUTTON1_MOVE_POINT</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_restore</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>click1_moves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_BUTTON2_MOVE_POINT</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_restore</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_moves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_DBUTTON3_DELETE</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_restore</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dclick3_deletes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_IN_BRACKET</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_restore</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_brackets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_QUOTE</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_restore</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_quotes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>SET_PASTE_LITERAL_NL</name></expr>:
	    <expr_stmt><expr><call><name>SCREEN_FLAG_restore</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>paste_literal_nl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_READLINE */</comment>
	</case>}</block></switch>
    }</block></for>
}</block></function>

<comment type="block">/*
 * Convert an XTextProperty to a string.
 *
 * This frees the data owned by the XTextProperty, and returns in its place the
 * string, which must be freed by the caller.
 */</comment>
<function><type><name>static</name> <name>char</name> *</type>
<name>property_to_string</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XTextProperty</name> *</type> <name>text</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Display</name> *</type><name>dpy</name> =<init> <expr><name>screen</name>-&gt;<name>display</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("property_to_string value %p, encoding %s, format %d, nitems %ld\n",
	   <name>text</name>-&gt;<name>value</name>,
	   <call><name>XGetAtomName</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>text</name>-&gt;<name>encoding</name></expr></argument>)</argument_list></call>,
	   <name>text</name>-&gt;<name>format</name>,
	   <name>text</name>-&gt;<name>nitems</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <comment type="block">/*
     * We will use the XmbTextPropertyToTextList call to extract UTF-8 data.
     * The xtermUtf8ToTextList() call is used to convert UTF-8 explicitly to
     * ISO-8859-1.
     */</comment>
    <if>if <condition>(<expr>(<name>text</name>-&gt;<name>format</name> != 8)
	|| <call><name>IsTitleMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>tmGetUtf8</name></expr></argument>)</argument_list></call>
	|| (<name>rc</name> = <call><name>xtermUtf8ToTextList</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>(<name>rc</name> = <call><name>XmbTextPropertyToTextList</name><argument_list>(<argument><expr><name>dpy</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>rc</name> = <call><name>XTextPropertyToStringList</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></then></if>

    <if>if <condition>(<expr><name>rc</name> &gt;= 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name>, <name>c</name>, <name>pass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>need</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>pass</name> = 0</expr>;</init> <condition><expr><name>pass</name> &lt; 2</expr>;</condition> <incr><expr>++<name>pass</name></expr></incr>) <block>{
	    <for>for (<init><expr><name>n</name> = 0</expr>, <expr><name>need</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>s</name> =<init> <expr><name><name>list</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr>(<name>c</name> = *<name>s</name>++) != '\0'</expr>)</condition> <block>{
		    <if>if <condition>(<expr><name>pass</name></expr>)</condition><then>
			<expr_stmt><expr><name><name>result</name><index>[<expr><name>need</name></expr>]</index></name> = (<name>char</name>) <name>c</name></expr>;</expr_stmt></then></if>
		    <expr_stmt><expr>++<name>need</name></expr>;</expr_stmt>
		}</block></while>
	    }</block></for>
	    <if>if <condition>(<expr><name>pass</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>need</name></expr>]</index></name> = '\0'</expr>;</expr_stmt></then>
	    <else>else
		<expr_stmt><expr><name>result</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>need</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	    <if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then>
		<break>break;</break></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>XFreeStringList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>text</name>-&gt;<name>value</name> != 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>XFree</name><argument_list>(<argument><expr><name>text</name>-&gt;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>char</name> *</type>
<name>get_icon_label</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XTextProperty</name></type> <name>text</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>XGetWMIconName</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr>&amp;<name>text</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <call><name>property_to_string</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>char</name> *</type>
<name>get_window_label</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XTextProperty</name></type> <name>text</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>XGetWMName</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr>&amp;<name>text</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <call><name>property_to_string</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Report window label (icon or title) in dtterm protocol
 * ESC ] code label ESC backslash
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>report_win_label</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		 <param><decl><type><name>int</name></type> <name>code</name></decl></param>,
		 <param><decl><type><name>char</name> *</type><name>text</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_ESC</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_ESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>text</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>copy</name> =<init> <expr><call><name>IsTitleMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>tmGetBase16</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>copy</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Encoding hex:%s\n", <name>text</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>text</name> = <call><name>x_encode_hex</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>unparseputs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>copy</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ANSI_ESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* should be ST */</comment>
    <expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Window operations (from CDE dtterm description, as well as extensions).
 * See also "allowWindowOps" resource.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>window_ops</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XWindowChanges</name></type> <name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XWindowAttributes</name></type> <name>win_attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>value_mask</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MAXIMIZE</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>root_width</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>root_height</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("window_ops %d\n", <name><name>param</name><index>[<expr>0</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
    <case>case <expr><name>ewRestoreWin</name></expr>:		<comment type="block">/* Restore (de-iconify) window */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewRestoreWin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...de-iconify window\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XMapWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
		       <argument><expr><name>VShellWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewMinimizeWin</name></expr>:	<comment type="block">/* Minimize (iconify) window */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewMinimizeWin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...iconify window\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XIconifyWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
			   <argument><expr><name>VShellWindow</name></expr></argument>,
			   <argument><expr><call><name>DefaultScreen</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewSetWinPosition</name></expr>:	<comment type="block">/* Move the window to the given position */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewSetWinPosition</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>values</name>.<name>x</name> = <call><name>zero_if_default</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>values</name>.<name>y</name> = <call><name>zero_if_default</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...move window to %d,%d\n", <name>values</name>.<name>x</name>, <name>values</name>.<name>y</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>value_mask</name> = (<name>CWX</name> | <name>CWY</name>)</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XReconfigureWMWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
				 <argument><expr><name>VShellWindow</name></expr></argument>,
				 <argument><expr><call><name>DefaultScreen</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>value_mask</name></expr></argument>,
				 <argument><expr>&amp;<name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewSetWinSizePixels</name></expr>:	<comment type="block">/* Resize the window to given size in pixels */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewSetWinSizePixels</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>RequestResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>zero_if_default</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>zero_if_default</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewRaiseWin</name></expr>:		<comment type="block">/* Raise the window to the front of the stack */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewRaiseWin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...raise window\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XRaiseWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewLowerWin</name></expr>:		<comment type="block">/* Lower the window to the bottom of the stack */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewLowerWin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...lower window\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XLowerWindow</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewRefreshWin</name></expr>:		<comment type="block">/* Refresh the window */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewRefreshWin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...redraw window\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>Redraw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewSetWinSizeChars</name></expr>:	<comment type="block">/* Resize the text-area, in characters */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewSetWinSizeChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>RequestResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>zero_if_default</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>zero_if_default</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MAXIMIZE</name></expr></cpp:if>
    </case><case>case <expr><name>ewMaximizeWin</name></expr>:	<comment type="block">/* Maximize or restore */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewMaximizeWin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>RequestMaximize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>zero_if_default</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>ewGetWinState</name></expr>:	<comment type="block">/* Report the window's state */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetWinState</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...get window attributes\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XGetWindowAttributes</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
				 <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>win_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr>(<name>win_attrs</name>.<name>map_state</name> == <name>IsViewable</name>)
					   ? 1
					   : 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 't'</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewGetWinPosition</name></expr>:	<comment type="block">/* Report the window's position */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetWinPosition</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...get window position\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XGetWindowAttributes</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
				 <argument><expr><call><name>WMFrameWindow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>win_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = (<name>ParmType</name>) <name>win_attrs</name>.<name>x</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = (<name>ParmType</name>) <name>win_attrs</name>.<name>y</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 't'</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewGetWinSizePixels</name></expr>:	<comment type="block">/* Report the window's size in pixels */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetWinSizePixels</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...get window size in pixels\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XGetWindowAttributes</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
				 <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>&amp;<name>win_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 4</expr>;</expr_stmt>
	    <comment type="block">/*FIXME: find if dtterm uses
	     *    win_attrs.height or Height
	     *      win_attrs.width  or Width
	     */</comment>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = (<name>ParmType</name>) <call><name>Height</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = (<name>ParmType</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 't'</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewGetWinSizeChars</name></expr>:	<comment type="block">/* Report the text's size in characters */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetWinSizeChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...get window size in characters\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 8</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = (<name>ParmType</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = (<name>ParmType</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 't'</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MAXIMIZE</name></expr></cpp:if>
    </case><case>case <expr><name>ewGetScreenSizeChars</name></expr>:	<comment type="block">/* Report the screen's size, in characters */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetScreenSizeChars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...get screen size in characters\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<call><name>QueryMaximize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>root_height</name></expr></argument>, <argument><expr>&amp;<name>root_width</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>root_height</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>root_width</name> = 0</expr>;</expr_stmt>
	    }</block></then></if>
	    <expr_stmt><expr><name>reply</name>.<name>a_type</name> = <name>ANSI_CSI</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_pintro</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_nparam</name> = 3</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>0</expr>]</index></name> = 9</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>1</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr><name>root_height</name>
					   / (<name>unsigned</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name><name>a_param</name><index>[<expr>2</expr>]</index></name> = <call>(<name>ParmType</name>) <argument_list>(<argument><expr><name>root_width</name>
					   / (<name>unsigned</name>) <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_inters</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>reply</name>.<name>a_final</name> = 't'</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>unparseseq</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>ewGetIconTitle</name></expr>:	<comment type="block">/* Report the icon's label */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetIconTitle</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...get icon's label\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>report_win_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'L'</expr></argument>, <argument><expr><call><name>get_icon_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewGetWinTitle</name></expr>:	<comment type="block">/* Report the window's title */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewGetWinTitle</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...get window's label\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>report_win_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'l'</expr></argument>, <argument><expr><call><name>get_window_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewPushTitle</name></expr>:		<comment type="block">/* save the window's title(s) on stack */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewPushTitle</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>SaveTitle</name> *</type><name>last</name> =<init> <expr><name>screen</name>-&gt;<name>save_title</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>SaveTitle</name> *</type><name>item</name> =<init> <expr><call><name>TypeCalloc</name><argument_list>(<argument><expr><name>SaveTitle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...push title onto stack\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>item</name> != 0</expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><call><name>zero_if_default</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<case>case <expr>0</expr>:
		    <expr_stmt><expr><name>item</name>-&gt;<name>iconName</name> = <call><name>get_icon_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>item</name>-&gt;<name>windowName</name> = <call><name>get_window_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>1</expr>:
		    <expr_stmt><expr><name>item</name>-&gt;<name>iconName</name> = <call><name>get_icon_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>2</expr>:
		    <expr_stmt><expr><name>item</name>-&gt;<name>windowName</name> = <call><name>get_window_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case>}</block></switch>
		<expr_stmt><expr><name>item</name>-&gt;<name>next</name> = <name>last</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>item</name>-&gt;<name>iconName</name> == 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>item</name>-&gt;<name>iconName</name> = ((<name>last</name> == 0)
				      ? <call><name>get_icon_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
				      : <call><name>x_strdup</name><argument_list>(<argument><expr><name>last</name>-&gt;<name>iconName</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>item</name>-&gt;<name>windowName</name> == 0</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>item</name>-&gt;<name>windowName</name> = ((<name>last</name> == 0)
					? <call><name>get_window_label</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
					: <call><name>x_strdup</name><argument_list>(<argument><expr><name>last</name>-&gt;<name>windowName</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>save_title</name> = <name>item</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
	<break>break;</break>

    </case><case>case <expr><name>ewPopTitle</name></expr>:		<comment type="block">/* restore the window's title(s) from stack */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewPopTitle</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>SaveTitle</name> *</type><name>item</name> =<init> <expr><name>screen</name>-&gt;<name>save_title</name></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...pop title off stack\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>item</name> != 0</expr>)</condition><then> <block>{
		<switch>switch <condition>(<expr><call><name>zero_if_default</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<case>case <expr>0</expr>:
		    <expr_stmt><expr><call><name>ChangeIconName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>item</name>-&gt;<name>iconName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>ChangeTitle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>item</name>-&gt;<name>windowName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>1</expr>:
		    <expr_stmt><expr><call><name>ChangeIconName</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>item</name>-&gt;<name>iconName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case><case>case <expr>2</expr>:
		    <expr_stmt><expr><call><name>ChangeTitle</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>item</name>-&gt;<name>windowName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		</case>}</block></switch>
		<expr_stmt><expr><name>screen</name>-&gt;<name>save_title</name> = <name>item</name>-&gt;<name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>item</name>-&gt;<name>iconName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>item</name>-&gt;<name>windowName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
	<break>break;</break>

    </case><default>default:			<comment type="block">/* DECSLPP (24, 25, 36, 48, 72, 144) */</comment>
	<if>if <condition>(<expr><call><name>AllowWindowOps</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ewSetWinLines</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name><name>param</name><index>[<expr>0</expr>]</index></name> &gt;= 24</expr>)</condition><then>
		<expr_stmt><expr><call><name>RequestResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>param</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<break>break;</break>
    </default>}</block></switch>
}</block></function>

<comment type="block">/*
 * set a bit in a word given a pointer to the word and a mask.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>bitset</name><parameter_list>(<param><decl><type><name>unsigned</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>mask</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>p</name> |= <name>mask</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * clear a bit in a word given a pointer to the word and a mask.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>bitclr</name><parameter_list>(<param><decl><type><name>unsigned</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>mask</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>p</name> &amp;= ~<name>mask</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Copy bits from one word to another, given a mask
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>bitcpy</name><parameter_list>(<param><decl><type><name>unsigned</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>q</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>mask</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>bitclr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bitset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name> &amp; <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>unparseputc1</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>c</name> &gt;= 0x80 &amp;&amp; <name>c</name> &lt;= 0x9F</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>!<call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>control_eight_bits</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>A2E</name><argument_list>(<argument><expr><name>ANSI_ESC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>c</name> = <call><name>A2E</name><argument_list>(<argument><expr><name>c</name> - 0x40</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>unparseseq</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ANSI</name> *</type> <name>ap</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>inters</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>unparseputc1</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name> = <name>ap</name>-&gt;<name>a_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>c</name> == <name>ANSI_ESC</name>
	|| <name>c</name> == <name>ANSI_DCS</name>
	|| <name>c</name> == <name>ANSI_CSI</name>
	|| <name>c</name> == <name>ANSI_OSC</name>
	|| <name>c</name> == <name>ANSI_PM</name>
	|| <name>c</name> == <name>ANSI_APC</name>
	|| <name>c</name> == <name>ANSI_SS3</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>ap</name>-&gt;<name>a_pintro</name> != 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ap</name>-&gt;<name>a_pintro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ap</name>-&gt;<name>a_nparam</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	    <if>if <condition>(<expr><name>i</name> != 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <macro><name>unparseputn</name><argument_list>(<argument>xw</argument>, <argument>(unsigned int) ap-&gt;a_param[i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	}</block></for>
	<if>if <condition>(<expr>(<name>inters</name> = <name>ap</name>-&gt;<name>a_inters</name>) != 0</expr>)</condition><then> <block>{
	    <for>for (<init><expr><name>i</name> = 3</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
		<expr_stmt><expr><name>c</name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>inters</name> &gt;&gt; (8 * <name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> != 0</expr>)</condition><then>
		    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    }</block></for>
	}</block></then></if>
	<expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>char</name>) <name>ap</name>-&gt;<name>a_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>unparseputn</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>q</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>q</name> = <name>n</name> / 10</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>q</name> != 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>unparseputn</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call>(<name>char</name>) <argument_list>(<argument><expr>'0' + (<name>n</name> % 10)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>unparseputs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>s</name> != 0</expr>)</condition><then> <block>{
	<while>while <condition>(<expr>*<name>s</name></expr>)</condition>
	    <expr_stmt><expr><call><name>unparseputc</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>unparseputc</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>IChar</name> *</type><name>buf</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>unparse_bfr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>unparse_len</name> + 2) &gt;= <call><name>sizeof</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>unparse_bfr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>unparse_end</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>len</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>unparse_len</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TCAP_QUERY</name></expr></cpp:if>
    <comment type="block">/*
     * If we're returning a termcap string, it has to be translated since
     * a DCS must not contain any characters except for the normal 7-bit
     * printable ASCII (counting tab, carriage return, etc).  For now,
     * just use hexadecimal for the whole thing.
     */</comment>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>tc_query_code</name> &gt;= 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr>"%02X"</expr></argument>, <argument><expr><name>c</name> &amp; 0xFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>tmp</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name><name>tmp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr>(<name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = (<name>IChar</name>) <name>c</name>) == '\r' &amp;&amp; (<name>xw</name>-&gt;<name>flags</name> &amp; <name>LINEFEED</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = '\n'</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>unparse_len</name> = <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* If send/receive mode is reset, we echo characters locally */</comment>
    <if>if <condition>(<expr>(<name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> &amp; <name>MODE_SRM</name>) == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr>(<name>void</name>) <call><name>doparsing</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>c</name></expr></argument>, <argument><expr>&amp;<name>myState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>unparse_end</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>unparse_len</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>tt_write</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>unparse_bfr</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>unparse_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* VMS */</comment>
	<expr_stmt><expr><call><name>writePtyData</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>unparse_bfr</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>unparse_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>unparse_len</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>ToggleAlternate</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>whichBuf</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>FromAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
	<expr_stmt><expr><call><name>ToAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>ToAlternate</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>whichBuf</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ToAlternate\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name> = <call><name>allocScrnBuf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
						    <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
						    <argument><expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
						    <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>SwitchBufs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>whichBuf</name> = 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>visbuf</name> = <name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>update_altscreen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>FromAlternate</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>whichBuf</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("FromAlternate\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>whichBuf</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SwitchBufs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>visbuf</name> = <name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>update_altscreen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>SwitchBufs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>toBuf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rows</name>, <name>top</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>rows</name> = <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SwitchBufPtrs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>toBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>top</name> = <call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) &lt; <name>rows</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scroll_amt</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>FlushScroll</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>XClearArea</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>,
		   <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr>(<name>int</name>) <call><name>OriginX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr>(<name>int</name>) <name>top</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></argument>,
		   <argument><expr>(<name>unsigned</name>) <call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>rows</name> - <name>top</name>) * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ScrnUpdate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>Bool</name></type>
<name>CheckBufPtrs</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<name>screen</name>-&gt;<name>visbuf</name> != 0
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
	    &amp;&amp; <name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>0</expr>]</index></name> != 0
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    &amp;&amp; <name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name> != 0)</expr>;</return>
}</block></function>

<comment type="block">/*
 * Swap buffer line pointers between alternate and regular screens.
 */</comment>
<function><type><name>void</name></type>
<name>SwitchBufPtrs</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name> <name>toBuf</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>CheckBufPtrs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>visbuf</name> = <name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>toBuf</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> =<init> <expr><call><name>ScrnPointers</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>size_t</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>save_ptr</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>visbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>visbuf</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>save_ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>VTRun</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTRun ...\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>Vshow</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>set_vt_visibility</name><argument_list>(<argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>update_vttekmode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_vtshow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>update_tekshow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_vthide_sensitivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScrnAllocBuf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>OFF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_set</name> = <name>ON</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>DoStartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>StartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr><name>Tpushb</name> &gt; <name>Tpushback</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fillPtyData</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>VTbuffer</name></expr></argument>, <argument><expr>(<name>char</name> *) <name>Tpushback</name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>Tpushb</name> - <name>Tpushback</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Tpushb</name> = <name>Tpushback</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>screen</name>-&gt;<name>is_running</name> = <name>True</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>setjmp</name><argument_list>(<argument><expr><name>VTend</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>VTparse</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>StopBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_set</name> = <name>OFF</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... VTRun\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>static</name> <name>void</name></type>
<name>VTExpose</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
	 <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,
	 <param><decl><type><name>Region</name> <name>region</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"Expose\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>
    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>Expose</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>HandleExposure</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>VTGraphicsOrNoExpose</name><parameter_list>(<param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>incopy</name> &lt;= 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>incopy</name> = 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scrolls</name> &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scrolls</name>--</expr>;</expr_stmt></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>event</name>-&gt;<name>type</name> == <name>GraphicsExpose</name></expr>)</condition><then>
	<if>if <condition>(<expr><call><name>HandleExposure</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>OFF</name></expr>;</expr_stmt></then></if></then></if>
    <if>if <condition>(<expr>(<name>event</name>-&gt;<name>type</name> == <name>NoExpose</name>)
	|| ((<name>XGraphicsExposeEvent</name> *) <name>event</name>)-&gt;<name>count</name> == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>incopy</name> &lt;= 0 &amp;&amp; <name>screen</name>-&gt;<name>scrolls</name> &gt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>scrolls</name>--</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>scrolls</name></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>incopy</name> = -1</expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>screen</name>-&gt;<name>incopy</name> = 0</expr>;</expr_stmt></else></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>static</name> <name>void</name></type>
<name>VTNonMaskableEvent</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>XtPointer</name> <name>closure</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,
		   <param><decl><type><name>Boolean</name> * <name>cont</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>event</name>-&gt;<name>type</name></expr>)</condition> <block>{
    <case>case <expr><name>GraphicsExpose</name></expr>:
    </case><case>case <expr><name>NoExpose</name></expr>:
	<expr_stmt><expr><call><name>VTGraphicsOrNoExpose</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>VTResize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>XtIsRealized</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr>(<name>XtermWidget</name>) <name>w</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScreenResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>core</name>.<name>width</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>core</name>.<name>height</name></expr></argument>, <argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>okDimension</name>(src,dst) ((src &lt;= 32767) \
			  &amp;&amp; ((dst = (Dimension) src) == src))</cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>RequestResize</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>rows</name></decl></param>, <param><decl><type><name>int</name></type> <name>cols</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>text</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Dimension</name></type> <name>replyWidth</name>, <name>replyHeight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Dimension</name></type> <name>askedWidth</name>, <name>askedHeight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtGeometryResult</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XWindowAttributes</name></type> <name>attrs</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("RequestResize(rows=%d, cols=%d, text=%d)\n", <name>rows</name>, <name>cols</name>, <name>text</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>askedWidth</name> = (<name>Dimension</name>) <name>cols</name></expr></argument>)</argument_list></call> &lt; <name>cols</name>
	|| <call>(<name>int</name>) <argument_list>(<argument><expr><name>askedHeight</name> = (<name>Dimension</name>) <name>rows</name></expr></argument>)</argument_list></call> &lt; <name>rows</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <if>if <condition>(<expr><name>askedHeight</name> == 0
	|| <name>askedWidth</name> == 0
	|| <name>xw</name>-&gt;<name>misc</name>.<name>limit_resize</name> &gt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>XGetWindowAttributes</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr><call><name>RootWindowOfScreen</name><argument_list>(<argument><expr><call><name>XtScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>text</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>value</name> = (<name>unsigned</name> <name>long</name>) <name>rows</name>) != 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>rows</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>value</name> = (<name>unsigned</name> <name>long</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>value</name> *= (<name>unsigned</name> <name>long</name>) <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>value</name> += (<name>unsigned</name> <name>long</name>) (2 * <name>screen</name>-&gt;<name>border</name>)</expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<call><name>okDimension</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>askedHeight</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	}</block></then></if>

	<if>if <condition>(<expr>(<name>value</name> = (<name>unsigned</name> <name>long</name>) <name>cols</name>) != 0</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>cols</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>value</name> = (<name>unsigned</name> <name>long</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>value</name> *= (<name>unsigned</name> <name>long</name>) <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>value</name> += (<name>unsigned</name> <name>long</name>) ((2 * <name>screen</name>-&gt;<name>border</name>)
				      + <call><name>ScrollbarWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<call><name>okDimension</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>askedWidth</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>
	}</block></then></if>

    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><name>rows</name> &lt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>askedHeight</name> = <call><name>FullHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>cols</name> &lt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>askedWidth</name> = <call><name>FullWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><name>rows</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><name>askedHeight</name> = (<name>Dimension</name>) <name>attrs</name>.<name>height</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>cols</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><name>askedWidth</name> = (<name>Dimension</name>) <name>attrs</name>.<name>width</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>limit_resize</name> &gt; 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Dimension</name></type> <name>high</name> =<init> <expr><call>(<name>Dimension</name>) <argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>limit_resize</name> * <name>attrs</name>.<name>height</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dimension</name></type> <name>wide</name> =<init> <expr><call>(<name>Dimension</name>) <argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>limit_resize</name> * <name>attrs</name>.<name>width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>(<name>int</name>) <name>high</name> &lt; <name>attrs</name>.<name>height</name></expr>)</condition><then>
	    <expr_stmt><expr><name>high</name> = (<name>Dimension</name>) <name>attrs</name>.<name>height</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>askedHeight</name> &gt; <name>high</name></expr>)</condition><then>
	    <expr_stmt><expr><name>askedHeight</name> = <name>high</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>int</name>) <name>wide</name> &lt; <name>attrs</name>.<name>width</name></expr>)</condition><then>
	    <expr_stmt><expr><name>wide</name> = (<name>Dimension</name>) <name>attrs</name>.<name>width</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>askedWidth</name> &gt; <name>wide</name></expr>)</condition><then>
	    <expr_stmt><expr><name>askedWidth</name> = <name>wide</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>nothack</name></cpp:ifndef>
    <expr_stmt><expr><call><name>getXtermSizeHints</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...requesting resize %dx%d\n", <name>askedHeight</name>, <name>askedWidth</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name> = <call><name>REQ_RESIZE</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>,
			<argument><expr><name>askedWidth</name></expr></argument>, <argument><expr><name>askedHeight</name></expr></argument>,
			<argument><expr>&amp;<name>replyWidth</name></expr></argument>, <argument><expr>&amp;<name>replyHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>status</name> == <name>XtGeometryYes</name> ||
	<name>status</name> == <name>XtGeometryDone</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScreenResize</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>replyWidth</name></expr></argument>, <argument><expr><name>replyHeight</name></expr></argument>, <argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>nothack</name></cpp:ifndef>
    <comment type="block">/*
     * XtMakeResizeRequest() has the undesirable side-effect of clearing
     * the window manager's hints, even on a failed request.  This would
     * presumably be fixed if the shell did its own work.
     */</comment>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name>
	&amp;&amp; <name>replyHeight</name>
	&amp;&amp; <name>replyWidth</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>height</name> = <name>replyHeight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>width</name> = <name>replyWidth</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s@%d -- ", <name>__FILE__</name>, <name>__LINE__</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE_HINTS</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>hints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XSetWMNormalHints</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr>&amp;<name>xw</name>-&gt;<name>hints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s@%d -- ", <name>__FILE__</name>, <name>__LINE__</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE_WM_HINTS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>XSync</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* synchronize */</comment>
    <if>if <condition>(<expr><call><name>XtAppPending</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><call><name>xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...RequestResize done\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><name>static</name> <name>String</name></type> <name>xterm_trans</name> =<init>
<expr>"&lt;ClientMessage&gt;WM_PROTOCOLS: DeleteWindow()\n\
     &lt;MappingNotify&gt;: KeyboardMapping()\n"</expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>VTInit</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Widget</name></type> <name>vtparent</name> =<init> <expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTInit {{\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XtRealizeWidget</name><argument_list>(<argument><expr><name>vtparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtOverrideTranslations</name><argument_list>(<argument><expr><name>vtparent</name></expr></argument>, <argument><expr><call><name>XtParseTranslationTable</name><argument_list>(<argument><expr><name>xterm_trans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <call><name>XSetWMProtocols</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>vtparent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>vtparent</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr>&amp;<name>wm_delete_window</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_TRANS</name><argument_list>(<argument><expr>"shell"</expr></argument>, <argument><expr><name>vtparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_TRANS</name><argument_list>(<argument><expr>"vt100"</expr></argument>, <argument><expr><call>(<name>Widget</name>) <argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ScrnAllocBuf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...}} VTInit\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(1)</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>VTClassInit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>XtAddConverter</name><argument_list>(<argument><expr><name>XtRString</name></expr></argument>, <argument><expr><name>XtRGravity</name></expr></argument>, <argument><expr><name>XmuCvtStringToGravity</name></expr></argument>,
		   <argument><expr>(<name>XtConvertArgList</name>) <name>NULL</name></expr></argument>, <argument><expr>(<name>Cardinal</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * The whole wnew-&gt;screen struct is zeroed in VTInitialize.  Use these macros
 * where applicable for copying the pieces from the request widget into the
 * new widget.  We do not have to use them for wnew-&gt;misc, but the associated
 * traces are very useful for debugging.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Bres</name>(name) \
	TRACE(("init " #name " = %s\n", \
		BtoS(wnew-&gt;name = request-&gt;name)))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Dres2</name>(name,i) \
	TRACE(("init " #name "[%d] = %f\n", i, \
		wnew-&gt;name[i] = request-&gt;name[i]))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Ires</name>(name) \
	TRACE(("init " #name " = %d\n", \
		wnew-&gt;name = request-&gt;name))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Sres</name>(name) \
	TRACE(("init " #name " = \"%s\"\n", \
		(wnew-&gt;name = x_strtrim(request-&gt;name)) != NULL \
			? wnew-&gt;name : "&lt;null&gt;"))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Sres2</name>(name,i) \
	TRACE(("init " #name "[%d] = \"%s\"\n", i, \
		(wnew-&gt;name(i) = x_strtrim(request-&gt;name(i))) != NULL \
			? wnew-&gt;name(i) : "&lt;null&gt;"))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Tres</name>(offset) \
	TRACE(("init screen.Tcolors[" #offset "] = %#lx\n", \
		fill_Tres(wnew, request, offset)))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Bres</name>(name)    wnew-&gt;name = request-&gt;name</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Dres2</name>(name,i) wnew-&gt;name[i] = request-&gt;name[i]</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Ires</name>(name)    wnew-&gt;name = request-&gt;name</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Sres</name>(name)    wnew-&gt;name = x_strtrim(request-&gt;name)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Sres2</name>(name,i) wnew-&gt;name(i) = x_strtrim(request-&gt;name(i))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>init_Tres</name>(offset)  fill_Tres(wnew, request, offset)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
<comment type="block">/*
 * Override the use of XtDefaultForeground/XtDefaultBackground to make some
 * colors, such as cursor color, use the actual foreground/background value
 * if there is no explicit resource value used.
 */</comment>
<function><type><name>static</name> <name>Pixel</name></type>
<name>fill_Tres</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>target</name></decl></param>, <param><decl><type><name>XtermWidget</name></type> <name>source</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnColors</name></type> <name>temp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>mode</name> = <name>False</name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>name</name> = <call><name>x_strtrim</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>resource</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>resource</name> = <name>name</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>name</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>value</name> = <name>target</name>-&gt;<name>dft_foreground</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>isDefaultForeground</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>value</name> =
	    ((<name>offset</name> == <name>TEXT_FG</name> || <name>offset</name> == <name>TEXT_BG</name>)
	     ? <name>target</name>-&gt;<name>dft_foreground</name>
	     : <call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEXT_FG</name></expr>]</index></name>.<name>value</name>)</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>isDefaultBackground</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>value</name> =
	    ((<name>offset</name> == <name>TEXT_FG</name> || <name>offset</name> == <name>TEXT_BG</name>)
	     ? <name>target</name>-&gt;<name>dft_background</name>
	     : <call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEXT_BG</name></expr>]</index></name>.<name>value</name>)</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>AllocateTermColor</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><call><name>COLOR_DEFINED</name><argument_list>(<argument><expr>&amp;(<name>temp</name>)</expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>temp</name>.<name><name>names</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>value</name> = <name>temp</name>.<name><name>colors</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if></else></if></else></if>
    <return>return <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>offset</name></expr>]</index></name>.<name>value</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>fill_Tres</name>(target, source, offset) \
	TScreenOf(target)-&gt;Tcolors[offset] = TScreenOf(source)-&gt;Tcolors[offset]</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>VTInitialize_locale</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>is_utf8</name> =<init> <expr><call><name>xtermEnvUTF8</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTInitialize_locale\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... request screen.utf8_mode = %d\n", <name>screen</name>-&gt;<name>utf8_mode</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uFalse</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> &gt; 3</expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uDefault</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>latin9_mode</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>unicode_font</name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_LUIT_PROG</name></expr></cpp:if>
    <expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>callfilter</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>use_encoding</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... setup for luit:\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... request misc.locale_str = \"%s\"\n", <name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> == <name>uFalse</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... command-line +u8 overrides\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MINI_LUIT</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"CHECKFONT"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>fl</name> =<init> <expr>(<name>xw</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name>
		  ? (<name>int</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name></expr></argument>)</argument_list></call>
		  : 0)</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>fl</name> &gt; 11
	    &amp;&amp; <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name> + <name>fl</name> - 11</expr></argument>,
			    <argument><expr>"-ISO10646-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>unicode_font</name> = 1</expr>;</expr_stmt>
	    <comment type="block">/* unicode font, use True */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LANGINFO_CODESET</name></cpp:ifdef>
	    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><call><name>xtermEnvEncoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"ANSI_X3.4-1968"</expr></argument>)</argument_list></call>
		|| !<call><name>strcmp</name><argument_list>(<argument><expr><call><name>xtermEnvEncoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"ISO-8859-1"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> == <name>uDefault</name></expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uFalse</name></expr>;</expr_stmt></then></if>
	    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><call><name>xtermEnvEncoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"ISO-8859-15"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> == <name>uDefault</name></expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uFalse</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>screen</name>-&gt;<name>latin9_mode</name> = 1</expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>callfilter</name> = <call>(<name>Boolean</name>) <argument_list>(<argument><expr><name>is_utf8</name> ? 0 : 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uAlways</name></expr>;</expr_stmt>
	    }</block></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>callfilter</name> = <name>is_utf8</name> ? 0 : 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uAlways</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
	    <comment type="block">/* other encoding, use False */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> == <name>uDefault</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>is_utf8</name> ? <name>uAlways</name> : <name>uFalse</name></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></else></if>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_MINI_LUIT */</comment>
	<if>if <condition>(<expr><call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"TRUE"</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"ON"</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"YES"</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"AUTO"</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>strcmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<comment type="block">/* when true ... fully obeying LC_CTYPE locale */</comment>
	<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>callfilter</name> = <call>(<name>Boolean</name>) <argument_list>(<argument><expr><name>is_utf8</name> ? 0 : 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uAlways</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"FALSE"</expr></argument>)</argument_list></call> == 0 ||
	       <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"OFF"</expr></argument>)</argument_list></call> == 0 ||
	       <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"NO"</expr></argument>)</argument_list></call> == 0 ||
	       <call><name>strcmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<comment type="block">/* when false ... original value of utf8_mode is effective */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> == <name>uDefault</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>is_utf8</name> ? <name>uAlways</name> : <name>uFalse</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"MEDIUM"</expr></argument>)</argument_list></call> == 0 ||
	       <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"SEMIAUTO"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<comment type="block">/* when medium ... obeying locale only for UTF-8 and Asian */</comment>
	<if>if <condition>(<expr><name>is_utf8</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uAlways</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MB_CUR_MAX</name></cpp:ifdef>
		      <expr><name>MB_CUR_MAX</name> &gt; 1 ||
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		      !<call><name>strncmp</name><argument_list>(<argument><expr><call><name>xtermEnvLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"ja"</expr></argument>, <argument><expr>(<name>size_t</name>) 2</expr></argument>)</argument_list></call> ||
		      !<call><name>strncmp</name><argument_list>(<argument><expr><call><name>xtermEnvLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"ko"</expr></argument>, <argument><expr>(<name>size_t</name>) 2</expr></argument>)</argument_list></call> ||
		      !<call><name>strncmp</name><argument_list>(<argument><expr><call><name>xtermEnvLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"zh"</expr></argument>, <argument><expr>(<name>size_t</name>) 2</expr></argument>)</argument_list></call> ||
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		      !<call><name>strncmp</name><argument_list>(<argument><expr><call><name>xtermEnvLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"th"</expr></argument>, <argument><expr>(<name>size_t</name>) 2</expr></argument>)</argument_list></call> ||
		      !<call><name>strncmp</name><argument_list>(<argument><expr><call><name>xtermEnvLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"vi"</expr></argument>, <argument><expr>(<name>size_t</name>) 2</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>callfilter</name> = 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uAlways</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uFalse</name></expr>;</expr_stmt>
	}</block></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"UTF-8"</expr></argument>)</argument_list></call> == 0 ||
	       <call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>, <argument><expr>"UTF8"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<comment type="block">/* when UTF-8 ... UTF-8 mode */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uAlways</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* other words are regarded as encoding name passed to luit */</comment>
	<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>callfilter</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>uAlways</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>use_encoding</name> = 1</expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... updated misc.callfilter = %s\n", <call><name>BtoS</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>callfilter</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... updated misc.use_encoding = %s\n", <call><name>BtoS</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>use_encoding</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name> == <name>uDefault</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>utf8_mode</name> = <name>is_utf8</name> ? <name>uAlways</name> : <name>uFalse</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_LUIT_PROG */</comment>

    <expr_stmt><expr><name>screen</name>-&gt;<name>utf8_inparse</name> = <call>(<name>Boolean</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>utf8_mode</name> != <name>uFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... updated screen.utf8_mode = %d\n", <name>screen</name>-&gt;<name>utf8_mode</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...VTInitialize_locale done\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>void</name></type>
<name>ParseOnClicks</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>wnew</name></decl></param>, <param><decl><type><name>XtermWidget</name></type> <name>wreq</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>item</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* *INDENT-OFF* */</comment>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type>	<name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectUnit</name></type>	<name>code</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>table</name><index>[]</index></name> = <block>{
    	<expr><block>{ <expr>"char"</expr>,	<expr><name>Select_CHAR</name></expr> }</block></expr>,
    	<expr><block>{ <expr>"word"</expr>,	<expr><name>Select_WORD</name></expr> }</block></expr>,
    	<expr><block>{ <expr>"line"</expr>,	<expr><name>Select_LINE</name></expr> }</block></expr>,
    	<expr><block>{ <expr>"group"</expr>,	<expr><name>Select_GROUP</name></expr> }</block></expr>,
    	<expr><block>{ <expr>"page"</expr>,	<expr><name>Select_PAGE</name></expr> }</block></expr>,
    	<expr><block>{ <expr>"all"</expr>,	<expr><name>Select_ALL</name></expr> }</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SELECT_REGEX</name></expr></cpp:if>
    	<expr><block>{ <expr>"regex"</expr>,	<expr><name>Select_REGEX</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr>;</expr_stmt>
    <comment type="block">/* *INDENT-ON* */</comment>

    <decl_stmt><decl><type><name>String</name></type> <name>res</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wreq</name></expr></argument>)</argument_list></call>-&gt;<name><name>onClick</name><index>[<expr><name>item</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>next</name> =<init> <expr><call><name>x_skip_nonblanks</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectMap</name><index>[<expr><name>item</name></expr>]</index></name> = <name>NSELECTUNITS</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>x_strncasecmp</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>next</name> - <name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectMap</name><index>[<expr><name>item</name></expr>]</index></name> = <name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>code</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SELECT_REGEX</name></expr></cpp:if>
	    <if>if <condition>(<expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>code</name> == <name>Select_REGEX</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectExpr</name><index>[<expr><name>item</name></expr>]</index></name> = <call><name>x_strtrim</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Parsed regex \"%s\"\n", <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectExpr</name><index>[<expr><name>item</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <break>break;</break>
	}</block></then></if>
    }</block></for>
}</block></function>

<comment type="block">/*
 * Parse a comma-separated list, returning a string which the caller must
 * free, and updating the source pointer.
 */</comment>
<function><type><name>static</name> <name>char</name> *</type>
<name>ParseList</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> **</type><name>source</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>base</name> =<init> <expr>*<name>source</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>value</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* ignore empty values */</comment>
    <while>while <condition>(<expr>*<name>base</name> == ','</expr>)</condition>
	<expr_stmt><expr>++<name>base</name></expr>;</expr_stmt></while>
    <if>if <condition>(<expr>*<name>base</name> != '\0'</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>next</name> = <name>base</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>*<name>next</name> != '\0' &amp;&amp; *<name>next</name> != ','</expr>)</condition>
	    <expr_stmt><expr>++<name>next</name></expr>;</expr_stmt></while>
	<expr_stmt><expr><name>size</name> = <call>(<name>size_t</name>) <argument_list>(<argument><expr>1 + <name>next</name> - <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>value</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>value</name><index>[<expr><name>size</name> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr>*<name>source</name> = <name>next</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr>*<name>source</name> = <name>base</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>result</name> = <call><name>x_strtrim</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>set_flags_from_list</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>target</name></decl></param>,
		    <param><decl><type><name>const</name> <name>char</name> *</type><name>source</name></decl></param>,
		    <param><decl><type><name>FlagList</name> *</type> <name>list</name></decl></param>,
		    <param><decl><type><name>Cardinal</name></type> <name>limit</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>value</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>*<name>source</name> != '\0'</expr>)</condition> <block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>next</name> =<init> <expr><call><name>ParseList</name><argument_list>(<argument><expr>&amp;<name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Boolean</name></type> <name>found</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>next</name> == 0</expr>)</condition><then>
	    <break>break;</break></then></if>
	<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>char</name> *</type><name>temp</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>value</name> = (<name>int</name>) <call><name>strtol</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!<call><name>IsEmpty</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Expected a number: %s\n"</expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>limit</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		    <if>if <condition>(<expr><name><name>list</name><index>[<expr><name>n</name></expr>]</index></name>.<name>code</name> == <name>value</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>target</name><index>[<expr><name>value</name></expr>]</index></name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> = <name>True</name></expr>;</expr_stmt>
			<break>break;</break>
		    }</block></then></if>
		}</block></for>
	    }</block></else></if>
	}</block></then> <else>else <block>{
	    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>limit</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name><name>list</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>value</name> = <name><name>list</name><index>[<expr><name>n</name></expr>]</index></name>.<name>code</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>target</name><index>[<expr><name>value</name></expr>]</index></name> = 1</expr>;</expr_stmt>
		    <expr_stmt><expr><name>found</name> = <name>True</name></expr>;</expr_stmt>
		    <break>break;</break>
		}</block></then></if>
	    }</block></for>
	}</block></else></if>
	<if>if <condition>(<expr>!<name>found</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Unrecognized keyword: %s\n"</expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...found %s (%d)\n", <name>next</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<comment type="block">/*
 * Extend a (normally) boolean resource value by checking for additional values
 * which will be mapped into true/false.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
<function><type><name>static</name> <name>int</name></type>
<name>extendedBoolean</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>FlagList</name> *</type> <name>table</name></decl></param>, <param><decl><type><name>Cardinal</name></type> <name>limit</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>check</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call> == 0)
	|| (<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"yes"</expr></argument>)</argument_list></call> == 0)
	|| (<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"on"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>(<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"false"</expr></argument>)</argument_list></call> == 0)
	       || (<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"no"</expr></argument>)</argument_list></call> == 0)
	       || (<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"off"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>(<name>check</name> = <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) &gt;= 0 &amp;&amp; *<name>next</name> == '\0'</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>check</name> &gt;= (<name>long</name>) <name>limit</name></expr>)</condition><then>
	    <expr_stmt><expr><name>check</name> = <name>True</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>result</name> = (<name>int</name>) <name>check</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>limit</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	    <if>if <condition>(<expr><call><name>x_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name><name>table</name><index>[<expr><name>n</name></expr>]</index></name>.<name>code</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block></for>
    }</block></else></if></else></if></else></if>

    <if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Unrecognized keyword: %s\n"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <name>False</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_RENDERFONT */</comment>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>VTInitialize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>wrequest</name></decl></param>,
	     <param><decl><type><name>Widget</name></type> <name>new_arg</name></decl></param>,
	     <param><decl><type><name>ArgList</name> <name>args</name></type> <name>GCC_UNUSED</name></decl></param>,
	     <param><decl><type><name>Cardinal</name> *<name>num_args</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>Kolor</name>(name) TScreenOf(wnew)-&gt;name.resource</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TxtFg</name>(name) !x_strcasecmp(Kolor(Tcolors[TEXT_FG]), Kolor(name))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TxtBg</name>(name) !x_strcasecmp(Kolor(Tcolors[TEXT_BG]), Kolor(name))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DftFg</name>(name) isDefaultForeground(Kolor(name))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DftBg</name>(name) isDefaultBackground(Kolor(name))</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>DATA</name>(name) { #name, ec##name }</cpp:define>
    <decl_stmt><decl><type><name>static</name> <name>FlagList</name></type> <name><name>tblColorOps</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetColor</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetColor</name></expr></argument>)</argument_list></call></expr>
	,<macro><name>DATA</name><argument_list>(<argument>GetAnsiColor</argument>)</argument_list></macro>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DATA</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>DATA</name>(name) { #name, ef##name }</cpp:define>
    <decl_stmt><decl><type><name>static</name> <name>FlagList</name></type> <name><name>tblFontOps</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetFont</name></expr></argument>)</argument_list></call></expr>
	,<macro><name>DATA</name><argument_list>(<argument>GetFont</argument>)</argument_list></macro>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DATA</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>DATA</name>(name) { #name, et##name }</cpp:define>
    <decl_stmt><decl><type><name>static</name> <name>FlagList</name></type> <name><name>tblTcapOps</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetTcap</name></expr></argument>)</argument_list></call></expr>
	,<macro><name>DATA</name><argument_list>(<argument>GetTcap</argument>)</argument_list></macro>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DATA</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>DATA</name>(name) { #name, ew##name }</cpp:define>
    <decl_stmt><decl><type><name>static</name> <name>FlagList</name></type> <name><name>tblWindowOps</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr><call><name>DATA</name><argument_list>(<argument><expr><name>RestoreWin</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>MinimizeWin</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetWinPosition</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetWinSizePixels</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>RaiseWin</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>LowerWin</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>RefreshWin</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetWinSizeChars</name></expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MAXIMIZE</name></expr></cpp:if>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>MaximizeWin</name></expr></argument>)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetWinState</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetWinPosition</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetWinSizePixels</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetWinSizeChars</name></expr></argument>)</argument_list></call></expr>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MAXIMIZE</name></expr></cpp:if>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetScreenSizeChars</name></expr></argument>)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetIconTitle</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetWinTitle</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>PushTitle</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>PopTitle</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetWinLines</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>SetXprop</name></expr></argument>)</argument_list></call></expr>
	,<expr><call><name>DATA</name><argument_list>(<argument><expr><name>GetSelection</name></expr></argument>)</argument_list></call></expr>
	,<macro><name>DATA</name><argument_list>(<argument>SetSelection</argument>)</argument_list></macro>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DATA</name></cpp:undef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DATA</name>(name) { #name, er##name }</cpp:define>
    <decl_stmt><decl><type><name>static</name> <name>FlagList</name></type> <name><name>tblRenderFont</name><index>[]</index></name> =<init>
    <expr><block>{
	<macro><name>DATA</name><argument_list>(<argument>Default</argument>)</argument_list></macro>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DATA</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>request</name> =<init> <expr>(<name>XtermWidget</name>) <name>wrequest</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>wnew</name> =<init> <expr>(<name>XtermWidget</name>) <name>new_arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Widget</name></type> <name>my_parent</name> =<init> <expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Bool</name></type> <name>color_ok</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES2</name></expr></cpp:if>
    <decl_stmt><decl><type><name>static</name> <name>XtResource</name></type> <name><name>fake_resources</name><index>[]</index></name> =<init>
    <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_256_COLORS</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;256colres.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OPT_88_COLORS</name></expr></cpp:elif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;88colres.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_COLOR_RES2 */</comment>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTInitialize wnew %p, %d / %d resources\n",
	   (<name>void</name> *) <name>wnew</name>, <call><name>XtNumber</name><argument_list>(<argument><expr><name>xterm_resources</name></expr></argument>)</argument_list></call>, <name>MAXRESOURCES</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>XtNumber</name><argument_list>(<argument><expr><name>xterm_resources</name></expr></argument>)</argument_list></call> &lt; <name>MAXRESOURCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Zero out the entire "screen" component of "wnew" widget, then do
     * field-by-field assignment of "screen" fields that are named in the
     * resource list.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>wnew</name>-&gt;<name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* DESCO Sys#67660
     * Zero out the entire "keyboard" component of "wnew" widget.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>wnew</name>-&gt;<name>keyboard</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>wnew</name>-&gt;<name>keyboard</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dummy values so that we don't try to Realize the parent shell with height
     * or width of 0, which is illegal in X.  The real size is computed in the
     * xtermWidget's Realize proc, but the shell's Realize proc is called first,
     * and must see a valid size.
     */</comment>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>core</name>.<name>height</name> = <name>wnew</name>-&gt;<name>core</name>.<name>width</name> = 1</expr>;</expr_stmt>

    <comment type="block">/*
     * The definition of -rv now is that it changes the definition of
     * XtDefaultForeground and XtDefaultBackground.  So, we no longer
     * need to do anything special.
     */</comment>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>display</name> = <name>wnew</name>-&gt;<name>core</name>.<name>screen</name>-&gt;<name>display</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We use the default foreground/background colors to compare/check if a
     * color-resource has been set.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MyBlackPixel</name>(dpy) BlackPixel(dpy,DefaultScreen(dpy))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MyWhitePixel</name>(dpy) WhitePixel(dpy,DefaultScreen(dpy))</cpp:define>

    <if>if <condition>(<expr><name>request</name>-&gt;<name>misc</name>.<name>re_verse</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>wnew</name>-&gt;<name>dft_foreground</name> = <call><name>MyWhitePixel</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>dft_background</name> = <call><name>MyBlackPixel</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>wnew</name>-&gt;<name>dft_foreground</name> = <call><name>MyBlackPixel</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>dft_background</name> = <call><name>MyWhitePixel</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>init_Tres</name><argument_list>(<argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Tres</name><argument_list>(<argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Color resource initialization:\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("   Default foreground %#lx\n", <name>wnew</name>-&gt;<name>dft_foreground</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("   Default background %#lx\n", <name>wnew</name>-&gt;<name>dft_background</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("   Screen foreground  %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("   Screen background  %#lx\n", <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>mouse_button</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>mouse_row</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>mouse_col</name> = -1</expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BOX_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>force_box_chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>force_packed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>force_all_chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>free_bold_box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>c132</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>curses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>hp_ll_bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_XMC_GLITCH</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>xmc_glitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>xmc_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>xmc_inline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>move_sgr_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>cursor_blink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>blink_on</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>blink_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>cursor_blink_res</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>cursor_blink</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>cursor_underline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_TEXT</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>blink_as_bold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>border</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>jumpscroll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>fastscroll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>old_fkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>delete_is_del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>keyboard</name>.<name>type</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>old_fkeys</name>
	? <name>keyboardIsLegacy</name>
	: <name>keyboardIsDefault</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>bellIsUrgent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>bellOnReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>marginbell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>multiscroll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>nmarginbell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>savelines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>scrollBarBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>scrolllines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>scrollttyoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>scrollkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>term_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>s</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name>term_id</name></expr>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr>!<call><name>isalpha</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <break>break;</break></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>terminal_id</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>terminal_id</name> &lt; <name>MIN_DECID</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>terminal_id</name> = <name>MIN_DECID</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>terminal_id</name> &gt; <name>MAX_DECID</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>terminal_id</name> = <name>MAX_DECID</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("term_id '%s' -&gt; terminal_id %d\n",
	   <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>term_id</name>,
	   <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>terminal_id</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>vtXX_level</name> = (<call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>terminal_id</name> / 100)</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>title_modes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>visualbell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>visualBellDelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>poponbell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>limit_resize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>real_NumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>alwaysUseMods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>num_lock</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>alt_mods</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>meta_mods</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>other_mods</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SHIFT_FONTS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>shift_fonts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUNPC_KBD</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>ctrl_fkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TEK4014_SHOWN</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call> = <name>False</name></expr>;</expr_stmt>	<comment type="block">/* not a resource... */</comment>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>tekInhibit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>tekSmall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>TekEmu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TCAP_QUERY</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>tc_query_code</name> = -1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>re_verse0</name> = <name>request</name>-&gt;<name>misc</name>.<name>re_verse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>re_verse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>multiClickTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>bellSuppressTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>charClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>always_highlight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>brokenSelections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>cutNewline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>cutToBeginningOfLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>highlight_selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>i18nSelections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>keepSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>selectToClipboard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>trim_selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>pointer_cursor</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name>pointer_cursor</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>pointer_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>answer_back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>printer_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>printer_autoclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>printer_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>printer_formfeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>printer_newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>printer_controlmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PRINT_COLORS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>print_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>keyboard_dialect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>input_eight_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>output_eight_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>control_eight_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>backarrow_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>alt_is_not_meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>alt_sends_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>meta_sends_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>allowSendEvent0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>allowColorOp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>allowFontOp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>allowTcapOp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>allowTitleOp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>allowWindowOp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>allowScrollLock0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>disallowedColorOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_flags_from_list</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallow_color_ops</name></expr></argument>,
			<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallowedColorOps</name></expr></argument>,
			<argument><expr><name>tblColorOps</name></expr></argument>,
			<argument><expr><name>ecLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>disallowedFontOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_flags_from_list</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallow_font_ops</name></expr></argument>,
			<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallowedFontOps</name></expr></argument>,
			<argument><expr><name>tblFontOps</name></expr></argument>,
			<argument><expr><name>efLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>disallowedTcapOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_flags_from_list</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallow_tcap_ops</name></expr></argument>,
			<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallowedTcapOps</name></expr></argument>,
			<argument><expr><name>tblTcapOps</name></expr></argument>,
			<argument><expr><name>etLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>disallowedWinOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_flags_from_list</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallow_win_ops</name></expr></argument>,
			<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>disallowedWinOps</name></expr></argument>,
			<argument><expr><name>tblWindowOps</name></expr></argument>,
			<argument><expr><name>ewLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>default_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>eightbit_select_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>utf8_select_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* make a copy so that editres cannot change the resource after startup */</comment>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowSendEvents</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowSendEvent0</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowColorOps</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowColorOp0</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowFontOps</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowFontOp0</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowTcapOps</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowTcapOp0</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowTitleOps</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowTitleOp0</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowWindowOps</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowWindowOp0</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SCROLL_LOCK</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowScrollLock</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>allowScrollLock0</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>quiet_grab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>fnt_icon</name>.<name>fs</name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name>fnt_icon</name>.<name>fs</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>active_icon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>icon_border_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>icon_border_pixel</name> = <name>request</name>-&gt;<name>misc</name>.<name>icon_border_pixel</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>titeInhibit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>tiXtraScroll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>dynamicColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name>fontMenu_font1</name></expr>;</init> <condition><expr><name>i</name> &lt;= <name>fontMenu_lastBuiltin</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><call><name>init_Sres2</name><argument_list>(<argument><expr><name>screen</name>.<name>MenuFontName</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>fontWarnings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DefaultFontNames</name> <name>TScreenOf</name>(wnew)-&gt;menu_font_names[fontMenu_default]</cpp:define>
    <expr_stmt><expr><name><name>DefaultFontNames</name><index>[<expr><name>fNorm</name></expr>]</index></name> = <name>wnew</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>DefaultFontNames</name><index>[<expr><name>fBold</name></expr>]</index></name> = <name>wnew</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_b</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><name><name>DefaultFontNames</name><index>[<expr><name>fWide</name></expr>]</index></name> = <name>wnew</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_w</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>DefaultFontNames</name><index>[<expr><name>fWBold</name></expr>]</index></name> = <name>wnew</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_wb</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_fontescape</name></expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_fontsel</name></expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>menu_font_number</name> = <name>fontMenu_default</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>screen</name>.<name>initial_font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>initial_font</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> =<init> <expr><call><name>xtermGetFont</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>initial_font</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> &gt;= 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>menu_font_number</name> = <name>result</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BROKEN_OSC</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>brokenLinuxOSC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BROKEN_ST</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>brokenStringTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_C1_PRINT</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>c1_printable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_CLIP_BOLD</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>use_clipping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>font_doublesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>cache_doublesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>cache_doublesize</name> &gt; <name>NUM_CHRSET</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>cache_doublesize</name> = <name>NUM_CHRSET</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>cache_doublesize</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>font_doublesize</name> = <name>False</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Doublesize%s enabled, up to %d fonts\n",
	   <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>font_doublesize</name> ? "" : " not",
	   <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>cache_doublesize</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>veryBoldColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>boldColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>colorAttrMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>colorBDMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>colorBLMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>colorMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>colorULMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>italicULMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>colorRVMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES2</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...will fake resources for color%d to color%d\n",
	   <name>MIN_ANSI_COLORS</name>,
	   <name>NUM_ANSI_COLORS</name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>color_ok</name> = <name>False</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>MAXCOLORS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES2</name></expr></cpp:if>
	<comment type="block">/*
	 * Xt has a hardcoded limit on the maximum number of resources that can
	 * be used in a widget.  If we configure both luit (which implies
	 * wide-characters) and 256-colors, it goes over that limit.  Most
	 * people would not need a resource-file with 256-colors; the default
	 * values in our table are sufficient.  In that case, fake the resource
	 * setting by copying the default value from the table.  The #define's
	 * can be overridden to make these true resources.
	 */</comment>
	<if>if <condition>(<expr><name>i</name> &gt;= <name>MIN_ANSI_COLORS</name> &amp;&amp; <name>i</name> &lt; <name>NUM_ANSI_COLORS</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>resource</name>
		= ((<name>char</name> *) <name><name>fake_resources</name><index>[<expr><name>i</name> - <name>MIN_ANSI_COLORS</name></expr>]</index></name>.<name>default_addr</name>)</expr>;</expr_stmt>
	    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>resource</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>resource</name> = <name>XtDefaultForeground</name></expr>;</expr_stmt></then></if>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_COLOR_RES2 */</comment>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></else></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Acolors[%d] = %s\n", <name>i</name>, <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>resource</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mode</name> = <name>False</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>DftFg</name><argument_list>(<argument><expr><name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name> = <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mode</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>DftBg</name><argument_list>(<argument><expr><name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name> = <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mode</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>color_ok</name> = <name>True</name></expr>;</expr_stmt>
	}</block></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Acolors[%d] = %#lx\n", <name>i</name>, <call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name> != <name>wnew</name>-&gt;<name>dft_foreground</name> &amp;&amp;
	    <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name> != <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call> &amp;&amp;
	    <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Acolors</name><index>[<expr><name>i</name></expr>]</index></name> != <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>color_ok</name> = <name>True</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>

    <comment type="block">/*
     * Check if we're trying to use color in a monochrome screen.  Disable
     * color in that case, since that would make ANSI colors unusable.  A 4-bit
     * or 8-bit display is usable, so we do not have to check for anything more
     * specific.
     */</comment>
    <if>if <condition>(<expr><name>color_ok</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Display</name> *</type><name>display</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>display</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XVisualInfo</name></type> <name>myTemplate</name>, *<name>visInfoPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numFound</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>myTemplate</name>.<name>visualid</name> = <call><name>XVisualIDFromVisual</name><argument_list>(<argument><expr><call><name>DefaultVisual</name><argument_list>(<argument><expr><name>display</name></expr></argument>,
								<argument><expr><call><name>XDefaultScreen</name><argument_list>(<argument><expr><name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>visInfoPtr</name> = <call><name>XGetVisualInfo</name><argument_list>(<argument><expr><name>display</name></expr></argument>, <argument><expr>(<name>long</name>) <name>VisualIDMask</name></expr></argument>,
				    <argument><expr>&amp;<name>myTemplate</name></expr></argument>, <argument><expr>&amp;<name>numFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>visInfoPtr</name> == 0
	    || <name>numFound</name> == 0
	    || <name>visInfoPtr</name>-&gt;<name>depth</name> &lt;= 1</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("disabling color since screen is monochrome\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>color_ok</name> = <name>False</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>XFree</name><argument_list>(<argument><expr><name>visInfoPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if>

    <comment type="block">/* If none of the colors are anything other than the foreground or
     * background, we'll assume this isn't color, no matter what the colorMode
     * resource says.  (There doesn't seem to be any good way to determine if
     * the resource lookup failed versus the user having misconfigured this).
     */</comment>
    <if>if <condition>(<expr>!<name>color_ok</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>colorMode</name> = <name>False</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("All colors are foreground or background: disable colorMode\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>sgr_foreground</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>sgr_background</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>sgr_extended</name> = <name>False</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_ISO_COLORS */</comment>

    <comment type="block">/*
     * Decode the resources that control the behavior on multiple mouse clicks.
     * A single click is always bound to normal character selection, but the
     * other flavors can be changed.
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NSELECTUNITS</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ck</name> =<init> <expr>(<name>i</name> + 1)</expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>maxClicks</name> = <name>ck</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>i</name> == <name>Select_CHAR</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectMap</name><index>[<expr><name>i</name></expr>]</index></name> = <name>Select_CHAR</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name><name>onClick</name><index>[<expr><name>i</name></expr>]</index></name> != 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>ParseOnClicks</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>, <argument><expr><name>request</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>i</name> &lt;= <name>Select_LINE</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectMap</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>SelectUnit</name>) <name>i</name></expr>;</expr_stmt></then>
	<else>else
	    <break>break;</break></else></if></else></if></else></if>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("on%dClicks %s=%d\n", <name>ck</name>,
	       <call><name>NonNull</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name><name>onClick</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>,
	       <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectMap</name><index>[<expr><name>i</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>selectMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>NSELECTUNITS</name></expr>)</condition><then>
	    <break>break;</break></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("maxClicks %d\n", <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>maxClicks</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Tres</name><argument_list>(<argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Tres</name><argument_list>(<argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Tres</name><argument_list>(<argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Tres</name><argument_list>(<argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Tres</name><argument_list>(<argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>hilite_reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>hilite_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>hilite_color</name> == <name>Maybe</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>hilite_color</name> = <name>False</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_COLOR_RES</name></expr></cpp:if>
	<comment type="block">/*
	 * If the highlight text/background are both set, and if they are
	 * not equal to either the text/background or background/text, then
	 * set the highlightColorMode automatically.
	 */</comment>
	<if>if <condition>(<expr>!<call><name>DftFg</name><argument_list>(<argument><expr><name><name>Tcolors</name><index>[<expr><name>HIGHLIGHT_BG</name></expr>]</index></name></expr></argument>)</argument_list></call>
	    &amp;&amp; !<call><name>DftBg</name><argument_list>(<argument><expr><name><name>Tcolors</name><index>[<expr><name>HIGHLIGHT_FG</name></expr>]</index></name></expr></argument>)</argument_list></call>
	    &amp;&amp; !<call><name>TxtFg</name><argument_list>(<argument><expr><name><name>Tcolors</name><index>[<expr><name>HIGHLIGHT_BG</name></expr>]</index></name></expr></argument>)</argument_list></call>
	    &amp;&amp; !<call><name>TxtBg</name><argument_list>(<argument><expr><name><name>Tcolors</name><index>[<expr><name>HIGHLIGHT_FG</name></expr>]</index></name></expr></argument>)</argument_list></call>
	    &amp;&amp; !<call><name>TxtBg</name><argument_list>(<argument><expr><name><name>Tcolors</name><index>[<expr><name>HIGHLIGHT_BG</name></expr>]</index></name></expr></argument>)</argument_list></call>
	    &amp;&amp; !<call><name>TxtFg</name><argument_list>(<argument><expr><name><name>Tcolors</name><index>[<expr><name>HIGHLIGHT_FG</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...setting hilite_color automatically\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>hilite_color</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <comment type="block">/*
     * The Tek4014 window has no separate resources for foreground, background
     * and cursor color.  Since xterm always creates the vt100 widget first, we
     * can set the Tektronix colors here.  That lets us use escape sequences to
     * set its dynamic colors and get consistent behavior whether or not the
     * window is displayed.
     */</comment>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEK_BG</name></expr>]</index></name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEXT_BG</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEK_FG</name></expr>]</index></name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEXT_FG</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEK_CURSOR</name></expr>]</index></name> = <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name><name>Tcolors</name><index>[<expr><name>TEXT_CURSOR</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>fontMenu_lastBuiltin</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<expr_stmt><expr><call><name>init_Dres2</name><argument_list>(<argument><expr><name>misc</name>.<name>face_size</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>misc</name>.<name>face_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>misc</name>.<name>face_wide_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>misc</name>.<name>render_font_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>render_font</name> =
	(<name>Boolean</name>) <call><name>extendedBoolean</name><argument_list>(<argument><expr><name>wnew</name>-&gt;<name>misc</name>.<name>render_font_s</name></expr></argument>,
				  <argument><expr><name>tblRenderFont</name></expr></argument>, <argument><expr><name>erLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>render_font</name> == <name>erDefault</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>IsEmpty</name><argument_list>(<argument><expr><name>wnew</name>-&gt;<name>misc</name>.<name>face_name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>face_name</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>DEFFACENAME_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("will allow runtime switch to render_font using \"%s\"\n",
		   <name>wnew</name>-&gt;<name>misc</name>.<name>face_name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>render_font</name> = <name>erTrue</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("initially using TrueType font\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if>
    <comment type="block">/* minor tweak to make debug traces consistent: */</comment>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>render_font</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>IsEmpty</name><argument_list>(<argument><expr><name>wnew</name>-&gt;<name>misc</name>.<name>face_name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>render_font</name> = <name>False</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("reset render_font since there is no face_name\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>VTInitialize_locale</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>utf8_latin1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>utf8_title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_LUIT_PROG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>callfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>use_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>misc</name>.<name>locale_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Sres</name><argument_list>(<argument><expr><name>misc</name>.<name>localefilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>utf8_inparse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>utf8_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>screen</name>.<name>max_combining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>max_combining</name> &lt; 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>max_combining</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>max_combining</name> &gt; 5</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>max_combining</name> = 5</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>vt100_graphics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>wide_chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>mk_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>misc</name>.<name>cjk_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>mk_samplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>mk_samplepass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplesize</name> &gt; 0xffff</expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplesize</name> = 0xffff</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplesize</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplesize</name> = 0</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplepass</name> &gt; <name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplesize</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplepass</name> = <name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplesize</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplepass</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>mk_samplepass</name> = 0</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name>utf8_mode</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("setting wide_chars on\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>wide_chars</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("setting utf8_mode to 0\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>utf8_mode</name> = <name>uFalse</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("initialized UTF-8 mode to %d\n", <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>utf8_mode</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MINI_LUIT</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name>latin9_mode</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>latin9_mode</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call>-&gt;<name>unicode_font</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>unicode_font</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("initialized Latin9 mode to %d\n", <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>latin9_mode</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("initialized unicode_font to %d\n", <call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>unicode_font</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>decode_wcwidth</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_WIDE_CHARS */</comment>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>always_bold_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>bold_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>underline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>wnew</name>-&gt;<name>cur_foreground</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>cur_background</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>wnew</name>-&gt;<name>keyboard</name>.<name>flags</name> = <name>MODE_SRM</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>backarrow_key</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>keyboard</name>.<name>flags</name> |= <name>MODE_DECBKM</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("initialized DECBKM %s\n",
	   <call><name>BtoS</name><argument_list>(<argument><expr><name>wnew</name>-&gt;<name>keyboard</name>.<name>flags</name> &amp; <name>MODE_DECBKM</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* look for focus related events on the shell, because we need
     * to care about the shell's border being part of our focus.
     */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("adding event handlers for my_parent %p\n", (<name>void</name> *) <name>my_parent</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtAddEventHandler</name><argument_list>(<argument><expr><name>my_parent</name></expr></argument>, <argument><expr><name>EnterWindowMask</name></expr></argument>, <argument><expr><name>False</name></expr></argument>,
		      <argument><expr><name>HandleEnterWindow</name></expr></argument>, <argument><expr>(<name>Opaque</name>) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtAddEventHandler</name><argument_list>(<argument><expr><name>my_parent</name></expr></argument>, <argument><expr><name>LeaveWindowMask</name></expr></argument>, <argument><expr><name>False</name></expr></argument>,
		      <argument><expr><name>HandleLeaveWindow</name></expr></argument>, <argument><expr>(<name>Opaque</name>) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtAddEventHandler</name><argument_list>(<argument><expr><name>my_parent</name></expr></argument>, <argument><expr><name>FocusChangeMask</name></expr></argument>, <argument><expr><name>False</name></expr></argument>,
		      <argument><expr><name>HandleFocusChange</name></expr></argument>, <argument><expr>(<name>Opaque</name>) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtAddEventHandler</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>wnew</name></expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr><name>True</name></expr></argument>,
		      <argument><expr><name>VTNonMaskableEvent</name></expr></argument>, <argument><expr>(<name>Opaque</name>) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XtAddEventHandler</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>wnew</name></expr></argument>, <argument><expr><name>PropertyChangeMask</name></expr></argument>, <argument><expr><name>False</name></expr></argument>,
		      <argument><expr><name>HandleBellPropertyChange</name></expr></argument>, <argument><expr>(<name>Opaque</name>) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HANDLE_STRUCT_NOTIFY</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
    <expr_stmt><expr><name>wnew</name>-&gt;<call><name>VT100_TB_INFO</name><argument_list>(<argument><expr><name>menu_bar</name></expr></argument>)</argument_list></call> = <name>request</name>-&gt;<call><name>VT100_TB_INFO</name><argument_list>(<argument><expr><name>menu_bar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><call><name>VT100_TB_INFO</name><argument_list>(<argument><expr><name>menu_height</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Flag icon name with "***"  on window output when iconified.
     * Put in a handler that will tell us when we get Map/Unmap events.
     */</comment>
    <if>if <condition>(<expr><name>resource</name>.<name>zIconBeep</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>XtAddEventHandler</name><argument_list>(<argument><expr><name>my_parent</name></expr></argument>, <argument><expr><name>StructureNotifyMask</name></expr></argument>, <argument><expr><name>False</name></expr></argument>,
			  <argument><expr><name>HandleStructNotify</name></expr></argument>, <argument><expr>(<name>Opaque</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HANDLE_STRUCT_NOTIFY */</comment>

    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>bellInProgress</name> = <name>False</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_character_class</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>charClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* create it, but don't realize it */</comment>
    <expr_stmt><expr><call><name>ScrollBarOn</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make sure that the resize gravity acceptable */</comment>
    <if>if <condition>(<expr>!<call><name>GravityIsNorthWest</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call> &amp;&amp;
	!<call><name>GravityIsSouthWest</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>value</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>String</name></type> <name><name>temp</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cardinal</name></type> <name>nparams</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>wnew</name>-&gt;<name>misc</name>.<name>resizeGravity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>temp</name><index>[<expr>0</expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>temp</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XtAppWarningMsg</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>, <argument><expr>"rangeError"</expr></argument>, <argument><expr>"resizeGravity"</expr></argument>, <argument><expr>"XTermError"</expr></argument>,
			<argument><expr>"unsupported resizeGravity resource value (%s)"</expr></argument>,
			<argument><expr><name>temp</name></expr></argument>, <argument><expr>&amp;<name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>misc</name>.<name>resizeGravity</name> = <name>SouthWestGravity</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>whichVwin</name> = &amp;<call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>fullVwin</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>

    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>savelines</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>savelines</name> = 0</expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>init_Bres</name><argument_list>(<argument><expr><name>screen</name>.<name>awaitInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>wnew</name>-&gt;<name>flags</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>jumpscroll</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>flags</name> |= <name>SMOOTHSCROLL</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>reverseWrap</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>flags</name> |= <name>REVERSEWRAP</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>autoWrap</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>flags</name> |= <name>WRAPAROUND</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>re_verse</name> != <name>wnew</name>-&gt;<name>misc</name>.<name>re_verse0</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>flags</name> |= <name>REVERSE_VIDEO</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call>-&gt;<name>c132</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>flags</name> |= <name>IN132COLUMNS</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>wnew</name>-&gt;<name>initflags</name> = <name>wnew</name>-&gt;<name>flags</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>cursor_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>function_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>keypad_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>other_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>keyboard</name>.<name>modify_1st</name>.<name>string_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>keyboard</name>.<name>format_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wnew</name>-&gt;<name>keyboard</name>.<name>modify_now</name> = <name>wnew</name>-&gt;<name>keyboard</name>.<name>modify_1st</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>appcursorDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>appcursorDefault</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>keyboard</name>.<name>flags</name> |= <name>MODE_DECCKM</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>init_Ires</name><argument_list>(<argument><expr><name>misc</name>.<name>appkeypadDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>wnew</name>-&gt;<name>misc</name>.<name>appkeypadDefault</name></expr>)</condition><then>
	<expr_stmt><expr><name>wnew</name>-&gt;<name>keyboard</name>.<name>flags</name> |= <name>MODE_DECKPAM</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>initLineData</name><argument_list>(<argument><expr><name>wnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>releaseCursorGCs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTwin</name> *</type><name>win</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <macro><name>for_each_curs_gc</name><argument_list>(<argument>n</argument>)</argument_list></macro> <block>{
	<expr_stmt><expr><call><name>freeCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr>(<name>CgsEnum</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
}</block></function>

<function><type><name>void</name></type>
<name>releaseWindowGCs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>VTwin</name> *</type> <name>win</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <macro><name>for_each_text_gc</name><argument_list>(<argument>n</argument>)</argument_list></macro> <block>{
	<expr_stmt><expr><call><name>freeCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr>(<name>CgsEnum</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRACE_FREE_LEAK</name>(name) \
	if (name) { \
	    free((void *) name); \
	    name = 0; \
	    TRACE(("freed " #name "\n")); \
	}</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>FREE_LEAK</name>(name) \
	if (name) { \
	    free((void *) name); \
	    name = 0; \
	}</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>cleanupInputMethod</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>xim</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>XCloseIM</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>xim</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("freed screen-&gt;xim\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>void</name></type>
<name>VTDestroy</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_LEAKS</name></cpp:ifdef>
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr>(<name>XtermWidget</name>) <name>w</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cardinal</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>StopBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>scrollWidget</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>XtUninstallTranslations</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XtDestroyWidget</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
    <while>while <condition>(<expr><name>screen</name>-&gt;<name>saved_fifo</name>-- &gt; 0</expr>)</condition> <block>{
	<expr_stmt><expr><call><name>deleteScrollback</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>screen</name>-&gt;<name>save_title</name> != 0</expr>)</condition> <block>{
	<decl_stmt><decl><type><name>SaveTitle</name> *</type><name>last</name> =<init> <expr><name>screen</name>-&gt;<name>save_title</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>save_title</name> = <name>last</name>-&gt;<name>next</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>last</name>-&gt;<name>iconName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>last</name>-&gt;<name>windowName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>save_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; 2</expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>keyboard_dialect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>term_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_LUIT_PROG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>localefilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INPUT_METHOD</name></expr></cpp:if>
    <expr_stmt><expr><call><name>cleanupInputMethod</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>releaseCursorGCs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releaseWindowGCs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>fullVwin</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <expr_stmt><expr><call><name>releaseWindowGCs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>iconVwin</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>XtUninstallTranslations</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
    <expr_stmt><expr><call><name>XtUninstallTranslations</name><argument_list>(<argument><expr>(<name>Widget</name>) <call><name>XtParent</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>XtUninstallTranslations</name><argument_list>(<argument><expr>(<name>Widget</name>) <call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>hidden_cursor</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>XFreeCursor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>hidden_cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>xtermCloseFonts</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>fnts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>noleaks_cachedCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>NMENUFONTS</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<expr_stmt><expr><call><name>xtermCloseXft</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name><name>renderFontNorm</name><index>[<expr><name>n</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermCloseXft</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name><name>renderFontBold</name><index>[<expr><name>n</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermCloseXft</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name><name>renderFontItal</name><index>[<expr><name>n</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERWIDE</name></expr></cpp:if>
	<expr_stmt><expr><call><name>xtermCloseXft</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name><name>renderWideNorm</name><index>[<expr><name>n</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermCloseXft</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name><name>renderWideBold</name><index>[<expr><name>n</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermCloseXft</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name><name>renderWideItal</name><index>[<expr><name>n</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* free things allocated via init_Sres or Init_Sres2 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALLOWLOGGING</name></cpp:ifdef>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>term_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>charClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>answer_back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>printer_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>keyboard_dialect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>disallowedColorOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>disallowedFontOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>disallowedTcapOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>disallowedWinOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>default_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>eightbit_select_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>utf8_select_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
    for (n = fontMenu_font1; n &lt;= fontMenu_lastBuiltin; n++) {
	TRACE_FREE_LEAK(screen-&gt;MenuFontName(n));
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>initial_font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_LUIT_PROG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>locale_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>localefilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>face_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>face_wide_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SELECT_REGEX</name></expr></cpp:if>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>NSELECTUNITS</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<expr_stmt><expr><call><name>FREE_LEAK</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name><name>selectExpr</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>selection_atoms</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) (<name>screen</name>-&gt;<name>selection_atoms</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>XtFree</name><argument_list>(<argument><expr>(<name>char</name> *) (<name>screen</name>-&gt;<name>selection_data</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>shell_translations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>xterm_translations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>FreeTypedBuffer</name><argument_list>(<argument><expr><name>XChar2b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeTypedBuffer</name><argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERFONT</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_RENDERWIDE</name></expr></cpp:if>
    <expr_stmt><expr><call><name>FreeTypedBuffer</name><argument_list>(<argument><expr><name>XftCharSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>FreeTypedBuffer</name><argument_list>(<argument><expr><name>XftChar8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>myState</name>.<name>print_area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_FREE_LEAK</name><argument_list>(<argument><expr><name>myState</name>.<name>string_area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>myState</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>myState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(NO_LEAKS) */</comment>
}</block></function>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><name>static</name> <name>void</name></type>
<name>VTRealize</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
	  <param><decl><type><name>XtValueMask</name> *</type> <name>valuemask</name></decl></param>,
	  <param><decl><type><name>XSetWindowAttributes</name> *</type> <name>values</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr>(<name>XtermWidget</name>) <name>w</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>const</name> <name>VTFontNames</name> *</type><name>myfont</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>width</name>, <name>height</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>xpos</name>, <name>ypos</name>, <name>pr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name></type> <name>pid_atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTRealize\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TabReset</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>tabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>menu_font_number</name> == <name>fontMenu_default</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>myfont</name> = &amp;(<name>xw</name>-&gt;<name>misc</name>.<name>default_font</name>)</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>myfont</name> = <call><name>xtermFontName</name><argument_list>(<argument><expr><name>screen</name>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>fnts</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>fnts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>xtermLoadFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
		       <argument><expr><name>myfont</name></expr></argument>,
		       <argument><expr><name>False</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>XmuCompareISOLatin1</name><argument_list>(<argument><expr><name>myfont</name>-&gt;<name>f_n</name></expr></argument>, <argument><expr><name>DEFFONT</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>char</name> *</type><name>use_font</name> =<init> <expr><call><name>x_strdup</name><argument_list>(<argument><expr><name>DEFFONT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
		    <argument><expr>"%s:  unable to open font \"%s\", trying \"%s\"....\n"</expr></argument>,
		    <argument><expr><name>xterm_name</name></expr></argument>, <argument><expr><name>myfont</name>-&gt;<name>f_n</name></expr></argument>, <argument><expr><name>use_font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>(<name>void</name>) <call><name>xtermLoadFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				 <argument><expr><call><name>xtermFontName</name><argument_list>(<argument><expr><name>use_font</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>False</name></expr></argument>,
				 <argument><expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call> = <name>use_font</name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <comment type="block">/* really screwed if we couldn't open default font */</comment>
    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name><name>fnts</name><index>[<expr><name>fNorm</name></expr>]</index></name>.<name>fs</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s:  unable to locate a suitable font\n"</expr></argument>,
		<argument><expr><name>xterm_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>utf8_mode</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("check if this is a wide font, if not try again\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>xtermLoadWideFonts</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>SetVTFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></argument>, <argument><expr><name>True</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* making cursor */</comment>
    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>pointer_cursor</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>pointer_cursor</name> =
	    <call><name>make_colored_cursor</name><argument_list>(<argument><expr><name>XC_xterm</name></expr></argument>,
				<argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>recolor_cursor</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>pointer_cursor</name></expr></argument>,
		       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* set defaults */</comment>
    <expr_stmt><expr><name>xpos</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>ypos</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>width</name> = 80</expr>;</expr_stmt>
    <expr_stmt><expr><name>height</name> = 24</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("parsing geo_metry %s\n", <call><name>NonNull</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>geo_metry</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pr</name> = <call><name>XParseGeometry</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>geo_metry</name></expr></argument>, <argument><expr>&amp;<name>xpos</name></expr></argument>, <argument><expr>&amp;<name>ypos</name></expr></argument>,
			<argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... position %d,%d size %dx%d\n", <name>ypos</name>, <name>xpos</name>, <name>height</name>, <name>width</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_max_col</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>width</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* units in character cells */</comment>
    <expr_stmt><expr><call><name>set_max_row</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>height</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* units in character cells */</comment>
    <expr_stmt><expr><call><name>xtermUpdateFontInfo</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>width</name> = <name>screen</name>-&gt;<name>fullVwin</name>.<name>fullwidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>height</name> = <name>screen</name>-&gt;<name>fullVwin</name>.<name>fullheight</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("... border widget %d parent %d shell %d\n",
	   <call><name>BorderWidth</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>,
	   <call><name>BorderWidth</name><argument_list>(<argument><expr><call><name>XtParent</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>,
	   <call><name>BorderWidth</name><argument_list>(<argument><expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>pr</name> &amp; <name>XValue</name>) &amp;&amp; (<name>XNegative</name> &amp; <name>pr</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xpos</name> += (<call><name>DisplayWidth</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>DefaultScreen</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		 - (<name>int</name>) <name>width</name>
		 - (<call><name>BorderWidth</name><argument_list>(<argument><expr><call><name>XtParent</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> * 2))</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>pr</name> &amp; <name>YValue</name>) &amp;&amp; (<name>YNegative</name> &amp; <name>pr</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ypos</name> += (<call><name>DisplayHeight</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>DefaultScreen</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		 - (<name>int</name>) <name>height</name>
		 - (<call><name>BorderWidth</name><argument_list>(<argument><expr><call><name>XtParent</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> * 2))</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* set up size hints for window manager; min 1 char by 1 char */</comment>
    <expr_stmt><expr><call><name>getXtermSizeHints</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>xtermSizeHints</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>(<name>xw</name>-&gt;<name>misc</name>.<name>scrollbar</name>
			? (<name>screen</name>-&gt;<name>scrollWidget</name>-&gt;<name>core</name>.<name>width</name>
			   + <call><name>BorderWidth</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call>)
			: 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>x</name> = <name>xpos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>y</name> = <name>ypos</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>XValue</name> &amp; <name>pr</name>) || (<name>YValue</name> &amp; <name>pr</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name> |= <name>USSize</name> | <name>USPosition</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name> |= <name>PWinGravity</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>pr</name> &amp; (<name>XNegative</name> | <name>YNegative</name>)</expr>)</condition> <block>{
	<case>case <expr>0</expr>:
	    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>win_gravity</name> = <name>NorthWestGravity</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>XNegative</name></expr>:
	    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>win_gravity</name> = <name>NorthEastGravity</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr><name>YNegative</name></expr>:
	    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>win_gravity</name> = <name>SouthWestGravity</name></expr>;</expr_stmt>
	    <break>break;</break>
	</case><default>default:
	    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>win_gravity</name> = <name>SouthEastGravity</name></expr>;</expr_stmt>
	    <break>break;</break>
	</default>}</block></switch>
    }</block></then> <else>else <block>{
	<comment type="block">/* set a default size, but do *not* set position */</comment>
	<expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name> |= <name>PSize</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>height</name> = <name>xw</name>-&gt;<name>hints</name>.<name>base_height</name>
	+ <name>xw</name>-&gt;<name>hints</name>.<name>height_inc</name> * <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>width</name> = <name>xw</name>-&gt;<name>hints</name>.<name>base_width</name>
	+ <name>xw</name>-&gt;<name>hints</name>.<name>width_inc</name> * <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>WidthValue</name> &amp; <name>pr</name>) || (<name>HeightValue</name> &amp; <name>pr</name>)</expr>)</condition><then>
	<expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name> |= <name>USSize</name></expr>;</expr_stmt></then>
    <else>else
	<expr_stmt><expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name> |= <name>PSize</name></expr>;</expr_stmt></else></if>

    <comment type="block">/*
     * Note that the size-hints are for the shell, while the resize-request
     * is for the vt100 widget.  They are not the same size.
     */</comment>
    <expr_stmt><expr>(<name>void</name>) <call><name>REQ_RESIZE</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>,
		      <argument><expr>(<name>Dimension</name>) <name>width</name></expr></argument>, <argument><expr>(<name>Dimension</name>) <name>height</name></expr></argument>,
		      <argument><expr>&amp;<name>xw</name>-&gt;<name>core</name>.<name>width</name></expr></argument>, <argument><expr>&amp;<name>xw</name>-&gt;<name>core</name>.<name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XXX This is bogus.  We are parsing geometries too late.  This
     * is information that the shell widget ought to have before we get
     * realized, so that it can do the right thing.
     */</comment>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>hints</name>.<name>flags</name> &amp; <name>USPosition</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>XMoveWindow</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>xw</name>-&gt;<name>hints</name>.<name>x</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>hints</name>.<name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s@%d -- ", <name>__FILE__</name>, <name>__LINE__</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_HINTS</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>hints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XSetWMNormalHints</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>xw</name>-&gt;<name>hints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s@%d -- ", <name>__FILE__</name>, <name>__LINE__</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_WM_HINTS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>pid_atom</name> = <call><name>XInternAtom</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"_NET_WM_PID"</expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call>) != <name>None</name></expr>)</condition><then> <block>{
	<comment type="block">/* XChangeProperty format 32 really is "long" */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>pid_l</name> =<init> <expr>(<name>unsigned</name> <name>long</name>) <call><name>getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Setting _NET_WM_PID property to %lu\n", <name>pid_l</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>XChangeProperty</name><argument_list>(<argument>XtDisplay(xw)</argument>, <argument>VShellWindow</argument>,
			<argument>pid_atom</argument>, <argument>XA_CARDINAL</argument>, <argument>32</argument>, <argument>PropModeReplace</argument>,
			<argument>(unsigned char *) &amp;pid_l</argument>, <argument>1</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>XFlush</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* get it out to window manager */</comment>

    <comment type="block">/* use ForgetGravity instead of SouthWestGravity because translating
       the Expose events for ConfigureNotifys is too hard */</comment>
    <expr_stmt><expr><name>values</name>-&gt;<name>bit_gravity</name> = (<call><name>GravityIsNorthWest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
			   ? <name>NorthWestGravity</name>
			   : <name>ForgetGravity</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>fullVwin</name>.<name>window</name> = <call><name>XtWindow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call> =
	<call><name>XCreateWindow</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><call><name>XtParent</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><name>xw</name>-&gt;<name>core</name>.<name>x</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>core</name>.<name>y</name></expr></argument>,
		      <argument><expr><name>xw</name>-&gt;<name>core</name>.<name>width</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>core</name>.<name>height</name></expr></argument>, <argument><expr><call><name>BorderWidth</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr>(<name>int</name>) <name>xw</name>-&gt;<name>core</name>.<name>depth</name></expr></argument>,
		      <argument><expr><name>InputOutput</name></expr></argument>, <argument><expr><name>CopyFromParent</name></expr></argument>,
		      <argument><expr>*<name>valuemask</name> | <name>CWBitGravity</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>event_mask</name> = <name>values</name>-&gt;<name>event_mask</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>active_icon</name> &amp;&amp; <name>screen</name>-&gt;<name>fnt_icon</name>.<name>fs</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>iconX</name> =<init> <expr>0</expr>, <expr><name>iconY</name> = 0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Widget</name></type> <name>shell</name> =<init> <expr><call><name>SHELL_OF</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VTwin</name> *</type><name>win</name> =<init> <expr>&amp;(<name>screen</name>-&gt;<name>iconVwin</name>)</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Initializing active-icon\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XtVaGetValues</name><argument_list>(<argument><expr><name>shell</name></expr></argument>, <argument><expr><name>XtNiconX</name></expr></argument>, <argument><expr>&amp;<name>iconX</name></expr></argument>, <argument><expr><name>XtNiconY</name></expr></argument>, <argument><expr>&amp;<name>iconY</name></expr></argument>, <argument><expr>(<name>XtPointer</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xtermComputeFontInfo</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>iconVwin</name>)</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>fnt_icon</name>.<name>fs</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* since only one client is permitted to select for Button
	 * events, we have to let the window manager get 'em...
	 */</comment>
	<expr_stmt><expr><name>values</name>-&gt;<name>event_mask</name> &amp;= ~(<name>ButtonPressMask</name> | <name>ButtonReleaseMask</name>)</expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name>-&gt;<name>border_pixel</name> = <name>xw</name>-&gt;<name>misc</name>.<name>icon_border_pixel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>window</name> =
	    <call><name>XCreateWindow</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><call><name>RootWindowOfScreen</name><argument_list>(<argument><expr><call><name>XtScreen</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name>iconX</name></expr></argument>, <argument><expr><name>iconY</name></expr></argument>,
			  <argument><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>fullwidth</name></expr></argument>,
			  <argument><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>fullheight</name></expr></argument>,
			  <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>icon_border_width</name></expr></argument>,
			  <argument><expr>(<name>int</name>) <name>xw</name>-&gt;<name>core</name>.<name>depth</name></expr></argument>,
			  <argument><expr><name>InputOutput</name></expr></argument>, <argument><expr><name>CopyFromParent</name></expr></argument>,
			  <argument><expr>*<name>valuemask</name> | <name>CWBitGravity</name> | <name>CWBorderPixel</name></expr></argument>,
			  <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XtVaSetValues</name><argument_list>(<argument><expr><name>shell</name></expr></argument>,
		      <argument><expr><name>XtNiconWindow</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>window</name></expr></argument>,
		      <argument><expr>(<name>XtPointer</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XtRegisterDrawable</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>window</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setCgsFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>fnt_icon</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>, <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copyCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcBold</name></expr></argument>, <argument><expr><name>gcNorm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setCgsFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>, <argument><expr>&amp;(<name>screen</name>-&gt;<name>fnt_icon</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>, <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>, <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copyCgs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcBoldReverse</name></expr></argument>, <argument><expr><name>gcNormReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOOLBAR</name></expr></cpp:if>
	<comment type="block">/*
	 * Toolbar is initialized before we get here.  Enable the menu item
	 * and set it properly.
	 */</comment>
	<expr_stmt><expr><call><name>SetItemSensitivity</name><argument_list>(<argument><expr><name><name>vtMenuEntries</name><index>[<expr><name>vtMenu_activeicon</name></expr>]</index></name>.<name>widget</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_activeicon</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Disabled active-icon\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>active_icon</name> = <name>False</name></expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_I18N_SUPPORT</name> &amp;&amp; <name>OPT_INPUT_METHOD</name></expr></cpp:if>
    <expr_stmt><expr><call><name>VTInitI18N</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>xic</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_NUM_LOCK</name></expr></cpp:if>
    <expr_stmt><expr><call><name>VTInitModifiers</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_EXTRA_PASTE</name></expr></cpp:if>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>XtOverrideTranslations</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>,
			       <argument><expr><call><name>XtParseTranslationTable</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>extra_translations</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>set_cursor_gcs</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset variables used by ANSI emulation. */</comment>

    <expr_stmt><expr><call><name>resetCharsets</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XDefineCursor</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>VShellWindow</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>pointer_cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_cur_col</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_cur_row</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_max_col</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>Width</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> / <name>screen</name>-&gt;<name>fullVwin</name>.<name>f_width</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_max_row</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>Height</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> / <name>screen</name>-&gt;<name>fullVwin</name>.<name>f_height</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_tb_margins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>sc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>sc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Mark screen buffer as unallocated.  We wait until the run loop so
       that the child process does not fork and exec with all the dynamic
       memory it will never use.  If we were to do it here, the
       swap space for new process would be huge for huge savelines. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TEK4014</name></expr></cpp:if>
    <if>if <condition>(<expr>!<name>tekWidget</name></expr>)</condition><then>		<comment type="block">/* if not called after fork */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>visbuf</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>saveBuf_index</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>do_wrap</name> = <name>False</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>scrolls</name> = <name>screen</name>-&gt;<name>incopy</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>xtermSetCursorBox</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = 0</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 2</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>whichBuf</name> = !<name>screen</name>-&gt;<name>whichBuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CursorSave</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/*
     * Do this last, since it may change the layout via a resize.
     */</comment>
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>scrollbar</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>fullVwin</name>.<name>sb_info</name>.<name>width</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScrollBarOn</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_I18N_SUPPORT</name> &amp;&amp; <name>OPT_INPUT_METHOD</name></expr></cpp:if>

<comment type="block">/* limit this feature to recent XFree86 since X11R6.x core dumps */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XtSpecificationRelease</name></expr></argument>)</argument_list></call> &amp;&amp; <name>XtSpecificationRelease</name> &gt;= 6 &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>X_HAVE_UTF8_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>USE_XIM_INSTANTIATE_CB</name></cpp:define>

<function><type><name>static</name> <name>void</name></type>
<name>xim_instantiate_cb</name><parameter_list>(<param><decl><type><name>Display</name> *</type> <name>display</name></decl></param>,
		   <param><decl><type><name>XPointer</name> <name>client_data</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>XPointer</name> <name>call_data</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>display</name> != <call><name>XtDisplay</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>VTInitI18N</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>xim_destroy_cb</name><parameter_list>(<param><decl><type><name>XIM</name> <name>im</name></type> <name>GCC_UNUSED</name></decl></param>,
	       <param><decl><type><name>XPointer</name> <name>client_data</name></type> <name>GCC_UNUSED</name></decl></param>,
	       <param><decl><type><name>XPointer</name> <name>call_data</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call>-&gt;<name>xic</name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>XRegisterIMInstantiateCallback</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				   <argument><expr><name>xim_instantiate_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* X11R6+ */</comment>

<function><type><name>static</name> <name>void</name></type>
<name>xim_real_init</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name>, *<name>s</name>, *<name>t</name>, *<name>ns</name>, *<name>end</name>, <name><name>buf</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XIMStyles</name> *</type><name>xim_styles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XIMStyle</name></type> <name>input_style</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>code</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>known_style</name><index>[]</index></name> = <block>{
	<expr><block>{
	    <expr>"OverTheSpot"</expr>, <expr>(<name>XIMPreeditPosition</name> | <name>XIMStatusNothing</name>)</expr>
	}</block></expr>,
	<expr><block>{
	    <expr>"OffTheSpot"</expr>, <expr>(<name>XIMPreeditArea</name> | <name>XIMStatusArea</name>)</expr>
	}</block></expr>,
	<expr><block>{
	    <expr>"Root"</expr>, <expr>(<name>XIMPreeditNothing</name> | <name>XIMStatusNothing</name>)</expr>
	}</block></expr>,
    }</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>xic</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>cannot_im</name></expr>)</condition><then> <block>{
	<return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>xw</name>-&gt;<name>misc</name>.<name>input_method</name> || !*<name>xw</name>-&gt;<name>misc</name>.<name>input_method</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>p</name> = <call><name>XSetLocaleModifiers</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp; *<name>p</name></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>xim</name> = <call><name>XOpenIM</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>s</name> = <name>xw</name>-&gt;<name>misc</name>.<name>input_method</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> = 5 + (<name>unsigned</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>t</name> = (<name>char</name> *) <call><name>MyStackAlloc</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_VINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{

	    <for>for (<init><expr><name>ns</name> = <name>s</name></expr>;</init> <condition><expr><name>ns</name> &amp;&amp; *<name>s</name></expr>;</condition><incr/>) <block>{
		<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		    <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
		<if>if <condition>(<expr>!*<name>s</name></expr>)</condition><then>
		    <break>break;</break></then></if>
		<if>if <condition>(<expr>(<name>ns</name> = <name>end</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
		    <expr_stmt><expr><name>end</name> = <name>s</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<while>while <condition>(<expr>(<name>end</name> != <name>s</name>) &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name><name>end</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		    <expr_stmt><expr><name>end</name>--</expr>;</expr_stmt></while>

		<if>if <condition>(<expr><name>end</name> != <name>s</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>"@im="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>size_t</name>) <argument_list>(<argument><expr><name>end</name> - <name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <if>if <condition>(<expr>(<name>p</name> = <call><name>XSetLocaleModifiers</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; *<name>p</name>
			&amp;&amp; (<name>screen</name>-&gt;<name>xim</name> = <call><name>XOpenIM</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<break>break;</break></then></if>

		}</block></then></if>
		<expr_stmt><expr><name>s</name> = <name>ns</name> + 1</expr>;</expr_stmt>
	    }</block></for>
	    <expr_stmt><expr><call><name>MyStackFree</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></else></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>xim</name> == <name>NULL</name>
	&amp;&amp; (<name>p</name> = <call><name>XSetLocaleModifiers</name><argument_list>(<argument><expr>"@im=none"</expr></argument>)</argument_list></call>) != <name>NULL</name>
	&amp;&amp; *<name>p</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>xim</name> = <call><name>XOpenIM</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>xim</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to open input method\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("VTInitI18N opened input method\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>XGetIMValues</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xim</name></expr></argument>, <argument><expr><name>XNQueryInputStyle</name></expr></argument>, <argument><expr>&amp;<name>xim_styles</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
	|| !<name>xim_styles</name>
	|| !<name>xim_styles</name>-&gt;<name>count_styles</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"input method doesn't support any style\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cleanupInputMethod</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>cannot_im</name> = <name>True</name></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>found</name> = <name>False</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>s</name> = <name>xw</name>-&gt;<name>misc</name>.<name>preedit_type</name></expr>;</init> <condition><expr><name>s</name> &amp;&amp; !<name>found</name></expr>;</condition><incr/>) <block>{
	<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
	<if>if <condition>(<expr>!*<name>s</name></expr>)</condition><then>
	    <break>break;</break></then></if>
	<if>if <condition>(<expr>(<name>ns</name> = <name>end</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
	    <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>end</name> = <name>s</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<while>while <condition>(<expr>(<name>end</name> != <name>s</name>) &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name><name>end</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	    <expr_stmt><expr><name>end</name>--</expr>;</expr_stmt></while>

	<if>if <condition>(<expr><name>end</name> != <name>s</name></expr>)</condition><then> <block>{		<comment type="block">/* just in case we have a spurious comma */</comment>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("looking for style '%.*s'\n", <call>(<name>int</name>) <argument_list>(<argument><expr><name>end</name> - <name>s</name></expr></argument>)</argument_list></call>, <name>s</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>known_style</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>(<name>int</name>) <call><name>strlen</name><argument_list>(<argument><expr><name><name>known_style</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call> == (<name>end</name> - <name>s</name>)
		    &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>known_style</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><call>(<name>size_t</name>) <argument_list>(<argument><expr><name>end</name> - <name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>input_style</name> = <name><name>known_style</name><index>[<expr><name>i</name></expr>]</index></name>.<name>code</name></expr>;</expr_stmt>
		    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>xim_styles</name>-&gt;<name>count_styles</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name>input_style</name> == <name>xim_styles</name>-&gt;<name><name>supported_styles</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name>found</name> = <name>True</name></expr>;</expr_stmt>
			    <break>break;</break>
			}</block></then></if>
		    }</block></for>
		    <if>if <condition>(<expr><name>found</name></expr>)</condition><then>
			<break>break;</break></then></if>
		}</block></then></if>
	    }</block></for>
	}</block></then></if>

	<expr_stmt><expr><name>s</name> = <name>ns</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>XFree</name><argument_list>(<argument><expr><name>xim_styles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>found</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
		<argument><expr>"input method doesn't support my preedit type (%s)\n"</expr></argument>,
		<argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>preedit_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cleanupInputMethod</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>cannot_im</name> = <name>True</name></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * Check for styles we do not yet support.
     */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("input_style %#lx\n", <name>input_style</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>input_style</name> == (<name>XIMPreeditArea</name> | <name>XIMStatusArea</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
		<argument><expr>"This program doesn't support the 'OffTheSpot' preedit type\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cleanupInputMethod</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>cannot_im</name> = <name>True</name></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * For XIMPreeditPosition (or OverTheSpot), XIM client has to
     * prepare a font.
     * The font has to be locale-dependent XFontSet, whereas
     * XTerm use Unicode font.  This leads a problem that the
     * same font cannot be used for XIM preedit.
     */</comment>
    <if>if <condition>(<expr><name>input_style</name> != (<name>XIMPreeditNothing</name> | <name>XIMStatusNothing</name>)</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>char</name> **</type><name>missing_charset_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>missing_charset_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>def_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XVaNestedList</name></type> <name>p_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XPoint</name></type> <name>spot</name> =<init>
	<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XFontStruct</name> **</type><name>fonts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type><name>font_name_list</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>screen</name>-&gt;<name>fs</name> = <call><name>XCreateFontSet</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>f_x</name></expr></argument>,
				    <argument><expr>&amp;<name>missing_charset_list</name></expr></argument>,
				    <argument><expr>&amp;<name>missing_charset_count</name></expr></argument>,
				    <argument><expr>&amp;<name>def_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>fs</name> == <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Preparation of font set "
		    "\"%s\" for XIM failed.\n"</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>misc</name>.<name>f_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>fs</name> = <call><name>XCreateFontSet</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>DEFXIMFONT</name></expr></argument>,
					<argument><expr>&amp;<name>missing_charset_list</name></expr></argument>,
					<argument><expr>&amp;<name>missing_charset_count</name></expr></argument>,
					<argument><expr>&amp;<name>def_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>fs</name> == <name>NULL</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Preparation of default font set "
		    "\"%s\" for XIM failed.\n"</expr></argument>, <argument><expr><name>DEFXIMFONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>cleanupInputMethod</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>xw</name>-&gt;<name>misc</name>.<name>cannot_im</name> = <name>True</name></expr>;</expr_stmt>
	    <return>return;</return>
	}</block></then></if>
	<expr_stmt><expr>(<name>void</name>) <call><name>XExtentsOfFontSet</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> = (<name>unsigned</name>) <call><name>XFontsOfFontSet</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>fs</name></expr></argument>, <argument><expr>&amp;<name>fonts</name></expr></argument>, <argument><expr>&amp;<name>font_name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>screen</name>-&gt;<name>fs_ascent</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>fs_ascent</name> &lt; (*<name>fonts</name>)-&gt;<name>ascent</name></expr>)</condition><then>
		<expr_stmt><expr><name>screen</name>-&gt;<name>fs_ascent</name> = (*<name>fonts</name>)-&gt;<name>ascent</name></expr>;</expr_stmt></then></if>
	}</block></for>
	<expr_stmt><expr><name>p_list</name> = <call><name>XVaCreateNestedList</name><argument_list>(<argument><expr>0</expr></argument>,
				     <argument><expr><name>XNSpotLocation</name></expr></argument>, <argument><expr>&amp;<name>spot</name></expr></argument>,
				     <argument><expr><name>XNFontSet</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>fs</name></expr></argument>,
				     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>xic</name> = <call><name>XCreateIC</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xim</name></expr></argument>,
				<argument><expr><name>XNInputStyle</name></expr></argument>, <argument><expr><name>input_style</name></expr></argument>,
				<argument><expr><name>XNClientWindow</name></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>XNFocusWindow</name></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>XNPreeditAttributes</name></expr></argument>, <argument><expr><name>p_list</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>xic</name> = <call><name>XCreateIC</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xim</name></expr></argument>, <argument><expr><name>XNInputStyle</name></expr></argument>, <argument><expr><name>input_style</name></expr></argument>,
				<argument><expr><name>XNClientWindow</name></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>XNFocusWindow</name></expr></argument>, <argument><expr><call><name>XtWindow</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>xic</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to create input context\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cleanupInputMethod</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_XIM_INSTANTIATE_CB</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <else>else <block>{
	<decl_stmt><decl><type><name>XIMCallback</name></type> <name>destroy_cb</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>destroy_cb</name>.<name>callback</name> = <name>xim_destroy_cb</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>destroy_cb</name>.<name>client_data</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>XSetIMValues</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>xim</name></expr></argument>, <argument><expr><name>XNDestroyCallback</name></expr></argument>, <argument><expr>&amp;<name>destroy_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Could not set destroy callback to IM\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>VTInitI18N</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>xw</name>-&gt;<name>misc</name>.<name>open_im</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>xim_real_init</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_XIM_INSTANTIATE_CB</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>xic</name> == <name>NULL</name>
	    &amp;&amp; !<name>xw</name>-&gt;<name>misc</name>.<name>cannot_im</name>
	    &amp;&amp; <name>xw</name>-&gt;<name>misc</name>.<name>retry_im</name>-- &gt; 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XRegisterIMInstantiateCallback</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>xim_instantiate_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_I18N_SUPPORT &amp;&amp; OPT_INPUT_METHOD */</comment>

<function><type><name>static</name> <name>Boolean</name></type>
<name>VTSetValues</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>cur</name></decl></param>,
	    <param><decl><type><name>Widget</name> <name>request</name></type> <name>GCC_UNUSED</name></decl></param>,
	    <param><decl><type><name>Widget</name></type> <name>wnew</name></decl></param>,
	    <param><decl><type><name>ArgList</name> <name>args</name></type> <name>GCC_UNUSED</name></decl></param>,
	    <param><decl><type><name>Cardinal</name> *<name>num_args</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>curvt</name> =<init> <expr>(<name>XtermWidget</name>) <name>cur</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>newvt</name> =<init> <expr>(<name>XtermWidget</name>) <name>wnew</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>refresh_needed</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>fonts_redone</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call> !=
	 <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call>) ||
	(<call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call> !=
	 <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call>) ||
	(<call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call> !=
	 <call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call>) ||
	(<name>curvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name> != <name>newvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name>)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>curvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name> != <name>newvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_default</name></expr></argument>)</argument_list></call> = <name>newvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><call><name>xtermLoadFont</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>,
			  <argument><expr><call><name>xtermFontName</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name>True</name></expr></argument>, <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call>-&gt;<name>menu_font_number</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* resizing does the redisplay, so don't ask for it here */</comment>
	    <expr_stmt><expr><name>refresh_needed</name> = <name>True</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>fonts_redone</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>curvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name> != <name>newvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_default</name></expr></argument>)</argument_list></call> = <name>curvt</name>-&gt;<name>misc</name>.<name>default_font</name>.<name>f_n</name></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>fonts_redone</name>
	&amp;&amp; (<call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> !=
	    <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>set_cursor_gcs</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refresh_needed</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>curvt</name>-&gt;<name>misc</name>.<name>re_verse</name> != <name>newvt</name>-&gt;<name>misc</name>.<name>re_verse</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>newvt</name>-&gt;<name>flags</name> ^= <name>REVERSE_VIDEO</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReverseVideo</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ReverseVideo toggles */</comment>
	<expr_stmt><expr><name>newvt</name>-&gt;<name>misc</name>.<name>re_verse</name> = <call>(<name>Boolean</name>) <argument_list>(<argument><expr>!<name>newvt</name>-&gt;<name>misc</name>.<name>re_verse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refresh_needed</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>(<call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call> !=
	 <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call>) ||
	(<call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>curvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call> !=
	 <call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>recolor_cursor</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call>-&gt;<name>pointer_cursor</name></expr></argument>,
		       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MOUSE_FG</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><call><name>T_COLOR</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MOUSE_BG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refresh_needed</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>curvt</name>-&gt;<name>misc</name>.<name>scrollbar</name> != <name>newvt</name>-&gt;<name>misc</name>.<name>scrollbar</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ToggleScrollBar</name><argument_list>(<argument><expr><name>newvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>refresh_needed</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>setGC</name>(code) set_at = __LINE__, currentCgs = code</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>OutsideSelection</name>(screen,srow,scol)  \
	 ((srow) &gt; (screen)-&gt;endH.row || \
	  ((srow) == (screen)-&gt;endH.row &amp;&amp; \
	   (scol) &gt;= (screen)-&gt;endH.col) || \
	  (srow) &lt; (screen)-&gt;startH.row || \
	  ((srow) == (screen)-&gt;startH.row &amp;&amp; \
	   (scol) &lt; (screen)-&gt;startH.col))</cpp:define>

<comment type="block">/*
 * Shows cursor at new cursor position in screen.
 */</comment>
<function><type><name>void</name></type>
<name>ShowCursor</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name>, <name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IChar</name></type> <name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CellColor</name></type> <name>fg_bg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GC</name></type> <name>currentGC</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GC</name></type> <name>outlineGC</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CgsEnum</name></type> <name>currentCgs</name> =<init> <expr><name>gcMAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTwin</name> *</type><name>currentWin</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>set_at</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>in_selection</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>reversed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>filled</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg_pix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg_pix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>tmp</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>selbg_pix</name> =<init> <expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_BG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>selfg_pix</name> =<init> <expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>HIGHLIGHT_FG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>use_selbg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>use_selfg</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>my_col</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>cursor_col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> == <name>BLINKED_OFF</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>eventMode</name> != <name>NORMAL</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <if>if <condition>(<expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>row</name> = <name>screen</name>-&gt;<name>cur_row</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cursor_col</name> = <name>screen</name>-&gt;<name>cursorp</name>.<name>col</name> = <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_moved</name> = <name>False</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <if>if <condition>(<expr><call><name>IsIcon</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>ON</name></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>

    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>base</name> = <name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>cursor_col</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> = <name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>cursor_col</name></expr>]</index></name></expr>;</expr_stmt>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	if (base == HIDDEN_CHAR &amp;&amp; cursor_col &gt; 0) {
	    <comment type="block">/* if cursor points to non-initial part of wide character,
	     * back it up
	     */</comment>
	    --cursor_col;
	    base = ld-&gt;charData[cursor_col];
	}
	my_col = cursor_col;
	if (base == 0)
	    base = ' ';
	if (isWide((int) base))
	    my_col += 1;
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr><name>base</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>base</name> = ' '</expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXP_BOGUS_FG</name></cpp:ifdef>
    <comment type="block">/*
     * If the cursor happens to be on blanks, and we have not set both
     * foreground and background color, do not treat it as a colored cell.
     */</comment>
    <if>if <condition>(<expr><name>base</name> == ' '</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>flags</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name>)) == <name>BG_COLOR</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ShowCursor - do not treat as a colored cell\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>flags</name> &amp;= ~(<name>FG_COLOR</name> | <name>BG_COLOR</name>)</expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr>(<name>flags</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name>)) == <name>FG_COLOR</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ShowCursor - should we treat as a colored cell?\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!(<name>xw</name>-&gt;<name>flags</name> &amp; <name>FG_COLOR</name>)</expr>)</condition><then>
		<if>if <condition>(<expr><call><name>CheckBogusForeground</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>"ShowCursor"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>flags</name> &amp;= ~(<name>FG_COLOR</name> | <name>BG_COLOR</name>)</expr>;</expr_stmt></then></if></then></if>
	}</block></then></if></else></if>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !EXP_BOGUS_FG */</comment>
    <comment type="block">/*
     * If the cursor happens to be on blanks, and the foreground color is set
     * but not the background, do not treat it as a colored cell.
     */</comment>
    <if>if <condition>(<expr>(<name>flags</name> &amp; <call><name>TERM_COLOR_FLAGS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>) == <name>BG_COLOR</name>
	&amp;&amp; <name>base</name> == ' '</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>flags</name> &amp;= <call><name>~<name>TERM_COLOR_FLAGS</name></name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Compare the current cell to the last set of colors used for the
     * cursor and update the GC's if needed.
     */</comment>
    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	fg_bg = ld-&gt;color[cursor_col];
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>fg_pix</name> = <call><name>getXtermForeground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>extract_fg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bg_pix</name> = <call><name>getXtermBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>extract_bg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>OutsideSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>in_selection</name> = <name>False</name></expr>;</expr_stmt></then>
    <else>else
	<expr_stmt><expr><name>in_selection</name> = <name>True</name></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><name>reversed</name> = <call><name>ReverseOrHilite</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>in_selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This is like updatedXtermGC(), except that we have to worry about
     * whether the window has focus, since in that case we want just an
     * outline for the cursor.
     */</comment>
    <expr_stmt><expr><name>filled</name> = (<name>screen</name>-&gt;<name>select</name> || <name>screen</name>-&gt;<name>always_highlight</name>) &amp;&amp; !<name>screen</name>-&gt;<name>cursor_underline</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
    <expr_stmt><expr><name>use_selbg</name> = <call><name>isNotForeground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>, <argument><expr><name>selbg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>use_selfg</name> = <call><name>isNotBackground</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>, <argument><expr><name>selfg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>filled</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>reversed</name></expr>)</condition><then> <block>{		<comment type="block">/* text is reverse video */</comment>
	    <if>if <condition>(<expr><call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gcVTcursNormal</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcVTcursNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<if>if <condition>(<expr><name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcBold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcNorm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	    }</block></else></if>
	    <expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>fg_pix</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>hilite_reverse</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>use_selbg</name> &amp;&amp; !<name>use_selfg</name></expr>)</condition><then>
		    <expr_stmt><expr><name>fg_pix</name> = <name>bg_pix</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>use_selfg</name> &amp;&amp; !<name>use_selbg</name></expr>)</condition><then>
		    <expr_stmt><expr><name>bg_pix</name> = <name>fg_pix</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>use_selbg</name></expr>)</condition><then>
		    <expr_stmt><expr><name>bg_pix</name> = <name>selbg_pix</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>use_selfg</name></expr>)</condition><then>
		    <expr_stmt><expr><name>fg_pix</name> = <name>selfg_pix</name></expr>;</expr_stmt></then></if>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{		<comment type="block">/* normal video */</comment>
	    <if>if <condition>(<expr><call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gcVTcursReverse</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcVTcursReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<if>if <condition>(<expr><name>flags</name> &amp; <call><name>BOLDATTR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcBoldReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcNormReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	    }</block></else></if>
	}</block></else></if>
	<if>if <condition>(<expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> == <name>xw</name>-&gt;<name>dft_foreground</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{			<comment type="block">/* not selected */</comment>
	<if>if <condition>(<expr><name>reversed</name></expr>)</condition><then> <block>{		<comment type="block">/* text is reverse video */</comment>
	    <expr_stmt><expr><call><name>EXCHANGE</name><argument_list>(<argument><expr><name>fg_pix</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcNormReverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{		<comment type="block">/* normal video */</comment>
	    <expr_stmt><expr><call><name>setGC</name><argument_list>(<argument><expr><name>gcNorm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_HIGHLIGHT_COLOR</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>hilite_reverse</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>in_selection</name> &amp;&amp; !<name>reversed</name></expr>)</condition><then> <block>{
		<empty_stmt>;</empty_stmt>		<comment type="block">/* really INVERSE ... */</comment>
	    }</block></then> <else>else <if>if <condition>(<expr><name>in_selection</name> || <name>reversed</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>use_selbg</name></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><name>use_selfg</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>bg_pix</name> = <name>fg_pix</name></expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><name>fg_pix</name> = <name>bg_pix</name></expr>;</expr_stmt>
		    }</block></else></if>
		}</block></then></if>
		<if>if <condition>(<expr><name>use_selbg</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>bg_pix</name> = <name>selbg_pix</name></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>use_selfg</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>fg_pix</name> = <name>selfg_pix</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if></else></if>
	}</block></then> <else>else <block>{
	    <if>if <condition>(<expr><name>in_selection</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>use_selbg</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>bg_pix</name> = <name>selbg_pix</name></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>use_selfg</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>fg_pix</name> = <name>selfg_pix</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
	}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_busy</name> == 0
	&amp;&amp; (<name>screen</name>-&gt;<name>cursor_state</name> != <name>ON</name> || <name>screen</name>-&gt;<name>cursor_GC</name> != <name>set_at</name>)</expr>)</condition><then> <block>{

	<expr_stmt><expr><name>screen</name>-&gt;<name>cursor_GC</name> = <name>set_at</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ShowCursor calling drawXtermText cur(%d,%d) %s-%s, set_at %d\n",
	       <name>screen</name>-&gt;<name>cur_row</name>, <name>screen</name>-&gt;<name>cur_col</name>,
	       (<name>filled</name> ? "filled" : "outline"),
	       (<name>screen</name>-&gt;<name>cursor_underline</name> ? "underline" : "box"),
	       <name>set_at</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>currentGC</name> = <call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> = <call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>cursor_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> = <call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_underline</name></expr>)</condition><then> <block>{

	    <comment type="block">/*
	     * Overriding the combination of filled, reversed, in_selection
	     * is too complicated since the underline and the text-cell use
	     * different rules.  Just redraw the text-cell, and draw the
	     * underline on top of it.
	     */</comment>
	    <expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/*
	     * Our current-GC is likely to have been modified in HideCursor().
	     * Setup a new request.
	     */</comment>
	    <if>if <condition>(<expr><name>filled</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call> == <name>xw</name>-&gt;<name>dft_foreground</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>fg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>currentCgs</name></expr></argument>, <argument><expr><name>bg_pix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>

	    <expr_stmt><expr><name>outlineGC</name> = <call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gcVTcursOutline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>outlineGC</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>outlineGC</name> = <name>currentGC</name></expr>;</expr_stmt></then></if>

	    <comment type="block">/*
	     * Finally, draw the underline.
	     */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>box</name>-&gt;<name>x</name> = (<name>short</name>) <name>x</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>box</name>-&gt;<name>y</name> = <call>(<name>short</name>) <argument_list>(<argument><expr><name>y</name> + <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XDrawLines</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outlineGC</name></expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>box</name></expr></argument>, <argument><expr><name>NBOX</name></expr></argument>, <argument><expr><name>CoordModePrevious</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>outlineGC</name> = <call><name>getCgsGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>currentWin</name></expr></argument>, <argument><expr><name>gcVTcursOutline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>outlineGC</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>outlineGC</name> = <name>currentGC</name></expr>;</expr_stmt></then></if>

	    <expr_stmt><expr><call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name> &amp; <name>DRAWX_MASK</name></expr></argument>,
			  <argument><expr><name>currentGC</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
			  <argument><expr><call><name>LineCharSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr>&amp;<name>base</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		for_each_combData(off, ld) {
		    if (!(ld-&gt;combData[off][my_col]))
			break;
		    drawXtermText(xw, (flags &amp; DRAWX_MASK) | NOBACKGROUND,
				  currentGC, x, y,
				  LineCharSet(screen, ld),
				  ld-&gt;combData[off] + my_col,
				  1, isWide((int) base));
		}
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	    <if>if <condition>(<expr>!<name>filled</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>box</name>-&gt;<name>x</name> = (<name>short</name>) <name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>box</name>-&gt;<name>y</name> = (<name>short</name>) <name>y</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XDrawLines</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outlineGC</name></expr></argument>,
			   <argument><expr><name>screen</name>-&gt;<name>box</name></expr></argument>, <argument><expr><name>NBOX</name></expr></argument>, <argument><expr><name>CoordModePrevious</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>ON</name></expr>;</expr_stmt>

    <return>return;</return>
}</block></function>

<comment type="block">/*
 * hide cursor at previous cursor position in screen.
 */</comment>
<function><type><name>void</name></type>
<name>HideCursor</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><name>term</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GC</name></type> <name>currentGC</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name>, <name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IChar</name></type> <name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CellColor</name></type> <name>fg_bg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>in_selection</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>my_col</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>cursor_col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> == <name>OFF</name></expr>)</condition><then>
	<return>return;</return></then></if>
    <if>if <condition>(<expr><call><name>INX2ROW</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>row</name></expr></argument>)</argument_list></call> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>cursor_col</name> = <name>screen</name>-&gt;<name>cursorp</name>.<name>col</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <if>if <condition>(<expr><call><name>IsIcon</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>OFF</name></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>

    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>base</name> = <name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>cursor_col</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> = <name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>cursor_col</name></expr>]</index></name></expr>;</expr_stmt>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	if (base == HIDDEN_CHAR &amp;&amp; cursor_col &gt; 0) {
	    <comment type="block">/* if cursor points to non-initial part of wide character,
	     * back it up
	     */</comment>
	    --cursor_col;
	    base = ld-&gt;charData[cursor_col];
	}
	my_col = cursor_col;
	if (base == 0)
	    base = ' ';
	if (isWide((int) base))
	    my_col += 1;
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr><name>base</name> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>base</name> = ' '</expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXP_BOGUS_FG</name></cpp:ifdef>
    <comment type="block">/*
     * If the cursor happens to be on blanks, and we have not set both
     * foreground and background color, do not treat it as a colored cell.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>base</name> == ' '</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>flags</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name>)) == <name>BG_COLOR</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HideCursor - do not treat as a colored cell\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>flags</name> &amp;= ~(<name>FG_COLOR</name> | <name>BG_COLOR</name>)</expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr>(<name>flags</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name>)) == <name>FG_COLOR</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HideCursor - should we treat as a colored cell?\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr>!(<name>xw</name>-&gt;<name>flags</name> &amp; <name>FG_COLOR</name>)</expr>)</condition><then>
		<if>if <condition>(<expr><call><name>CheckBogusForeground</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>"HideCursor"</expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>flags</name> &amp;= ~(<name>FG_COLOR</name> | <name>BG_COLOR</name>)</expr>;</expr_stmt></then></if></then></if>
	}</block></then></if></else></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <expr_stmt><expr><name>fg_bg</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Compare the current cell to the last set of colors used for the
     * cursor and update the GC's if needed.
     */</comment>
    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	fg_bg = ld-&gt;color[cursor_col];
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr><call><name>OutsideSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>row</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>col</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>in_selection</name> = <name>False</name></expr>;</expr_stmt></then>
    <else>else
	<expr_stmt><expr><name>in_selection</name> = <name>True</name></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><name>currentGC</name> = <call><name>updatedXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>in_selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("HideCursor calling drawXtermText cur(%d,%d)\n",
	   <name>screen</name>-&gt;<name>cursorp</name>.<name>row</name>, <name>screen</name>-&gt;<name>cursorp</name>.<name>col</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>x</name> = <call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>cursor_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> = <call><name>CursorY</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name> &amp; <name>DRAWX_MASK</name></expr></argument>,
		  <argument><expr><name>currentGC</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
		  <argument><expr><call><name>LineCharSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr>&amp;<name>base</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	for_each_combData(off, ld) {
	    if (!(ld-&gt;combData[off][my_col]))
		break;
	    drawXtermText(xw, (flags &amp; DRAWX_MASK) | NOBACKGROUND,
			  currentGC, x, y,
			  LineCharSet(screen, ld),
			  ld-&gt;combData[off] + my_col,
			  1, isWide((int) base));
	}
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>OFF</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>in_selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name> || <name>OPT_BLINK_TEXT</name></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>StartBlinking</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>blink_timer</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>interval</name> =<init> <expr>(<name>unsigned</name> <name>long</name>) ((<name>screen</name>-&gt;<name>cursor_state</name> == <name>ON</name>)
						  ? <name>screen</name>-&gt;<name>blink_on</name>
						  : <name>screen</name>-&gt;<name>blink_off</name>)</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>interval</name> == 0</expr>)</condition><then>	<comment type="block">/* wow! */</comment>
	    <expr_stmt><expr><name>interval</name> = 1</expr>;</expr_stmt></then></if>	<comment type="block">/* let's humor him anyway */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>blink_timer</name> = <call><name>XtAppAddTimeOut</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>,
					      <argument><expr><name>interval</name></expr></argument>,
					      <argument><expr><name>HandleBlinking</name></expr></argument>,
					      <argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>StopBlinking</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>blink_timer</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>XtRemoveTimeOut</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>blink_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>screen</name>-&gt;<name>blink_timer</name> = 0</expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_TEXT</name></expr></cpp:if>
<function><type><name>static</name> <name>Bool</name></type>
<name>LineHasBlinking</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>LineData</name> *</type> <name>ld</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>result</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>col</name> = 0</expr>;</init> <condition><expr><name>col</name> &lt; <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
	<if>if <condition>(<expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> &amp; <name>BLINK</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>result</name> = <name>True</name></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></then></if>
    }</block></for>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Blink the cursor by alternately showing/hiding cursor.  We leave the timer
 * running all the time (even though that's a little inefficient) to make the
 * logic simple.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>HandleBlinking</name><parameter_list>(<param><decl><type><name>XtPointer</name></type> <name>closure</name></decl></param>, <param><decl><type><name>XtIntervalId</name> * <name>id</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr>(<name>TScreen</name> *) <name>closure</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>resume</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>blink_timer</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>blink_state</name> = !<name>screen</name>-&gt;<name>blink_state</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>DoStartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> == <name>ON</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>select</name> || <name>screen</name>-&gt;<name>always_highlight</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> == <name>OFF</name></expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>BLINKED_OFF</name></expr>;</expr_stmt></then></if>
	    }</block></then></if>
	}</block></then> <else>else <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> == <name>BLINKED_OFF</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>OFF</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ShowCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name> == <name>OFF</name></expr>)</condition><then>
		<expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>BLINKED_OFF</name></expr>;</expr_stmt></then></if>
	}</block></then></if></else></if>
	<expr_stmt><expr><name>resume</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_TEXT</name></expr></cpp:if>
    <comment type="block">/*
     * Inspect the lines on the current screen to see if any have the BLINK flag
     * associated with them.  Prune off any that have had the corresponding
     * cells reset.  If any are left, repaint those lines with ScrnRefresh().
     */</comment>
    <if>if <condition>(<expr>!(<name>screen</name>-&gt;<name>blink_as_bold</name>)</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>first_row</name> =<init> <expr><name>screen</name>-&gt;<name>max_row</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>last_row</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>

	<for>for (<init><expr><name>row</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</init> <condition><expr><name>row</name> &gt;= 0</expr>;</condition> <incr><expr><name>row</name>--</expr></incr>) <block>{
	    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>ld</name> != 0 &amp;&amp; <call><name>LineTstBlinked</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>LineHasBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>resume</name> = <name>True</name></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>row</name> &gt; <name>last_row</name></expr>)</condition><then>
			<expr_stmt><expr><name>last_row</name> = <name>row</name></expr>;</expr_stmt></then></if>
		    <if>if <condition>(<expr><name>row</name> &lt; <name>first_row</name></expr>)</condition><then>
			<expr_stmt><expr><name>first_row</name> = <name>row</name></expr>;</expr_stmt></then></if>
		}</block></then> <else>else <block>{
		    <expr_stmt><expr><call><name>LineClrBlinked</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	    }</block></then></if>
	}</block></for>
	<comment type="block">/*
	 * FIXME: this could be a little more efficient, e.g,. by limiting the
	 * columns which are updated.
	 */</comment>
	<if>if <condition>(<expr><name>first_row</name> &lt;= <name>last_row</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>term</name></expr></argument>,
			<argument><expr><name>first_row</name></expr></argument>,
			<argument><expr>0</expr></argument>,
			<argument><expr><name>last_row</name> + 1 - <name>first_row</name></expr></argument>,
			<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If either the cursor or text is blinking, restart the timer.
     */</comment>
    <if>if <condition>(<expr><name>resume</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>StartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_BLINK_CURS || OPT_BLINK_TEXT */</comment>

<function><type><name>void</name></type>
<name>RestartBlinking</name><parameter_list>(<param><decl><type><name>TScreen</name> * <name>screen</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name> || <name>OPT_BLINK_TEXT</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>blink_timer</name> == 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Bool</name></type> <name>resume</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_CURS</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>DoStartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>resume</name> = <name>True</name></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_TEXT</name></expr></cpp:if>
	<if>if <condition>(<expr>!<name>resume</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>

	    <for>for (<init><expr><name>row</name> = <name>screen</name>-&gt;<name>max_row</name></expr>;</init> <condition><expr><name>row</name> &gt;= 0</expr>;</condition> <incr><expr><name>row</name>--</expr></incr>) <block>{
		<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr><name>ld</name> != 0 &amp;&amp; <call><name>LineTstBlinked</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <if>if <condition>(<expr><call><name>LineHasBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>resume</name> = <name>True</name></expr>;</expr_stmt>
			<break>break;</break>
		    }</block></then></if>
		}</block></then></if>
	    }</block></for>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>resume</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>StartBlinking</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
 * Implement soft or hard (full) reset of the VTxxx emulation.  There are a
 * couple of differences from real DEC VTxxx terminals (to avoid breaking
 * applications which have come to rely on xterm doing this):
 *
 *	+ autowrap mode should be reset (instead it's reset to the resource
 *	  default).
 *	+ the popup menu offers a choice of resetting the savedLines, or not.
 *	  (but the control sequence does this anyway).
 */</comment>
<function><type><name>void</name></type>
<name>VTReset</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>full</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>saved</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>empty</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>XtIsRealized</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call> || (<call><name>CURRENT_EMU</name><argument_list>()</argument_list></call> != (<name>Widget</name>) <name>xw</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>saved</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScrollBarDrawThumb</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>scrollWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* make cursor visible */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>cursor_set</name> = <name>ON</name></expr>;</expr_stmt>

    <comment type="block">/* reset scrolling region */</comment>
    <expr_stmt><expr><call><name>set_tb_margins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>bitclr</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	reset_SGR_Colors(xw);
	if (ResetAnsiColorRequest(xw, empty, 0))
	    xtermRepaint(xw);
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <comment type="block">/* Reset character-sets to initial state */</comment>
    <expr_stmt><expr><call><name>resetCharsets</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_MOD_FKEYS</name></expr></cpp:if>
    <comment type="block">/* Reset modifier-resources to initial state */</comment>
    <expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>modify_now</name> = <name>xw</name>-&gt;<name>keyboard</name>.<name>modify_1st</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Reset DECSCA */</comment>
    <expr_stmt><expr><call><name>bitclr</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>PROTECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>protected_mode</name> = <name>OFF_PROTECT</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>full</name></expr>)</condition><then> <block>{			<comment type="block">/* RIS */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>bellOnReset</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_TerminalBell</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* reset the mouse mode */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>send_mouse_pos</name> = <name>MOUSE_OFF</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>send_focus_pos</name> = <name>OFF</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>waitingForTrackInfo</name> = <name>False</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>eventMode</name> = <name>NORMAL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xtermShowPointer</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TabReset</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>tabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> = <name>MODE_SRM</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INITIAL_ERASE</name></expr></cpp:if>
	<if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>reset_DECBKM</name> == 1</expr>)</condition><then>
	    <expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> |= <name>MODE_DECBKM</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>xw</name>-&gt;<name>keyboard</name>.<name>reset_DECBKM</name> == 2</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>backarrow_key</name></expr>)</condition><then>
		<expr_stmt><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> |= <name>MODE_DECBKM</name></expr>;</expr_stmt></then></if></then></if></else></if>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("full reset DECBKM %s\n",
	       <call><name>BtoS</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name> &amp; <name>MODE_DECBKM</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_appcursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_appkeypad</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_decbkm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show_8bit_control</name><argument_list>(<argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reset_decudk</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FromAlternate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ClearScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>OFF</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>xw</name>-&gt;<name>flags</name> &amp; <name>REVERSE_VIDEO</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>ReverseVideo</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>xw</name>-&gt;<name>flags</name> = <name>xw</name>-&gt;<name>initflags</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_reversevideo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_autowrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_reversewrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_autolinefeed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>screen</name>-&gt;<name>jumpscroll</name> = <call>(<name>Boolean</name>) <argument_list>(<argument><expr>!(<name>xw</name>-&gt;<name>flags</name> &amp; <name>SMOOTHSCROLL</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_jumpscroll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>c132</name> &amp;&amp; (<name>xw</name>-&gt;<name>flags</name> &amp; <name>IN132COLUMNS</name>)</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Dimension</name></type> <name>reqWidth</name> =<init> <expr><call>(<name>Dimension</name>) <argument_list>(<argument><expr>80 * <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
					      + 2 * <name>screen</name>-&gt;<name>border</name>
					      + <call><name>ScrollbarWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Dimension</name></type> <name>reqHeight</name> =<init> <expr><call>(<name>Dimension</name>) <argument_list>(<argument><expr><call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
					       * <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
					       + 2 * <name>screen</name>-&gt;<name>border</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Dimension</name></type> <name>replyWidth</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Dimension</name></type> <name>replyHeight</name></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Making resize-request to restore 80-columns %dx%d\n",
		   <name>reqHeight</name>, <name>reqWidth</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>REQ_RESIZE</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>,
		       <argument><expr><name>reqWidth</name></expr></argument>,
		       <argument><expr><name>reqHeight</name></expr></argument>,
		       <argument><expr>&amp;<name>replyWidth</name></expr></argument>, <argument><expr>&amp;<name>replyHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>repairSizeHints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>XSync</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* synchronize */</comment>
	    <if>if <condition>(<expr><call><name>XtAppPending</name><argument_list>(<argument><expr><name>app_con</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>xevents</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>CursorSet</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>xw</name>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CursorSave</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{			<comment type="block">/* DECSTR */</comment>
	<comment type="block">/*
	 * There's a tiny difference, to accommodate usage of xterm.
	 * We reset autowrap to the resource values rather than turning
	 * it off.
	 */</comment>
	<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>xw</name>-&gt;<name>keyboard</name>.<name>flags</name></expr></argument>, <argument><expr>(<name>MODE_DECCKM</name> | <name>MODE_KAM</name> | <name>MODE_DECKPAM</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bitcpy</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>xw</name>-&gt;<name>initflags</name></expr></argument>, <argument><expr><name>WRAPAROUND</name> | <name>REVERSEWRAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bitclr</name><argument_list>(<argument><expr>&amp;<name>xw</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>INSERT</name> | <name>INVERSE</name> | <name>BOLD</name> | <name>BLINK</name> | <name>UNDERLINE</name> | <name>INVISIBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	    reset_SGR_Colors(xw);
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><call><name>update_appcursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_autowrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_reversewrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CursorSave</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name><name>sc</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name>.<name>row</name> =
	    <name>screen</name>-&gt;<name><name>sc</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name>.<name>col</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>vtjmpbuf</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* force ground state in parser */</comment>
}</block></function>

<comment type="block">/*
 * set_character_class - takes a string of the form
 *
 *   low[-high]:val[,low[-high]:val[...]]
 *
 * and sets the indicated ranges to the indicated values.
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>set_character_class</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>			<comment type="block">/* iterator, index into s */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>			<comment type="block">/* length of s */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>acc</name></decl>;</decl_stmt>			<comment type="block">/* accumulator */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>low</name>, <name>high</name></decl>;</decl_stmt>		<comment type="block">/* bounds of range [0..127] */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>;</decl_stmt>			<comment type="block">/* 8, 10, 16 (octal, decimal, hex) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>numbers</name></decl>;</decl_stmt>		<comment type="block">/* count of numbers per range */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>digits</name></decl>;</decl_stmt>			<comment type="block">/* count of digits in a number */</comment>
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name>errfmt</name> =<init> <expr>"%s:  %s in range string \"%s\" (position %d)\n"</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>s</name> || !<name><name>s</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
	<return>return <expr>-1</expr>;</return></then></if>

    <expr_stmt><expr><name>base</name> = 10</expr>;</expr_stmt>			<comment type="block">/* in case we ever add octal, hex */</comment>
    <expr_stmt><expr><name>low</name> = <name>high</name> = -1</expr>;</expr_stmt>		<comment type="block">/* out of range */</comment>

    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>len</name> = (<name>int</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr><name>acc</name> = 0</expr>, <expr><name>numbers</name> = <name>digits</name> = 0</expr>;</init>
	 <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>Char</name></type> <name>c</name> =<init> <expr><call><name>CharOf</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <continue>continue;</continue>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>acc</name> = <name>acc</name> * <name>base</name> + (<name>c</name> - '0')</expr>;</expr_stmt>
	    <expr_stmt><expr><name>digits</name>++</expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == '-'</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>low</name> = <name>acc</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>acc</name> = 0</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>digits</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"missing number"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(-1)</expr>;</return>
	    }</block></then></if>
	    <expr_stmt><expr><name>digits</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>numbers</name>++</expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == ':'</expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><name>numbers</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>low</name> = <name>acc</name></expr>;</expr_stmt></then>
	    <else>else <if>if <condition>(<expr><name>numbers</name> == 1</expr>)</condition><then>
		<expr_stmt><expr><name>high</name> = <name>acc</name></expr>;</expr_stmt></then>
	    <else>else <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"too many numbers"</expr></argument>,
			<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(-1)</expr>;</return>
	    }</block></else></if></else></if>
	    <expr_stmt><expr><name>digits</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>numbers</name>++</expr>;</expr_stmt>
	    <expr_stmt><expr><name>acc</name> = 0</expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == ','</expr>)</condition><then> <block>{
	    <comment type="block">/*
	     * now, process it
	     */</comment>

	    <if>if <condition>(<expr><name>high</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>high</name> = <name>low</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numbers</name>++</expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>numbers</name> != 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"bad value number"</expr></argument>,
			<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <if>if <condition>(<expr><call><name>SetCharacterClassRange</name><argument_list>(<argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>acc</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"bad range"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if></else></if>

	    <expr_stmt><expr><name>low</name> = <name>high</name> = -1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>acc</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>digits</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>numbers</name> = 0</expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"bad character"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr>(-1)</expr>;</return>
	}</block></else></if></else></if></else></if></else></if></else></if>			<comment type="block">/* end if else if ... else */</comment>

    }</block></for>

    <if>if <condition>(<expr><name>low</name> &lt; 0 &amp;&amp; <name>high</name> &lt; 0</expr>)</condition><then>
	<return>return <expr>(0)</expr>;</return></then></if>

    <comment type="block">/*
     * now, process it
     */</comment>

    <if>if <condition>(<expr><name>high</name> &lt; 0</expr>)</condition><then>
	<expr_stmt><expr><name>high</name> = <name>low</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>numbers</name> &lt; 1 || <name>numbers</name> &gt; 2</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"bad value number"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>SetCharacterClassRange</name><argument_list>(<argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>acc</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name>ProgramName</name></expr></argument>, <argument><expr>"bad range"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <return>return <expr>(0)</expr>;</return>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>HandleKeymapChange</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		   <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		   <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,
		   <param><decl><type><name>Cardinal</name> *</type><name>param_count</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>static</name> <name>XtTranslations</name></type> <name>keymap</name>, <name>original</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>XtResource</name></type> <name><name>key_resources</name><index>[]</index></name> =<init>
    <expr><block>{
	<expr><block>{<expr><name>XtNtranslations</name></expr>, <expr><name>XtCTranslations</name></expr>, <expr><name>XtRTranslationTable</name></expr>,
	 <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>XtTranslations</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr>, <expr><name>XtRTranslationTable</name></expr>, <expr>(<name>XtPointer</name>) <name>NULL</name></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>mapName</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>mapClass</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>pmapName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>pmapClass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>param_count</name> != 1</expr>)</condition><then>
	<return>return;</return></then></if>

    <if>if <condition>(<expr><name>original</name> == <name>NULL</name></expr>)</condition><then>
	<expr_stmt><expr><name>original</name> = <name>w</name>-&gt;<name>core</name>.<name>tm</name>.<name>translations</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>params</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"None"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>XtOverrideTranslations</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>params</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> + 7</expr>;</expr_stmt>

    <expr_stmt><expr><name>pmapName</name> = (<name>char</name> *) <call><name>MyStackAlloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>mapName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pmapClass</name> = (<name>char</name> *) <call><name>MyStackAlloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>mapClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pmapName</name> == <name>NULL</name>
	|| <name>pmapClass</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_KMMALLOC1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{

	<expr_stmt><expr>(<name>void</name>) <call><name>sprintf</name><argument_list>(<argument><expr><name>pmapName</name></expr></argument>, <argument><expr>"%sKeymap"</expr></argument>, <argument><expr><name><name>params</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>) <call><name>strcpy</name><argument_list>(<argument><expr><name>pmapClass</name></expr></argument>, <argument><expr><name>pmapName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><call><name>CharOf</name><argument_list>(<argument><expr><name><name>pmapClass</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name><name>pmapClass</name><index>[<expr>0</expr>]</index></name> = <call><name>x_toupper</name><argument_list>(<argument><expr><name><name>pmapClass</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>XtGetSubresources</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>(<name>XtPointer</name>) &amp;<name>keymap</name></expr></argument>, <argument><expr><name>pmapName</name></expr></argument>, <argument><expr><name>pmapClass</name></expr></argument>,
			  <argument><expr><name>key_resources</name></expr></argument>, <argument><expr>(<name>Cardinal</name>) 1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>Cardinal</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>keymap</name> != <name>NULL</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>XtOverrideTranslations</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>keymap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>MyStackFree</name><argument_list>(<argument><expr><name>pmapName</name></expr></argument>, <argument><expr><name>mapName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MyStackFree</name><argument_list>(<argument><expr><name>pmapClass</name></expr></argument>, <argument><expr><name>mapClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>HandleBell</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
	   <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
	   <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>,	<comment type="block">/* [0] = volume */</comment>
	   <param><decl><type><name>Cardinal</name> *</type><name>param_count</name></decl></param>)</parameter_list>	<comment type="block">/* 0 or 1 */</comment>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>percent</name> =<init> <expr>(*<name>param_count</name>) ? <call><name>atoi</name><argument_list>(<argument><expr><name><name>params</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>XkbBI_TerminalBell</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>HandleVisualBell</name><parameter_list>(<param><decl><type><name>Widget</name> <name>w</name></type> <name>GCC_UNUSED</name></decl></param>,
		 <param><decl><type><name>XEvent</name> * <name>event</name></type> <name>GCC_UNUSED</name></decl></param>,
		 <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
		 <param><decl><type><name>Cardinal</name> *<name>param_count</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VisualBell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>HandleIgnore</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
	     <param><decl><type><name>XEvent</name> *</type> <name>event</name></decl></param>,
	     <param><decl><type><name>String</name> * <name>params</name></type> <name>GCC_UNUSED</name></decl></param>,
	     <param><decl><type><name>Cardinal</name> *<name>param_count</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Handle ignore for %p\n", (<name>void</name> *) <name>w</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>xw</name> = <call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<comment type="block">/* do nothing, but check for funny escape sequences */</comment>
	<expr_stmt><expr>(<name>void</name>) <call><name>SendMousePosition</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* ARGSUSED */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>DoSetSelectedFont</name><parameter_list>(<param><decl><type><name>Widget</name></type> <name>w</name></decl></param>,
		  <param><decl><type><name>XtPointer</name> <name>client_data</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>Atom</name> * <name>selection</name></type> <name>GCC_UNUSED</name></decl></param>,
		  <param><decl><type><name>Atom</name> *</type> <name>type</name></decl></param>,
		  <param><decl><type><name>XtPointer</name></type> <name>value</name></decl></param>,
		  <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>length</name></decl></param>,
		  <param><decl><type><name>int</name> *</type><name>format</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>XtermWidget</name></type> <name>xw</name> =<init> <expr><call><name>getXtermWidget</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>xw</name> == 0) || *<name>type</name> != <name>XA_STRING</name> || *<name>format</name> != 8</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<decl_stmt><decl><type><name>Boolean</name></type> <name>failed</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>oldFont</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>menu_font_number</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>String</name></type> <name>save</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_fontsel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>test</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>used</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr>(<name>unsigned</name>) *<name>length</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>tst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Some versions of X deliver null-terminated selections, some do not.
	 */</comment>
	<for>for (<init><expr><name>tst</name> = 0</expr>;</init> <condition><expr><name>tst</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>tst</name></expr></incr>) <block>{
	    <if>if <condition>(<expr>((<name>char</name> *) <name>value</name>)<index>[<expr><name>tst</name></expr>]</index> == '\0'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>len</name> = <name>tst</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block></for>

	<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; (<name>val</name> = <call><name>TypeMallocN</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>val</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	    <expr_stmt><expr><name>used</name> = <call><name>x_strtrim</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DoSetSelectedFont(%s)\n", <name>val</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <comment type="block">/* Do some sanity checking to avoid sending a long selection
	       back to the server in an OpenFont that is unlikely to succeed.
	       XLFD allows up to 255 characters and no control characters;
	       we are a little more liberal here. */</comment>
	    <if>if <condition>(<expr><name>len</name> &lt; 1000
		&amp;&amp; !<call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call>
		&amp;&amp; (<name>test</name> = <call><name>x_strdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_fontsel</name></expr></argument>)</argument_list></call> = <name>test</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>xtermLoadFont</name><argument_list>(<argument><expr><name>term</name></expr></argument>,
				   <argument><expr><call><name>xtermFontName</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>True</name></expr></argument>,
				   <argument><expr><name>fontMenu_fontsel</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>failed</name> = <name>True</name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_fontsel</name></expr></argument>)</argument_list></call> = <name>save</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>failed</name> = <name>True</name></expr>;</expr_stmt>
	    }</block></else></if>
	    <if>if <condition>(<expr><name>failed</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>(<name>void</name>) <call><name>xtermLoadFont</name><argument_list>(<argument><expr><name>term</name></expr></argument>,
				     <argument><expr><call><name>xtermFontName</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>oldFont</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><name>True</name></expr></argument>,
				     <argument><expr><name>oldFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>used</name> != <name>val</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>FindFontSelection</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>atom_name</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>justprobe</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>AtomPtr</name> *</type><name>atoms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>atomCount</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AtomPtr</name> *</type><name>pAtom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Atom</name></type> <name>target</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>atom_name</name></expr>)</condition><then>
	<expr_stmt><expr><name>atom_name</name> = (<name>screen</name>-&gt;<name>mappedSelect</name>
		     ? <name>screen</name>-&gt;<name><name>mappedSelect</name><index>[<expr>0</expr>]</index></name>
		     : "PRIMARY")</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("FindFontSelection(%s)\n", <name>atom_name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>pAtom</name> = <name>atoms</name></expr>, <expr><name>a</name> = <name>atomCount</name></expr>;</init> <condition><expr><name>a</name></expr>;</condition> <incr><expr><name>a</name>--</expr>, <expr><name>pAtom</name>++</expr></incr>) <block>{
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>atom_name</name></expr></argument>, <argument><expr><call><name>XmuNameOfAtom</name><argument_list>(<argument><expr>*<name>pAtom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
	    <break>break;</break></then></if>
    }</block></for>
    <if>if <condition>(<expr>!<name>a</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>atoms</name> = (<name>AtomPtr</name> *) <call><name>XtRealloc</name><argument_list>(<argument><expr>(<name>char</name> *) <name>atoms</name></expr></argument>,
				      <argument><expr>(<name>Cardinal</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>AtomPtr</name></expr></argument>)</argument_list></call>
				      * (<name>atomCount</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*(<name>pAtom</name> = &amp;<name><name>atoms</name><index>[<expr><name>atomCount</name></expr>]</index></name>) = <call><name>XmuMakeAtom</name><argument_list>(<argument><expr><name>atom_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>target</name> = <call><name>XmuInternAtom</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>*<name>pAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>justprobe</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>screen</name>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_fontsel</name></expr></argument>)</argument_list></call> =
	    <call><name>XGetSelectionOwner</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call> ? <name>_Font_Selected_</name> : 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...selected fontname '%s'\n",
	       <call><name>NonNull</name><argument_list>(<argument><expr><name>screen</name>-&gt;<call><name>MenuFontName</name><argument_list>(<argument><expr><name>fontMenu_fontsel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>XtGetSelectionValue</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>XA_STRING</name></expr></argument>,
			    <argument><expr><name>DoSetSelectedFont</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			    <argument><expr><call><name>XtLastTimestampProcessed</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return;</return>
}</block></function>

<function><type><name>void</name></type>
<name>set_cursor_gcs</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTwin</name> *</type><name>win</name> =<init> <expr><call><name>WhichVWin</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Pixel</name></type> <name>cc</name> =<init> <expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_CURSOR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>fg</name> =<init> <expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_FG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pixel</name></type> <name>bg</name> =<init> <expr><call><name>T_COLOR</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>TEXT_BG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>changed</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Let's see, there are three things that have "color":
     *
     *     background
     *     text
     *     cursorblock
     *
     * And, there are four situations when drawing a cursor, if we decide
     * that we like have a solid block of cursor color with the letter
     * that it is highlighting shown in the background color to make it
     * stand out:
     *
     *     selected window, normal video - background on cursor
     *     selected window, reverse video - foreground on cursor
     *     unselected window, normal video - foreground on background
     *     unselected window, reverse video - background on foreground
     *
     * Since the last two are really just normalGC and reverseGC, we only
     * need two new GC's.  Under monochrome, we get the same effect as
     * above by setting cursor color to foreground.
     */</comment>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("set_cursor_gcs cc=%#lx, fg=%#lx, bg=%#lx\n", <name>cc</name>, <name>fg</name>, <name>bg</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>win</name> != 0 &amp;&amp; (<name>cc</name> != <name>bg</name>)</expr>)</condition><then> <block>{
	<comment type="block">/* set the fonts to the current one */</comment>
	<expr_stmt><expr><call><name>setCgsFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursNormal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursFilled</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursReverse</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursOutline</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we have a colored cursor */</comment>
	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursNormal</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursNormal</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursFilled</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursFilled</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>always_highlight</name></expr>)</condition><then> <block>{
	    <comment type="block">/* both GC's use the same color */</comment>
	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursReverse</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursReverse</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursOutline</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursOutline</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursReverse</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursReverse</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>setCgsFore</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursOutline</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>setCgsBack</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>win</name></expr></argument>, <argument><expr><name>gcVTcursOutline</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>changed</name> = <name>True</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>changed</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...set_cursor_gcs - done\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_LEAKS</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>noleaks_charproc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>v_buffer</name> != 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
