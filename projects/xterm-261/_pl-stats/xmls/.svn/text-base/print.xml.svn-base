<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" dir="" filename="print.c"><comment type="block">/* $XTermId: print.c,v 1.119 2010/06/13 17:46:27 tom Exp $ */</comment>

<comment type="block">/************************************************************

Copyright 1997-2009,2010 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

********************************************************/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;data.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;menu.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;error.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xstrings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>CTRL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive>	<name>CTRL</name>(c)	((c) &amp; 0x1f)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>SHIFT_IN</name>  '\017'</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>SHIFT_OUT</name> '\016'</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>CSET_IN</name>   'A'</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CSET_OUT</name>  '0'</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>isForm</name>(c)      ((c) == '\r' || (c) == '\n' || (c) == '\f')</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>Strlen</name>(a)      strlen((char *)a)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>Strcmp</name>(a,b)    strcmp((char *)a,(char *)b)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>Strncmp</name>(a,b,c) strncmp((char *)a,(char *)b,c)</cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>VMS_TEMP_PRINT_FILE</name> "sys$scratch:xterm_print.txt"</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>static</name> <name>void</name></type> <name>charToPrinter</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
			  <param><decl><type><name>unsigned</name></type></decl></param> <comment type="block">/* chr */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>printLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
		      <param><decl><type><name>int</name></type></decl></param> <comment type="block">/* row */</comment> ,
		      <param><decl><type><name>unsigned</name></type></decl></param> <comment type="block">/* chr */</comment> ,
		      <param><decl><type><name>PrinterFlags</name> *</type></decl></param> <comment type="block">/* p */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>send_CharSet</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
			 <param><decl><type><name>LineData</name> *</type></decl></param> <comment type="block">/* ld */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>send_SGR</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
		     <param><decl><type><name>unsigned</name></type></decl></param> <comment type="block">/* attr */</comment> ,
		     <param><decl><type><name>unsigned</name></type></decl></param> <comment type="block">/* fg */</comment> ,
		     <param><decl><type><name>unsigned</name></type></decl></param> <comment type="block">/* bg */</comment> )</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>stringToPrinter</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type></decl></param> <comment type="block">/* xw */</comment> ,
			    <param><decl><type><name>const</name> <name>char</name> *</type></decl></param> <comment type="block">/*str */</comment> )</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>static</name> <name>FILE</name> *</type><name>Printer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>pid_t</name></type> <name>Printer_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>initialized</name></decl>;</decl_stmt>

<function><type><name>static</name> <name>void</name></type>
<name>closePrinter</name><parameter_list>(<param><decl><type><name>XtermWidget</name> <name>xw</name></type> <name>GCC_UNUSED</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>xtermHasPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>pcommand</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr>(<name>void</name>) <call><name>sprintf</name><argument_list>(<argument><expr><name>pcommand</name></expr></argument>, <argument><expr>"%s %s;"</expr></argument>,
		       <argument><expr><name>screen</name>-&gt;<name>printer_command</name></expr></argument>,
		       <argument><expr><name>VMS_TEMP_PRINT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>Printer</name> != 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("closed printer, waiting...\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VMS</name></cpp:ifdef>			<comment type="block">/* This is a quick hack, really should use
				   spawn and check status or system services
				   and go straight to the queue */</comment>
	    <expr_stmt><expr>(<name>void</name>) <call><name>system</name><argument_list>(<argument><expr><name>pcommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* VMS */</comment>
	    <while>while <condition>(<expr><call><name>nonblocking_wait</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* VMS */</comment>
		<empty_stmt>;</empty_stmt></while>
	    <expr_stmt><expr><name>Printer</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><name>initialized</name> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("closed printer\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>printCursorLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("printCursorLine\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><call><name>getPrinterFlags</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>NO_COLOR</name>	((unsigned)-1)</cpp:define>

<comment type="block">/*
 * DEC's manual doesn't document whether trailing blanks are removed, or what
 * happens with a line that is entirely blank.  This function prints the
 * characters that xterm would allow as a selection (which may include blanks).
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>printLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>chr</name></decl></param>, <param><decl><type><name>PrinterFlags</name> *</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>inx</name> =<init> <expr><call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name></type> <name>attr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> =<init> <expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name> &amp;&amp; <name>OPT_PRINT_COLORS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>CellColor</name> *</type><name>fb</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ColorOf</name>(ld,col) (ld-&gt;color[col])</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>fg</name> =<init> <expr><name>NO_COLOR</name></expr>, <expr><name>last_fg</name> = <name>NO_COLOR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>bg</name> =<init> <expr><name>NO_COLOR</name></expr>, <expr><name>last_bg</name> = <name>NO_COLOR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cs</name> =<init> <expr><name>CSET_IN</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_cs</name> =<init> <expr><name>CSET_IN</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>inx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ld</name> == 0</expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("printLine(row=%d/%d, top=%d:%d, chr=%d):%s\n",
	   <name>row</name>, <call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call>, <name>screen</name>-&gt;<name>topline</name>, <name>screen</name>-&gt;<name>max_row</name>, <name>chr</name>,
	   <call><name>visibleIChars</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name>charData</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>last</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	fb = ld-&gt;color;
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <while>while <condition>(<expr><name>last</name> &gt; 0</expr>)</condition> <block>{
	<if>if <condition>(<expr>(<name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>last</name> - 1</expr>]</index></name> &amp; <name>CHARDRAWN</name>) == 0</expr>)</condition><then>
	    <expr_stmt><expr><name>last</name>--</expr>;</expr_stmt></then>
	<else>else
	    <break>break;</break></else></if>
    }</block></while>
    <if>if <condition>(<expr><name>last</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>p</name>-&gt;<name>print_attributes</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>send_CharSet</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>send_SGR</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NO_COLOR</name></expr></argument>, <argument><expr><name>NO_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<for>for (<init><expr><name>col</name> = 0</expr>;</init> <condition><expr><name>col</name> &lt; <name>last</name></expr>;</condition> <incr><expr><name>col</name>++</expr></incr>) <block>{
	    <expr_stmt><expr><name>ch</name> = <name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PRINT_COLORS</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>colorMode</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>p</name>-&gt;<name>print_attributes</name> &gt; 1</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>fg</name> = (<name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> &amp; <name>FG_COLOR</name>)
			? <call><name>extract_fg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>ColorOf</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call>
			: <name>NO_COLOR</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>bg</name> = (<name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> &amp; <name>BG_COLOR</name>)
			? <call><name>extract_bg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>ColorOf</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call>
			: <name>NO_COLOR</name></expr>;</expr_stmt>
		}</block></then></if>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr>(((<name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> &amp; <name>SGR_MASK</name>) != <name>attr</name>)
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PRINT_COLORS</name></expr></cpp:if>
		 || (<name>last_fg</name> != <name>fg</name>) || (<name>last_bg</name> != <name>bg</name>)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)
		&amp;&amp; <name>ch</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>attr</name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> &amp; <name>SGR_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PRINT_COLORS</name></expr></cpp:if>
		<expr_stmt><expr><name>last_fg</name> = <name>fg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_bg</name> = <name>bg</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name>p</name>-&gt;<name>print_attributes</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>send_SGR</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>, <argument><expr><name>bg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    }</block></then></if>

	    <if>if <condition>(<expr><name>ch</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>ch</name> = ' '</expr>;</expr_stmt></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>utf8_mode</name></expr>)</condition><then>
		<expr_stmt><expr><name>cs</name> = <name>CSET_IN</name></expr>;</expr_stmt></then>
	    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>cs</name> = (<name>ch</name> &gt;= ' ' &amp;&amp; <name>ch</name> != <name>ANSI_DEL</name>) ? <name>CSET_IN</name> : <name>CSET_OUT</name></expr>;</expr_stmt></else></if>
	    <if>if <condition>(<expr><name>last_cs</name> != <name>cs</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>p</name>-&gt;<name>print_attributes</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				  <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>cs</name> == <name>CSET_OUT</name>)
					      ? <name>SHIFT_OUT</name>
					      : <name>SHIFT_IN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>last_cs</name> = <name>cs</name></expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/* FIXME:  we shouldn't have to map back from the
	     * alternate character set, except that the
	     * corresponding charset information is not encoded
	     * into the CSETS array.
	     */</comment>
	    <expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			  <argument><expr>((<name>cs</name> == <name>CSET_OUT</name>)
			   ? (<name>ch</name> == <name>ANSI_DEL</name> ? 0x5f : (<name>ch</name> + 0x5f))
			   : <name>ch</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		size_t off;
		for_each_combData(off, ld) {
		    ch = ld-&gt;combData[off][col];
		    if (ch == 0)
			break;
		    charToPrinter(xw, ch);
		}
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	}</block></for>
	<if>if <condition>(<expr><name>p</name>-&gt;<name>print_attributes</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>send_SGR</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NO_COLOR</name></expr></argument>, <argument><expr><name>NO_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>cs</name> != <name>CSET_IN</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>SHIFT_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
    }</block></then></if>

    <comment type="block">/* finish line (protocol for attributes needs a CR */</comment>
    <if>if <condition>(<expr><name>p</name>-&gt;<name>print_attributes</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'\r'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>chr</name> &amp;&amp; !(<name>p</name>-&gt;<name>printer_newline</name>)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>LineTstWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><name>chr</name> = '\0'</expr>;</expr_stmt></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>chr</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>PrintNewLine</name>() (unsigned) (((top &lt; bot) || p-&gt;printer_newline) ? '\n' : '\0')</cpp:define>

<function><type><name>void</name></type>
<name>xtermPrintScreen</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>Bool</name></type> <name>use_DECPEX</name></decl></param>, <param><decl><type><name>PrinterFlags</name> *</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>XtIsRealized</name><argument_list>(<argument><expr>(<name>Widget</name>) <name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bool</name></type> <name>extent</name> =<init> <expr>(<name>use_DECPEX</name> &amp;&amp; <name>p</name>-&gt;<name>printer_extent</name>)</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>top</name> =<init> <expr><name>extent</name> ? 0 : <name>screen</name>-&gt;<name>top_marg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bot</name> =<init> <expr><name>extent</name> ? <name>screen</name>-&gt;<name>max_row</name> : <name>screen</name>-&gt;<name>bot_marg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>was_open</name> =<init> <expr><name>initialized</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermPrintScreen, rows %d..%d\n", <name>top</name>, <name>bot</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>top</name> &lt;= <name>bot</name></expr>)</condition> <block>{
	    <expr_stmt><expr><call><name>printLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><call><name>PrintNewLine</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>++<name>top</name></expr>;</expr_stmt>
	}</block></while>
	<if>if <condition>(<expr><name>p</name>-&gt;<name>printer_formfeed</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'\f'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr>!<name>was_open</name> || <name>screen</name>-&gt;<name>printer_autoclose</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>closePrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>Bell</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>XkbBI_MinorError</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * If the alternate screen is active, we'll print only that.  Otherwise, print
 * the normal screen plus all scrolled-back lines.  The distinction is made
 * because the normal screen's buffer is part of the overall scrollback buffer.
 */</comment>
<function><type><name>void</name></type>
<name>xtermPrintEverything</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>PrinterFlags</name> *</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>top</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bot</name> =<init> <expr><name>screen</name>-&gt;<name>max_row</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>was_open</name> =<init> <expr><name>initialized</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>screen</name>-&gt;<name>whichBuf</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>top</name> = -<name>screen</name>-&gt;<name>savedlines</name> - <name>screen</name>-&gt;<name>topline</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bot</name> -= <name>screen</name>-&gt;<name>topline</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("xtermPrintEverything, rows %d..%d\n", <name>top</name>, <name>bot</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>top</name> &lt;= <name>bot</name></expr>)</condition> <block>{
	<expr_stmt><expr><call><name>printLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><call><name>PrintNewLine</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>++<name>top</name></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name>p</name>-&gt;<name>printer_formfeed</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>'\f'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<name>was_open</name> || <name>screen</name>-&gt;<name>printer_autoclose</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>closePrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>send_CharSet</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>LineData</name> *</type> <name>ld</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>msg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
    <case>case <expr><name>CSET_SWL</name></expr>:
	<expr_stmt><expr><name>msg</name> = "\033#5"</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>CSET_DHL_TOP</name></expr>:
	<expr_stmt><expr><name>msg</name> = "\033#3"</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>CSET_DHL_BOT</name></expr>:
	<expr_stmt><expr><name>msg</name> = "\033#4"</expr>;</expr_stmt>
	<break>break;</break>
    </case><case>case <expr><name>CSET_DWL</name></expr>:
	<expr_stmt><expr><name>msg</name> = "\033#6"</expr>;</expr_stmt>
	<break>break;</break>
    </case>}</block></switch>
    <if>if <condition>(<expr><name>msg</name> != 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>stringToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr>(<name>void</name>) <name>xw</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>ld</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_CHRSET */</comment>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>send_SGR</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>attr</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>fg</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>bg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>"\033[0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>attr</name> &amp; <name>BOLD</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>";1"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>attr</name> &amp; <name>UNDERLINE</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>";4"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="block">/* typo? DEC documents this as '2' */</comment>
    <if>if <condition>(<expr><name>attr</name> &amp; <name>BLINK</name></expr>)</condition><then>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>";5"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>attr</name> &amp; <name>INVERSE</name></expr>)</condition><then>		<comment type="block">/* typo? DEC documents this as invisible */</comment>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>";7"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PRINT_COLORS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>bg</name> != <name>NO_COLOR</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>msg</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>";%u"</expr></argument>, <argument><expr>(<name>bg</name> &lt; 8) ? (40 + <name>bg</name>) : (92 + <name>bg</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>fg</name> != <name>NO_COLOR</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_PC_COLORS</name></expr></cpp:if>
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>boldColors</name>
	    &amp;&amp; <name>fg</name> &gt; 8
	    &amp;&amp; (<name>attr</name> &amp; <name>BOLD</name>) != 0</expr>)</condition><then>
	    <expr_stmt><expr><name>fg</name> -= 8</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>msg</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>";%u"</expr></argument>, <argument><expr>(<name>fg</name> &lt; 8) ? (30 + <name>fg</name>) : (82 + <name>fg</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr>(<name>void</name>) <name>bg</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>fg</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr>"m"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stringToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * This implementation only knows how to write to a pipe.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>charToPrinter</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>chr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>initialized</name> &amp;&amp; <call><name>xtermHasPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/*
	 * This implementation only knows how to write to a file.  When the
	 * file is closed the print command executes.  Print command must be of
	 * the form:
	 *   print/que=name/delete [/otherflags].
	 */</comment>
	<expr_stmt><expr><name>Printer</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>VMS_TEMP_PRINT_FILE</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/*
	 * This implementation only knows how to write to a pipe.
	 */</comment>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>input</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>my_pipe</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>my_pipe</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_FORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr>(<name>Printer_pid</name> = <call><name>fork</name><argument_list>()</argument_list></call>) &lt; 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_FORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>Printer_pid</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE_CLOSE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>my_pipe</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* printer is silent */</comment>
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <if>if <condition>(<expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/* don't want privileges! */</comment>
	    <if>if <condition>(<expr><call><name>xtermResetIds</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	    <expr_stmt><expr><name>Printer</name> = <call><name>popen</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>printer_command</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>input</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>my_pipe</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <while>while <condition>(<expr>(<name>c</name> = <call><name>fgetc</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call>) != <name>EOF</name></expr>)</condition> <block>{
		<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>isForm</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    }</block></while>
	    <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>my_pipe</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* won't read from printer */</comment>
	    <expr_stmt><expr><name>Printer</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>my_pipe</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("opened printer from pid %d/%d\n",
		   (<name>int</name>) <call><name>getpid</name><argument_list>()</argument_list></call>, (<name>int</name>) <name>Printer_pid</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>initialized</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>Printer</name> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>chr</name> &gt; 127</expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Char</name></type> <name><name>temp</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
	    <expr_stmt><expr>*<call><name>convertToUTF8</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>(<name>char</name> *) <name>temp</name></expr></argument>, <argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>(<name>int</name>) <name>chr</name></expr></argument>, <argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<if>if <condition>(<expr><call><name>isForm</name><argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type>
<name>stringToPrinter</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr>*<name>str</name></expr>)</condition>
	<expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>CharOf</name><argument_list>(<argument><expr>*<name>str</name>++</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
}</block></function>

<comment type="block">/*
 * This module implements the MC (Media Copy) and related printing control
 * sequences for VTxxx emulation.  This is based on the description in the
 * VT330/VT340 Programmer Reference Manual EK-VT3XX-TP-001 (Digital Equipment
 * Corp., March 1987).
 */</comment>
<function><type><name>void</name></type>
<name>xtermMediaControl</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>param</name></decl></param>, <param><decl><type><name>int</name></type> <name>private_seq</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("MediaCopy param=%d, private=%d\n", <name>param</name>, <name>private_seq</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>private_seq</name></expr>)</condition><then> <block>{
	<switch>switch <condition>(<expr><name>param</name></expr>)</condition> <block>{
	<case>case <expr>1</expr>:
	    <expr_stmt><expr><call><name>printCursorLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>4</expr>:
	    <expr_stmt><expr><call><name>setPrinterControlMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>5</expr>:
	    <expr_stmt><expr><call><name>setPrinterControlMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>10</expr>:		<comment type="block">/* VT320 */</comment>
	    <expr_stmt><expr><call><name>xtermPrintScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>False</name></expr></argument>, <argument><expr><call><name>getPrinterFlags</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>11</expr>:		<comment type="block">/* VT320 */</comment>
	    <expr_stmt><expr><call><name>xtermPrintEverything</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>getPrinterFlags</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case>}</block></switch>
    }</block></then> <else>else <block>{
	<switch>switch <condition>(<expr><name>param</name></expr>)</condition> <block>{
	<case>case <expr>-1</expr>:
	</case><case>case <expr>0</expr>:
	    <expr_stmt><expr><call><name>xtermPrintScreen</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>, <argument><expr><call><name>getPrinterFlags</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>4</expr>:
	    <expr_stmt><expr><call><name>setPrinterControlMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case><case>case <expr>5</expr>:
	    <expr_stmt><expr><call><name>setPrinterControlMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	</case>}</block></switch>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * When in autoprint mode, the printer prints a line from the screen when you
 * move the cursor off that line with an LF, FF, or VT character, or an
 * autowrap occurs.  The printed line ends with a CR and the character (LF, FF
 * or VT) that moved the cursor off the previous line.
 */</comment>
<function><type><name>void</name></type>
<name>xtermAutoPrint</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>chr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>printer_controlmode</name> == 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("AutoPrint %d\n", <name>chr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printLine</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>row</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name>getPrinterFlags</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>Printer</name> != 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>Printer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * When in printer controller mode, the terminal sends received characters to
 * the printer without displaying them on the screen. The terminal sends all
 * characters and control sequences to the printer, except NUL, XON, XOFF, and
 * the printer controller sequences.
 *
 * This function eats characters, returning 0 as long as it must buffer or
 * divert to the printer.  We're only invoked here when in printer controller
 * mode, and handle the exit from that mode.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>LB</name> '['</cpp:define>

<function><type><name>int</name></type>
<name>xtermPrinterControl</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>chr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* *INDENT-OFF* */</comment>
    <decl_stmt><decl><type><name>static</name></type> struct <block>{
	<decl_stmt><decl><type><name>Char</name></type> <name><name>seq</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>active</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>tbl</name><index>[]</index></name> = <block>{
	<expr><block>{ <expr><block>{ <expr><name>ANSI_CSI</name></expr>, <expr>'5'</expr>, <expr>'i'</expr>      }</block></expr>, <expr>2</expr> }</block></expr>,
	<expr><block>{ <expr><block>{ <expr><name>ANSI_CSI</name></expr>, <expr>'4'</expr>, <expr>'i'</expr>      }</block></expr>, <expr>0</expr> }</block></expr>,
	<expr><block>{ <expr><block>{ <expr><name>ANSI_ESC</name></expr>, <expr><name>LB</name></expr>,  <expr>'5'</expr>, <expr>'i'</expr> }</block></expr>, <expr>2</expr> }</block></expr>,
	<expr><block>{ <expr><block>{ <expr><name>ANSI_ESC</name></expr>, <expr><name>LB</name></expr>,  <expr>'4'</expr>, <expr>'i'</expr> }</block></expr>, <expr>0</expr> }</block></expr>,
    }</block></expr>;</expr_stmt>
    <comment type="block">/* *INDENT-ON* */</comment>

    <decl_stmt><decl><type><name>static</name> <name>Char</name></type> <name><name>bfr</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>size_t</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("In printer:%04X\n", <name>chr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>chr</name></expr>)</condition> <block>{
    <case>case <expr>0</expr>:
    </case><case>case <expr><call><name>CTRL</name><argument_list>(<argument><expr>'Q'</expr></argument>)</argument_list></call></expr>:
    </case><case>case <expr><call><name>CTRL</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>:
	<return>return <expr>0</expr>;</return>		<comment type="block">/* ignored by application */</comment>

    </case><case>case <expr><name>ANSI_CSI</name></expr>:
    </case><case>case <expr><name>ANSI_ESC</name></expr>:
    </case><case>case <expr>'['</expr>:
    </case><case>case <expr>'4'</expr>:
    </case><case>case <expr>'5'</expr>:
    </case><case>case <expr>'i'</expr>:
	<expr_stmt><expr><name><name>bfr</name><index>[<expr><name>length</name>++</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <call><name>sizeof</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call> / <call><name>sizeof</name><argument_list>(<argument><expr><name><name>tbl</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
	    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> =<init> <expr><call><name>Strlen</name><argument_list>(<argument><expr><name><name>tbl</name><index>[<expr><name>n</name></expr>]</index></name>.<name>seq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>length</name> == <name>len</name>
		&amp;&amp; <call><name>Strcmp</name><argument_list>(<argument><expr><name>bfr</name></expr></argument>, <argument><expr><name><name>tbl</name><index>[<expr><name>n</name></expr>]</index></name>.<name>seq</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>setPrinterControlMode</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>tbl</name><index>[<expr><name>n</name></expr>]</index></name>.<name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>printer_autoclose</name>
		    &amp;&amp; <name>screen</name>-&gt;<name>printer_controlmode</name> == 0</expr>)</condition><then>
		    <expr_stmt><expr><call><name>closePrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>length</name> = 0</expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	    }</block></then> <else>else <if>if <condition>(<expr><name>len</name> &gt; <name>length</name>
		       &amp;&amp; <call><name>Strncmp</name><argument_list>(<argument><expr><name>bfr</name></expr></argument>, <argument><expr><name><name>tbl</name><index>[<expr><name>n</name></expr>]</index></name>.<name>seq</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<return>return <expr>0</expr>;</return>
	    }</block></then></if></else></if>
	}</block></for>
	<expr_stmt><expr><name>length</name>--</expr>;</expr_stmt>

	<comment type="block">/* FALLTHRU */</comment>

    </case><default>default:
	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
	    <expr_stmt><expr><call><name>charToPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name><name>bfr</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
	<expr_stmt><expr><name><name>bfr</name><index>[<expr>0</expr>]</index></name> = <call><name>CharOf</name><argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>length</name> = 1</expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
    </default>}</block></switch>
}</block></function>

<comment type="block">/*
 * If there is no printer command, we will ignore printer controls.
 */</comment>
<function><type><name>Bool</name></type>
<name>xtermHasPrinter</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr>(<call><name>strlen</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>printer_command</name></expr></argument>)</argument_list></call> != 0)</expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>showPrinterControlMode</name>(mode) \
		(((mode) == 0) \
		 ? "normal" \
		 : ((mode) == 1 \
		    ? "autoprint" \
		    : "printer controller"))</cpp:define>

<function><type><name>void</name></type>
<name>setPrinterControlMode</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>xtermHasPrinter</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
	&amp;&amp; <name>screen</name>-&gt;<name>printer_controlmode</name> != <name>mode</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s %s mode\n",
	       (<name>mode</name>
		? "set"
		: "reset"),
	       (<name>mode</name>
		? <call><name>showPrinterControlMode</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call>
		: <call><name>showPrinterControlMode</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>printer_controlmode</name></expr></argument>)</argument_list></call>))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>printer_controlmode</name> = <name>mode</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_print_redir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>PrinterFlags</name> *</type>
<name>getPrinterFlags</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>String</name> *</type> <name>params</name></decl></param>, <param><decl><type><name>Cardinal</name> *</type><name>param_count</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* *INDENT-OFF* */</comment>
    <decl_stmt><decl><type><name>static</name> <name>const</name></type> <type>struct</type> <block>{
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>    <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	    <name>value</name></decl>;</decl_stmt>
    }</block></decl></decl_stmt> <expr_stmt><expr><name><name>table</name><index>[]</index></name> = <block>{
	<expr><block>{ <expr>"noFormFeed"</expr>, <expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>PrinterFlags</name></expr></argument>, <argument><expr><name>printer_formfeed</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr> }</block></expr>,
	<expr><block>{ <expr>"FormFeed"</expr>,	<expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>PrinterFlags</name></expr></argument>, <argument><expr><name>printer_formfeed</name></expr></argument>)</argument_list></call></expr>, <expr>1</expr> }</block></expr>,
	<expr><block>{ <expr>"noNewLine"</expr>,	<expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>PrinterFlags</name></expr></argument>, <argument><expr><name>printer_newline</name></expr></argument>)</argument_list></call></expr>,  <expr>0</expr> }</block></expr>,
	<expr><block>{ <expr>"NewLine"</expr>,	<expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>PrinterFlags</name></expr></argument>, <argument><expr><name>printer_newline</name></expr></argument>)</argument_list></call></expr>,  <expr>1</expr> }</block></expr>,
	<expr><block>{ <expr>"noAttrs"</expr>,	<expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>PrinterFlags</name></expr></argument>, <argument><expr><name>print_attributes</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr> }</block></expr>,
	<expr><block>{ <expr>"monoAttrs"</expr>,	<expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>PrinterFlags</name></expr></argument>, <argument><expr><name>print_attributes</name></expr></argument>)</argument_list></call></expr>, <expr>1</expr> }</block></expr>,
	<expr><block>{ <expr>"colorAttrs"</expr>, <expr><call><name>XtOffsetOf</name><argument_list>(<argument><expr><name>PrinterFlags</name></expr></argument>, <argument><expr><name>print_attributes</name></expr></argument>)</argument_list></call></expr>, <expr>2</expr> }</block></expr>,
    }</block></expr>;</expr_stmt>
    <comment type="block">/* *INDENT-ON* */</comment>

    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PrinterFlags</name> *</type><name>result</name> =<init> <expr>&amp;(<name>screen</name>-&gt;<name>printer_flags</name>)</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("getPrinterFlags %d params\n", <name>param_count</name> ? *<name>param_count</name> : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name>-&gt;<name>printer_extent</name> = <name>screen</name>-&gt;<name>printer_extent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name>-&gt;<name>printer_formfeed</name> = <name>screen</name>-&gt;<name>printer_formfeed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name>-&gt;<name>printer_newline</name> = <name>screen</name>-&gt;<name>printer_newline</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name>-&gt;<name>print_attributes</name> = <name>screen</name>-&gt;<name>print_attributes</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>param_count</name> != 0 &amp;&amp; *<name>param_count</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>Cardinal</name></type> <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>k</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; *<name>param_count</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("param%d:%s\n", <name>j</name>, <name><name>params</name><index>[<expr><name>j</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <call><name>XtNumber</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>k</name></expr></incr>) <block>{
		<if>if <condition>(<expr>!<call><name>x_strcasecmp</name><argument_list>(<argument><expr><name><name>params</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		    <decl_stmt><decl><type><name>int</name> *</type><name>ptr</name> =<init> <expr>(<name>int</name> *) ((<name>char</name> *) <name>result</name> + <name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>offset</name>)</expr></init></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...PrinterFlags(%s) %d-&gt;%d\n",
			   <name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>name</name>,
			   *<name>ptr</name>,
			   <name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr>*<name>ptr</name> = <name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>value</name></expr>;</expr_stmt>
		    <break>break;</break>
		}</block></then></if>
	    }</block></for>
	}</block></for>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
</unit>
