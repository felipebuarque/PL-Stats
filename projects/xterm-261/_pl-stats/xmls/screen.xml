<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" dir="" filename="screen.c"><comment type="block">/* $XTermId: screen.c,v 1.423 2010/06/14 00:00:58 tom Exp $ */</comment>

<comment type="block">/*
 * Copyright 1999-2009,2010 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */</comment>

<comment type="block">/* screen.c */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;error.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;data.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xcharmouse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xterm_io.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fontutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;menu.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>inSaveBuf</name>(screen, buf, inx) \
	((buf) == (screen)-&gt;saveBuf_index &amp;&amp; \
	 ((inx) &lt; (screen)-&gt;savelines || (screen)-&gt;savelines == 0))</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>getMinRow</name>(screen) ((xw-&gt;flags &amp; ORIGIN) ? (screen)-&gt;top_marg : 0)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>getMaxRow</name>(screen) ((xw-&gt;flags &amp; ORIGIN) ? (screen)-&gt;bot_marg : (screen)-&gt;max_row)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>getMinCol</name>(screen) 0</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>getMaxCol</name>(screen) ((screen)-&gt;max_col)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>MoveLineData</name>(base, dst, src, len) \
	memmove(scrnHeadAddr(screen, base, (unsigned) (dst)), \
		scrnHeadAddr(screen, base, (unsigned) (src)), \
		(size_t) scrnHeadSize(screen, (unsigned) (len)))</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>SaveLineData</name>(base, src, len) \
	(void) ScrnPointers(screen, len); \
	memcpy (screen-&gt;save_ptr, \
		scrnHeadAddr(screen, base, src), \
		(size_t) scrnHeadSize(screen, (unsigned) (len)))</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>RestoreLineData</name>(base, dst, len) \
	memcpy (scrnHeadAddr(screen, base, dst), \
		screen-&gt;save_ptr, \
		(size_t) scrnHeadSize(screen, (unsigned) (len)))</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>VisBuf</name>(screen) screen-&gt;editBuf_index[screen-&gt;whichBuf]</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>VisBuf</name>(screen) scrnHeadAddr(screen, screen-&gt;saveBuf_index, (unsigned) savelines)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ScrnPtr's can point to different types of data.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>SizeofScrnPtr</name>(name) \
	(unsigned) sizeof(*((LineData *)0)-&gt;name)</cpp:define>

<comment type="block">/*
 * The pointers in LineData point into a block of text allocated as a single
 * chunk for the given number of rows.  Ensure that these pointers are aligned
 * at least to int-boundaries.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>AlignMask</name>()      (sizeof(int) - 1)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IsAligned</name>(value) (((unsigned long) (value) &amp; AlignMask()) == 0)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>AlignValue</name>(value) \
		if (!IsAligned(value)) \
		    value = (value | (unsigned) AlignMask()) + 1</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>SetupScrnPtr</name>(dst,src,type) \
		dst = (type *) src; \
		assert(IsAligned(dst)); \
		src += skipNcol##type</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>ScrnBufAddr</name>(ptrs, offset)  (ScrnBuf)    ((char *) (ptrs) + (offset))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>LineDataAddr</name>(ptrs, offset) (LineData *) ((char *) (ptrs) + (offset))</cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name> &gt; 1</expr></cpp:if>
<function><type><name>static</name> <name>void</name></type>
<name>traceScrnBuf</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>tag</name></decl></param>, <param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>sb</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("traceScrnBuf %s\n", <name>tag</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>src</name> =<init> <expr>(<name>LineData</name> *) <call><name>scrnHeadAddr</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%p %s%3d:%s\n",
	       <name>src</name>, ((<name>int</name>) <name>j</name> &gt;= <name>screen</name>-&gt;<name>savelines</name>) ? "*" : " ",
	       <name>j</name>, <call><name>visibleIChars</name><argument_list>(<argument><expr><name>src</name>-&gt;<name>charData</name></expr></argument>, <argument><expr><name>src</name>-&gt;<name>lineSize</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...traceScrnBuf %s\n", <name>tag</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRACE_SCRNBUF</name>(tag, screen, sb, len) traceScrnBuf(tag, screen, sb, len)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRACE_SCRNBUF</name>(tag, screen, sb, len)</cpp:define>	<comment type="block">/*nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>static</name> <name>unsigned</name></type>
<name>scrnHeadSize</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>result</name> =<init> <expr><name>SizeOfLineData</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>) <name>screen</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> += (<name>unsigned</name>) <name>screen</name>-&gt;<name>lineExtra</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>result</name> *= <name>count</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>ScrnBuf</name></type>
<name>scrnHeadAddr</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>base</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name> =<init> <expr><call><name>scrnHeadSize</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>result</name> =<init> <expr><call><name>ScrnBufAddr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>int</name>) <name>offset</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Given a block of data, build index to it in the 'base' parameter.
 */</comment>
<function><type><name>void</name></type>
<name>setupLineData</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>base</name></decl></param>, <param><decl><type><name>Char</name> *</type> <name>data</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>nrow</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ncol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>offset</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>jump</name> =<init> <expr><call><name>scrnHeadSize</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ptr</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* these names are based on types */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>skipNcolChar</name> =<init> <expr>(<name>ncol</name> * <call><name>SizeofScrnPtr</name><argument_list>(<argument><expr><name>attribs</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>skipNcolCharData</name> =<init> <expr>(<name>ncol</name> * <call><name>SizeofScrnPtr</name><argument_list>(<argument><expr><name>charData</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>skipNcolCellColor</name> =<init> <expr>(<name>ncol</name> * <call><name>SizeofScrnPtr</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>AlignValue</name><argument_list>(<argument><expr><name>skipNcolChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <expr_stmt><expr><call><name>AlignValue</name><argument_list>(<argument><expr><name>skipNcolCellColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>AlignValue</name><argument_list>(<argument><expr><name>skipNcolCharData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nrow</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>offset</name> += <name>jump</name></expr></incr>) <block>{
	<expr_stmt><expr><name>ptr</name> = <call><name>LineDataAddr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name>-&gt;<name>lineSize</name> = (<name>Dimension</name>) <name>ncol</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name>-&gt;<name>bufHead</name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	<expr_stmt><expr><call><name>SetLineDblCS</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>SetupScrnPtr</name><argument_list>(<argument><expr><name>ptr</name>-&gt;<name>attribs</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>Char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	<expr_stmt><expr><call><name>SetupScrnPtr</name><argument_list>(<argument><expr><name>ptr</name>-&gt;<name>color</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>CellColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>SetupScrnPtr</name><argument_list>(<argument><expr><name>ptr</name>-&gt;<name>charData</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>CharData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>unsigned</name></type> <name>extra</name> =<init> <expr>(<name>unsigned</name>) <name>screen</name>-&gt;<name>max_combining</name></expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><name>ptr</name>-&gt;<name>combSize</name> = (<name>Char</name>) <name>extra</name></expr>;</expr_stmt>
	    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>extra</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
		<expr_stmt><expr><call><name>SetupScrnPtr</name><argument_list>(<argument><expr><name>ptr</name>-&gt;<name><name>combData</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>CharData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></for>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>ExtractScrnData</name>(name) \
		memcpy(dstPtrs-&gt;name, \
		       ((LineData *) srcPtrs)-&gt;name,\
		       dstCols * sizeof(dstPtrs-&gt;name[0])); \
		nextPtr += (srcCols * sizeof(dstPtrs-&gt;name[0]))</cpp:define>

<comment type="block">/*
 * As part of reallocating the screen buffer when resizing, extract from
 * the old copy of the screen buffer the data which will be used in the
 * new copy of the screen buffer.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>extractScrnData</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
		<param><decl><type><name>ScrnBuf</name></type> <name>dstPtrs</name></decl></param>,
		<param><decl><type><name>ScrnBuf</name></type> <name>srcPtrs</name></decl></param>,
		<param><decl><type><name>unsigned</name></type> <name>nrows</name></decl></param>,
		<param><decl><type><name>unsigned</name></type> <name>move_down</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("extractScrnData(nrows %d)\n", <name>nrows</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"extract from"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>srcPtrs</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>nrows</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>dst</name> =<init> <expr>(<name>LineData</name> *) <call><name>scrnHeadAddr</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
						  <argument><expr><name>dstPtrs</name></expr></argument>, <argument><expr><name>j</name> + <name>move_down</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>src</name> =<init> <expr>(<name>LineData</name> *) <call><name>scrnHeadAddr</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
						  <argument><expr><name>srcPtrs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>copyLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><name>static</name> <name>ScrnPtr</name> *</type>
<name>allocScrnHead</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>nrow</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ScrnPtr</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name> =<init> <expr><call><name>scrnHeadSize</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> = (<name>ScrnPtr</name> *) <call><name>calloc</name><argument_list>(<argument><expr>(<name>size_t</name>) <name>nrow</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_SCALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("allocScrnHead %d -&gt; %d -&gt; %p..%p\n", <name>nrow</name>, <name>nrow</name> * <name>size</name>,
	   (<name>void</name> *) <name>result</name>,
	   (<name>char</name> *) <name>result</name> + (<name>nrow</name> * <name>size</name>) - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Return the size of a line's data.
 */</comment>
<function><type><name>static</name> <name>unsigned</name></type>
<name>sizeofScrnRow</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ncol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>sizeAttribs</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>sizeColors</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr>(<name>void</name>) <name>screen</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> = (<name>ncol</name> * (<name>unsigned</name>) <call><name>sizeof</name><argument_list>(<argument><expr><name>CharData</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AlignValue</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>result</name> *= <call>(<name>unsigned</name>) <argument_list>(<argument><expr>1 + <name>screen</name>-&gt;<name>max_combining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>sizeAttribs</name> = (<name>ncol</name> * <call><name>SizeofScrnPtr</name><argument_list>(<argument><expr><name>attribs</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AlignValue</name><argument_list>(<argument><expr><name>sizeAttribs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> += <name>sizeAttribs</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <expr_stmt><expr><name>sizeColors</name> = (<name>ncol</name> * <call><name>SizeofScrnPtr</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AlignValue</name><argument_list>(<argument><expr><name>sizeColors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> += <name>sizeColors</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>Char</name> *</type>
<name>allocScrnData</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>nrow</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ncol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Char</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> =<init> <expr>(<name>nrow</name> * <call><name>sizeofScrnRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ncol</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>result</name> = (<name>Char</name> *) <call><name>calloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
	<expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_SCALLOC2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <macro><name>TRACE</name><argument_list>(<argument>("allocScrnData %ux%u -&gt; %lu -&gt; %p..%p\n",
	   nrow, ncol, (unsigned long) length, result, result + length - 1)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Allocates memory for a 2-dimensional array of chars and returns a pointer
 * thereto.  Each line is formed from a set of char arrays, with an index
 * (i.e., the ScrnBuf type).  The first pointer in the index is reserved for
 * per-line flags, and does not point to data.
 *
 * After the per-line flags, we have a series of pointers to char arrays:  The
 * first one is the actual character array, the second one is the attributes,
 * the third is the foreground and background colors, and the fourth denotes
 * the character set.
 *
 * We store it all as pointers, because of alignment considerations.
 */</comment>
<function><type><name>ScrnBuf</name></type>
<name>allocScrnBuf</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>nrow</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ncol</name></decl></param>, <param><decl><type><name>Char</name> **</type> <name>addr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>base</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nrow</name> != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>base</name> = <call><name>allocScrnHead</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>addr</name> = <call><name>allocScrnData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>, <argument><expr><name>ncol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setupLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>*<name>addr</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>, <argument><expr><name>ncol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("allocScrnBuf %dx%d -&gt;%p\n", <name>nrow</name>, <name>ncol</name>, (<name>void</name> *) <name>base</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>base</name>)</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
<comment type="block">/*
 * Copy line-data from the visible (edit) buffer to the save-lines buffer.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>saveEditBufLines</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>sb</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...copying %d lines from editBuf to saveBuf\n", <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
    <expr_stmt><expr>(<name>void</name>) <name>sb</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>dst</name> =<init> <expr><call><name>addScrollback</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>k</name> =<init> <expr>(<name>screen</name>-&gt;<name>savelines</name> + <name>j</name> - <name>n</name>)</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>dst</name> =<init> <expr>(<name>LineData</name> *) <call><name>scrnHeadAddr</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>src</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>int</name>) <name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>copyLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<comment type="block">/*
 * Copy line-data from the save-lines buffer to the visible (edit) buffer.
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>unsaveEditBufLines</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>sb</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...copying %d lines from saveBuf to editBuf\n", <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>extra</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>n</name> - <name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>dst</name> =<init> <expr>(<name>LineData</name> *) <call><name>scrnHeadAddr</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>src</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>screen</name>-&gt;<name>saved_fifo</name> - <name>extra</name>) &lt;= 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...FIXME: must clear text!\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if>
	<expr_stmt><expr><name>src</name> = <call><name>getScrollback</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>-<name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>k</name> =<init> <expr>(<name>screen</name>-&gt;<name>savelines</name> - <name>extra</name>)</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>src</name> =<init> <expr>(<name>LineData</name> *) <call><name>scrnHeadAddr</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
						  <argument><expr><name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>copyLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 *  This is called when the screen is resized.
 *  Returns the number of lines the text was moved down (neg for up).
 *  (Return value only necessary with SouthWestGravity.)
 */</comment>
<function><type><name>static</name> <name>int</name></type>
<name>Reallocate</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	   <param><decl><type><name>ScrnBuf</name> *</type> <name>sbuf</name></decl></param>,
	   <param><decl><type><name>Char</name> **</type> <name>sbufaddr</name></decl></param>,
	   <param><decl><type><name>unsigned</name></type> <name>nrow</name></decl></param>,
	   <param><decl><type><name>unsigned</name></type> <name>ncol</name></decl></param>,
	   <param><decl><type><name>unsigned</name></type> <name>oldrow</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>oldBufHead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>newBufHead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>newBufData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>minrows</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>oldBufData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>move_down</name> =<init> <expr>0</expr>, <expr><name>move_up</name> = 0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>sbuf</name> == <name>NULL</name> || *<name>sbuf</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<return>return <expr>0</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>oldBufData</name> = *<name>sbufaddr</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Reallocate %dx%d -&gt; %dx%d\n", <name>oldrow</name>, <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>, <name>nrow</name>, <name>ncol</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * realloc sbuf, the pointers to all the lines.
     * If the screen shrinks, remove lines off the top of the buffer
     * if resizeGravity resource says to do so.
     */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("Check move_up, nrow %d vs oldrow %d (resizeGravity %s)\n",
	   <name>nrow</name>, <name>oldrow</name>,
	   <call><name>BtoS</name><argument_list>(<argument><expr><call><name>GravityIsSouthWest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>GravityIsSouthWest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>nrow</name> &lt; <name>oldrow</name></expr>)</condition><then> <block>{
	    <comment type="block">/* Remove lines off the top of the buffer if necessary. */</comment>
	    <expr_stmt><expr><name>move_up</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name>oldrow</name> - <name>nrow</name></expr></argument>)</argument_list></call>
		- (<call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>max_row</name> - <call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>cur_row</name>)</expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>move_up</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>move_up</name> = 0</expr>;</expr_stmt></then></if>
	    <comment type="block">/* Overlapping move here! */</comment>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("move_up %d\n", <name>move_up</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>move_up</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>ScrnBuf</name></type> <name>dst</name> =<init> <expr>*<name>sbuf</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>(<name>int</name>) <name>oldrow</name> - <name>move_up</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"before move_up"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>oldrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SaveLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>size_t</name>) <name>move_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MoveLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>size_t</name>) <name>move_up</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RestoreLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>move_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"after move_up"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>oldrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>oldBufHead</name> = *<name>sbuf</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>sbuf</name> = <call><name>allocScrnHead</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>nrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newBufHead</name> = *<name>sbuf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the new buffer space and copy old buffer contents there, line by
     * line.
     */</comment>
    <expr_stmt><expr><name>newBufData</name> = <call><name>allocScrnData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>, <argument><expr><name>ncol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>sbufaddr</name> = <name>newBufData</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>minrows</name> = (<name>oldrow</name> &lt; <name>nrow</name>) ? <name>oldrow</name> : <name>nrow</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>GravityIsSouthWest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>nrow</name> &gt; <name>oldrow</name></expr>)</condition><then> <block>{
	    <comment type="block">/* move data down to bottom of expanded screen */</comment>
	    <expr_stmt><expr><name>move_down</name> = <call><name>Min</name><argument_list>(<argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>nrow</name> - <name>oldrow</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>savedlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>setupLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>newBufHead</name></expr></argument>, <argument><expr>*<name>sbufaddr</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>, <argument><expr><name>ncol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>extractScrnData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>newBufHead</name></expr></argument>, <argument><expr><name>oldBufHead</name></expr></argument>, <argument><expr><name>minrows</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
		    <argument><expr>0
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		    (<name>unsigned</name>) <name>move_down</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldBufHead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now free the old data */</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldBufData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...Reallocate %dx%d -&gt;%p\n", <name>nrow</name>, <name>ncol</name>, (<name>void</name> *) <name>newBufHead</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>move_down</name> ? <name>move_down</name> : -<name>move_up</name></expr>;</return>	<comment type="block">/* convert to rows */</comment>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
<comment type="block">/*
 * This function reallocates memory if changing the number of Buf offsets.
 * The code is based on Reallocate().
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ReallocateBufOffsets</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		     <param><decl><type><name>ScrnBuf</name> *</type> <name>sbuf</name></decl></param>,
		     <param><decl><type><name>Char</name> **</type> <name>sbufaddr</name></decl></param>,
		     <param><decl><type><name>unsigned</name></type> <name>nrow</name></decl></param>,
		     <param><decl><type><name>unsigned</name></type> <name>ncol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>newBufHead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>oldBufData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>oldBufHead</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name></type> <name>old_jump</name> =<init> <expr><call><name>scrnHeadSize</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>new_jump</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>new_ptrs</name> =<init> <expr>1 + <call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>max_combining</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>dstCols</name> =<init> <expr><name>ncol</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>srcCols</name> =<init> <expr><name>ncol</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>dstPtrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>srcPtrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>nextPtr</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nrow</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ncol</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldBufData</name> = *<name>sbufaddr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldBufHead</name> = *<name>sbuf</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Allocate a new LineData array, retain the old one until we've copied
     * the data that it points to, as well as non-pointer data, e.g., bufHead.
     *
     * Turn on wide-chars temporarily when constructing pointers, since that is
     * used to decide whether to address the combData[] array, which affects
     * the length of the LineData structure.
     */</comment>
    <expr_stmt><expr><name>screen</name>-&gt;<name>wide_chars</name> = <name>True</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>new_jump</name> = <call><name>scrnHeadSize</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newBufHead</name> = <call><name>allocScrnHead</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>sbufaddr</name> = <call><name>allocScrnData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>, <argument><expr><name>ncol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setupLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>newBufHead</name></expr></argument>, <argument><expr>*<name>sbufaddr</name></expr></argument>, <argument><expr><name>nrow</name></expr></argument>, <argument><expr><name>ncol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>screen</name>-&gt;<name>wide_chars</name> = <name>False</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nextPtr</name> = *<name>sbufaddr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>srcPtrs</name> = (<name>LineData</name> *) <name>oldBufHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dstPtrs</name> = (<name>LineData</name> *) <name>newBufHead</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nrow</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><name>dstPtrs</name>-&gt;<name>bufHead</name> = <name>srcPtrs</name>-&gt;<name>bufHead</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExtractScrnData</name><argument_list>(<argument><expr><name>attribs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	<expr_stmt><expr><call><name>ExtractScrnData</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>ExtractScrnData</name><argument_list>(<argument><expr><name>charData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nextPtr</name> += <name>ncol</name> * <name>new_ptrs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcPtrs</name> = <call><name>LineDataAddr</name><argument_list>(<argument><expr><name>srcPtrs</name></expr></argument>, <argument><expr><name>old_jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dstPtrs</name> = <call><name>LineDataAddr</name><argument_list>(<argument><expr><name>dstPtrs</name></expr></argument>, <argument><expr><name>new_jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* Now free the old data */</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldBufData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldBufHead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>*<name>sbuf</name> = <name>newBufHead</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ReallocateBufOffsets %dx%d -&gt;%p\n", <name>nrow</name>, <name>ncol</name>, *<name>sbufaddr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * This function dynamically adds support for wide-characters.
 */</comment>
<function><type><name>void</name></type>
<name>ChangeToWide</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ChangeToWide\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>xtermLoadWideFonts</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>whichBuf</name> =<init> <expr><name>screen</name>-&gt;<name>whichBuf</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_FIFO_LINES</name> || !<name>OPT_SAVE_LINES</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>savelines</name> =<init> <expr><name>screen</name>-&gt;<name>scrollWidget</name> ? <name>screen</name>-&gt;<name>savelines</name> : 0</expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>savelines</name> &lt; 0</expr>)</condition><then>
	    <expr_stmt><expr><name>savelines</name> = 0</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If we're displaying the alternate screen, switch the pointers back
	 * temporarily so ReallocateBufOffsets() will operate on the proper
	 * data in the alternate buffer.
	 */</comment>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>SwitchBufPtrs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_FIFO_LINES</name></expr></cpp:if>
	<expr_stmt><expr><call><name>ReallocateBufOffsets</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			     <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
			     <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>,
			     <argument><expr>(<name>unsigned</name>) <name>savelines</name></expr></argument>,
			     <argument><expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ReallocateBufOffsets</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				 <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>0</expr>]</index></name></expr></argument>,
				 <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr>0</expr>]</index></name></expr></argument>,
				 <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>ReallocateBufOffsets</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			     <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
			     <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>,
			     <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>savelines</name></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>ReallocateBufOffsets</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				 <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name></expr></argument>,
				 <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr>1</expr>]</index></name></expr></argument>,
				 <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>screen</name>-&gt;<name>wide_chars</name> = <name>True</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>visbuf</name> = <call><name>VisBuf</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch the pointers back before we start painting on the screen.
	 */</comment>
	<if>if <condition>(<expr><name>whichBuf</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>SwitchBufPtrs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>whichBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>update_font_utf8_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVTFont</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>menu_font_number</name></expr></argument>, <argument><expr><name>True</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...ChangeToWide\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Clear cells, no side-effects.
 */</comment>
<function><type><name>void</name></type>
<name>ClearCells</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>len</name> != 0</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>flags</name> = <call>(<name>int</name>) <argument_list>(<argument><expr>(<name>unsigned</name>) <name>flags</name> | <call><name>TERM_COLOR_FLAGS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
	    <expr_stmt><expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr>(<name>unsigned</name>) <name>col</name> + <name>n</name></expr>]</index></name> = (<name>CharData</name>) ' '</expr>;</expr_stmt></for>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name>attribs</name> + <name>col</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	    CellColor p = xtermColorPair(xw);
	    for (n = 0; n &lt; len; ++n) {
		ld-&gt;color[(unsigned) col + n] = p;
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    size_t off;
	    for_each_combData(off, ld) {
		memset(ld-&gt;combData[off] + col, 0, (size_t) len * sizeof(CharData));
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Clear data in the screen-structure (no I/O).
 * Check for wide-character damage as well, clearing the damaged cells.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnClearCells</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	int kl;
	int kr;

	if (DamagedCells(screen, len, &amp;kl, &amp;kr, row, col)
	    &amp;&amp; kr &gt;= kl) {
	    ClearCells(xw, flags, (unsigned) (kr - kl + 1), row, kl);
	}
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>ClearCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Disown the selection and repaint the area that is highlighted so it is no
 * longer highlighted.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnDisownSelection</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>-&gt;<name>keepSelection</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>UnhiliteSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>DisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Writes str into buf at screen's current row and column.  Characters are set
 * to match flags.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnWriteText</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	      <param><decl><type><name>IChar</name> *</type> <name>str</name></decl></param>,
	      <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,
	      <param><decl><type><name>unsigned</name></type> <name>cur_fg_bg</name></decl></param>,
	      <param><decl><type><name>unsigned</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Char</name> *</type><name>attrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>avail</name> =<init> <expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IChar</name> *</type><name>chars</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>IChar</name></type> <name>starcol1</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>real_width</name> =<init> <expr><call><name>visual_width</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>) <name>cur_fg_bg</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>real_width</name> + (<name>unsigned</name>) <name>screen</name>-&gt;<name>cur_col</name> &gt; (<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>real_width</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <name>screen</name>-&gt;<name>cur_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>avail</name> &lt;= 0</expr>)</condition><then>
	<return>return;</return></then></if>
    <if>if <condition>(<expr><name>length</name> &gt; (<name>unsigned</name>) <name>avail</name></expr>)</condition><then>
	<expr_stmt><expr><name>length</name> = (<name>unsigned</name>) <name>avail</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>length</name> == 0 || <name>real_width</name> == 0</expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>chars</name> = <name>ld</name>-&gt;<name>charData</name> + <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>attrs</name> = <name>ld</name>-&gt;<name>attribs</name> + <name>screen</name>-&gt;<name>cur_col</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
    <expr_stmt><expr><name>starcol1</name> = *<name>chars</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* write blanks if we're writing invisible text */</comment>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
	<if>if <condition>(<expr>(<name>flags</name> &amp; <name>INVISIBLE</name>)</expr>)</condition><then>
	    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>n</name></expr>]</index></name> = ' '</expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>n</name></expr>]</index></name> = <name><name>str</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt></else></if>
    }</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLINK_TEXT</name></expr></cpp:if>
    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>BLINK</name>) &amp;&amp; !(<name>screen</name>-&gt;<name>blink_as_bold</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>LineSetBlinked</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{

	if (real_width != length) {
	    IChar *char1 = chars;
	    if (screen-&gt;cur_col
		&amp;&amp; starcol1 == HIDDEN_CHAR
		&amp;&amp; isWide((int) char1[-1])) {
		char1[-1] = (CharData) ' ';
	    }
	    <comment type="block">/* if we are overwriting the right hand half of a
	       wide character, make the other half vanish */</comment>
	    while (length) {
		int ch = (int) str[0];

		*char1++ = *str++;
		length--;

		if (isWide(ch)) {
		    *char1++ = (CharData) HIDDEN_CHAR;
		}
	    }

	    if (*char1 == HIDDEN_CHAR
		&amp;&amp; char1[-1] == HIDDEN_CHAR) {
		*char1 = (CharData) ' ';
	    }
	    <comment type="block">/* if we are overwriting the left hand half of a
	       wide character, make the other half vanish */</comment>
	} else {
	    if (screen-&gt;cur_col
		&amp;&amp; starcol1 == HIDDEN_CHAR
		&amp;&amp; isWide((int) chars[-1])) {
		chars[-1] = (CharData) ' ';
	    }
	    <comment type="block">/* if we are overwriting the right hand half of a
	       wide character, make the other half vanish */</comment>
	    if (chars[length] == HIDDEN_CHAR
		&amp;&amp; isWide((int) chars[length - 1])) {
		chars[length] = (CharData) ' ';
	    }
	}
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>flags</name> &amp;= <name>ATTRIBUTES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> |= <name>CHARDRAWN</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr>(<name>Char</name>) <name>flags</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>real_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	size_t off;
	for_each_combData(off, ld) {
	    memset(ld-&gt;combData[off] + screen-&gt;cur_col,
		   0,
		   real_width * sizeof(CharData));
	}
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	unsigned j;
	for (j = 0; j &lt; real_width; ++j)
	    ld-&gt;color[screen-&gt;cur_col + (int) j] = (CellColor) cur_fg_bg;
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	screen-&gt;last_written_col = screen-&gt;cur_col + (int) real_width - 1;
	screen-&gt;last_written_row = screen-&gt;cur_row;
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <macro><name>if_OPT_XMC_GLITCH</name><argument_list>(<argument>screen</argument>, <argument>{
	Resolve_XMC(xw);
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <return>return;</return>
}</block></function>

<comment type="block">/*
 * Saves pointers to the n lines beginning at sb + where, and clears the lines
 */</comment>
<function><type><name>static</name> <name>void</name></type>
<name>ScrnClearLines</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>sb</name></decl></param>, <param><decl><type><name>int</name></type> <name>where</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScrnPtr</name> *</type><name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>jump</name> =<init> <expr><call><name>scrnHeadSize</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>work</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> =<init> <expr><call><name>TERM_COLOR_FLAGS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScrnClearLines(%s:where %d, n %d, size %d)\n",
	   (<name>sb</name> == <name>screen</name>-&gt;<name>saveBuf_index</name>) ? "save" : "edit",
	   <name>where</name>, <name>n</name>, <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* save n lines at where */</comment>
    <expr_stmt><expr><call><name>SaveLineData</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>where</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* clear contents of old rows */</comment>
    <expr_stmt><expr><name>base</name> = <name>screen</name>-&gt;<name>save_ptr</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<expr_stmt><expr><name>work</name> = (<name>LineData</name> *) <name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>work</name>-&gt;<name>bufHead</name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	<expr_stmt><expr><call><name>SetLineDblCS</name><argument_list>(<argument><expr><name>work</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>work</name>-&gt;<name>charData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>CharData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>TERM_COLOR_FLAGS</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>work</name>-&gt;<name>attribs</name></expr></argument>, <argument><expr>(<name>int</name>) <name>flags</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	    <block>{
		<decl_stmt><decl><type><name>CellColor</name></type> <name>p</name> =<init> <expr><call><name>xtermColorPair</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>size</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
		    <expr_stmt><expr><name>work</name>-&gt;<name><name>color</name><index>[<expr><name>j</name></expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
		}</block></for>
	    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>work</name>-&gt;<name>attribs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>size_t</name>) <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>work</name>-&gt;<name>color</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>work</name>-&gt;<name><name>color</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>wide_chars</name></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>size_t</name></type> <name>off</name></decl>;</decl_stmt>

	    <for>for (<init><expr><name>off</name> = 0</expr>;</init> <condition><expr><name>off</name> &lt; <name>work</name>-&gt;<name>combSize</name></expr>;</condition> <incr><expr>++<name>off</name></expr></incr>) <block>{
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>work</name>-&gt;<name><name>combData</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>CharData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></for>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>base</name> = <call><name>ScrnBufAddr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<comment type="block">/*
 * We're always ensured of having a visible buffer, but may not have saved
 * lines.  Check the pointer that's sure to work.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>OkAllocBuf</name>(screen) (screen-&gt;editBuf_index[0] != 0)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>OkAllocBuf</name>(screen) (screen-&gt;saveBuf_index != 0)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>ScrnAllocBuf</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>OkAllocBuf</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nrows</name> =<init> <expr><call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_SAVE_LINES</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>savelines</name> =<init> <expr><name>screen</name>-&gt;<name>scrollWidget</name> ? <name>screen</name>-&gt;<name>savelines</name> : 0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScrnAllocBuf %dx%d (%d)\n",
	       <name>nrows</name>, <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>, <name>screen</name>-&gt;<name>savelines</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>savelines</name> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
	    <comment type="block">/* for FIFO, we only need space for the index - addScrollback inits */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>saveBuf_index</name> = <call><name>allocScrnHead</name><argument_list>(<argument><expr><name>screen</name></expr></argument>,
						  <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>savelines</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>saveBuf_index</name> = <call><name>allocScrnBuf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
						 <argument><expr>(<name>unsigned</name>) <name>screen</name>-&gt;<name>savelines</name></expr></argument>,
						 <argument><expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>screen</name>-&gt;<name>saveBuf_index</name> = 0</expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>0</expr>]</index></name> = <call><name>allocScrnBuf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
						<argument><expr>(<name>unsigned</name>) <name>nrows</name></expr></argument>,
						<argument><expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !OPT_SAVE_LINES */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>saveBuf_index</name> = <call><name>allocScrnBuf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
					     <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>nrows</name> + <name>screen</name>-&gt;<name>savelines</name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SAVE_LINES */</comment>
	<expr_stmt><expr><name>screen</name>-&gt;<name>visbuf</name> = <call><name>VisBuf</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
}</block></function>

<function><type><name>size_t</name></type>
<name>ScrnPointers</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>result</name> =<init> <expr><call><name>scrnHeadSize</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>result</name> &gt; <name>screen</name>-&gt;<name>save_len</name></expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>save_len</name></expr>)</condition><then>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>save_ptr</name> = (<name>ScrnPtr</name> *) <call><name>realloc</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>save_ptr</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>screen</name>-&gt;<name>save_ptr</name> = (<name>ScrnPtr</name> *) <call><name>malloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name>screen</name>-&gt;<name>save_len</name> = <name>len</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>save_ptr</name> == 0</expr>)</condition><then>
	    <expr_stmt><expr><call><name>SysError</name><argument_list>(<argument><expr><name>ERROR_SAVE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("ScrnPointers %ld -&gt;%p\n", (<name>long</name>) <name>len</name>, <name>screen</name>-&gt;<name>save_ptr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Inserts n blank lines at sb + where, treating last as a bottom margin.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnInsertLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>sb</name></decl></param>, <param><decl><type><name>int</name></type> <name>last</name></decl></param>, <param><decl><type><name>int</name></type> <name>where</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name> =<init> <expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScrnInsertLine(last %d, where %d, n %d, size %d)\n",
	   <name>last</name>, <name>where</name>, <name>n</name>, <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>where</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last</name> &gt;= (<name>int</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last</name> &gt;= <name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* save n lines at bottom */</comment>
    <expr_stmt><expr><call><name>ScrnClearLines</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr>(<name>last</name> -= (<name>int</name>) <name>n</name> - 1)</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * WARNING, overlapping copy operation.  Move down lines (pointers).
     *
     *   +----|---------|--------+
     *
     * is copied in the array to:
     *
     *   +--------|---------|----+
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last</name> &gt;= <name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * This will never shift from the saveBuf to editBuf, so there is no need
     * to handle that case.
     */</comment>
    <expr_stmt><expr><call><name>MoveLineData</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,
		 <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>where</name> + (<name>int</name>) <name>n</name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr>(<name>unsigned</name>) <name>where</name></expr></argument>,
		 <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>last</name> - <name>where</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* reuse storage for new lines at where */</comment>
    <expr_stmt><expr><call><name>RestoreLineData</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>where</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Deletes n lines at sb + where, treating last as a bottom margin.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnDeleteLine</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>ScrnBuf</name></type> <name>sb</name></decl></param>, <param><decl><type><name>int</name></type> <name>last</name></decl></param>, <param><decl><type><name>int</name></type> <name>where</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name> =<init> <expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScrnDeleteLine(%s:last %d, where %d, n %d, size %d)\n",
	   (<name>sb</name> == <name>screen</name>-&gt;<name>saveBuf_index</name>) ? "save" : "edit",
	   <name>last</name>, <name>where</name>, <name>n</name>, <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>where</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last</name> &gt;= <name>where</name> + (<name>int</name>) <name>n</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* move up lines */</comment>
    <expr_stmt><expr><name>last</name> -= ((<name>int</name>) <name>n</name> - 1)</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>inSaveBuf</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_FIFO_LINES</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>from</name> =<init> <expr><name>where</name> + <name>n</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* we shouldn't be editing the saveBuf, only scroll into it */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last</name> &gt;= <name>screen</name>-&gt;<name>savelines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>sb</name> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
	    <comment type="block">/* copy lines from editBuf to saveBuf (allocating as we go...) */</comment>
	    <expr_stmt><expr><call><name>saveEditBufLines</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <expr_stmt><expr><call><name>ScrnClearLines</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* move the pointers within saveBuf */</comment>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...%smoving pointers in saveBuf (compare %d %d)\n",
		   ((<name>screen</name>-&gt;<name>savelines</name> &gt; <name>from</name>)
		    ? ""
		    : "SKIP "),
		   <name>screen</name>-&gt;<name>savelines</name>,
		   <name>from</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>savelines</name> &gt; <name>from</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>MoveLineData</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,
			     <argument><expr>(<name>unsigned</name>) <name>where</name></expr></argument>,
			     <argument><expr>(<name>unsigned</name>) <name>from</name></expr></argument>,
			     <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>screen</name>-&gt;<name>savelines</name> - <name>from</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/* reuse storage in saveBuf */</comment>
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...reuse %d lines storage in saveBuf\n", <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>RestoreLineData</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>screen</name>-&gt;<name>savelines</name> - <name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* copy lines from editBuf to saveBuf (into the reused storage) */</comment>
	    <expr_stmt><expr><call><name>saveEditBufLines</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>

	<comment type="block">/* adjust variables to fall-thru into changes only to editBuf */</comment>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...adjusting variables, to work on editBuf alone\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last</name> -= <name>screen</name>-&gt;<name>savelines</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>where</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>sb</name> = <name>screen</name>-&gt;<name>visbuf</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Scroll the visible buffer (editBuf).
     */</comment>
    <expr_stmt><expr><call><name>ScrnClearLines</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MoveLineData</name><argument_list>(<argument><expr><name>sb</name></expr></argument>,
		 <argument><expr>(<name>unsigned</name>) <name>where</name></expr></argument>,
		 <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>where</name> + (<name>int</name>) <name>n</name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><call>(<name>size_t</name>) <argument_list>(<argument><expr><name>last</name> - <name>where</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* reuse storage for new bottom lines */</comment>
    <expr_stmt><expr><call><name>RestoreLineData</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>last</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Inserts n blanks in screen at current row, col.  Size is the size of each
 * row.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnInsertChar</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MemMove</name>(data) \
    	for (j = last - 1; j &gt;= (col + (int) n); --j) \
	    data[j] = data[j - (int) n]</cpp:define>

    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> =<init> <expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr><name>screen</name>-&gt;<name>cur_row</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr><name>screen</name>-&gt;<name>cur_col</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>last</name> &lt;= (<name>col</name> + (<name>int</name>) <name>n</name>)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>last</name> &lt;= <name>col</name></expr>)</condition><then>
	    <return>return;</return></then></if>
	<expr_stmt><expr><name>n</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>last</name> - <name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_row</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last</name> &gt; (<name>int</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	int xx = screen-&gt;cur_row;
	int kl;
	int kr = screen-&gt;cur_col;
	if (DamagedCells(screen, n, &amp;kl, (int *) 0, xx, kr) &amp;&amp; kr &gt; kl) {
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
	}
	kr = screen-&gt;max_col - (int) n + 1;
	if (DamagedCells(screen, n, &amp;kl, (int *) 0, xx, kr) &amp;&amp; kr &gt; kl) {
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
	}
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr>(<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>MemMove</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name>charData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemMove</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name>attribs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	    MemMove(ld-&gt;color);
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    size_t off;
	    for_each_combData(off, ld) {
		MemMove(ld-&gt;combData[off]);
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ClearCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>CHARDRAWN</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MemMove</name></cpp:undef>
}</block></function>

<comment type="block">/*
 * Deletes n characters at current row, col.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnDeleteChar</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MemMove</name>(data) \
    	for (j = col; j &lt; last - (int) n; ++j) \
	    data[j] = data[j + (int) n]</cpp:define>

    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> =<init> <expr><call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr><name>screen</name>-&gt;<name>cur_row</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr><name>screen</name>-&gt;<name>cur_col</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>last</name> &lt;= (<name>col</name> + (<name>int</name>) <name>n</name>)</expr>)</condition><then> <block>{
	<if>if <condition>(<expr><name>last</name> &lt;= <name>col</name></expr>)</condition><then>
	    <return>return;</return></then></if>
	<expr_stmt><expr><name>n</name> = <call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>last</name> - <name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_col</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>cur_row</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last</name> &gt; (<name>int</name>) <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	int kl;
	int kr;
	if (DamagedCells(screen, n, &amp;kl, &amp;kr,
			 screen-&gt;cur_row,
			 screen-&gt;cur_col))
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr>(<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>MemMove</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name>charData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemMove</name><argument_list>(<argument><expr><name>ld</name>-&gt;<name>attribs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	    MemMove(ld-&gt;color);
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    size_t off;
	    for_each_combData(off, ld) {
		MemMove(ld-&gt;combData[off]);
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><call><name>LineClrWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ClearCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr>(<name>last</name> - (<name>int</name>) <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MemMove</name></cpp:undef>
}</block></function>

<comment type="block">/*
 * Repaints the area enclosed by the parameters.
 * Requires: (toprow, leftcol), (toprow + nrows, leftcol + ncols) are
 * 	     coordinates of characters in screen;
 *	     nrows and ncols positive.
 *	     all dimensions are based on single-characters.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnRefresh</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>toprow</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>leftcol</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>nrows</name></decl></param>,
	    <param><decl><type><name>int</name></type> <name>ncols</name></decl></param>,
	    <param><decl><type><name>Bool</name></type> <name>force</name></decl></param>)</parameter_list>		<comment type="block">/* ... leading/trailing spaces */</comment>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>y</name> =<init> <expr><name>toprow</name> * <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>screen</name>-&gt;<name>border</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxrow</name> =<init> <expr><name>toprow</name> + <name>nrows</name> - 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>scrollamt</name> =<init> <expr><name>screen</name>-&gt;<name>scroll_amt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>gc_changes</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__CYGWIN__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>static</name> <name>char</name></type> <name>first_time</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>recurse</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScrnRefresh top %d (%d,%d) - (%d,%d)%s {{\n",
	   <name>screen</name>-&gt;<name>topline</name>, <name>toprow</name>, <name>leftcol</name>,
	   <name>nrows</name>, <name>ncols</name>,
	   <name>force</name> ? " force" : "")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursorp</name>.<name>col</name> &gt;= <name>leftcol</name>
	&amp;&amp; <name>screen</name>-&gt;<name>cursorp</name>.<name>col</name> &lt;= (<name>leftcol</name> + <name>ncols</name> - 1)
	&amp;&amp; <name>screen</name>-&gt;<name>cursorp</name>.<name>row</name> &gt;= <call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>toprow</name></expr></argument>)</argument_list></call>
	&amp;&amp; <name>screen</name>-&gt;<name>cursorp</name>.<name>row</name> &lt;= <call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>maxrow</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<expr_stmt><expr><name>screen</name>-&gt;<name>cursor_state</name> = <name>OFF</name></expr>;</expr_stmt></then></if>

    <for>for (<init><expr><name>row</name> = <name>toprow</name></expr>;</init> <condition><expr><name>row</name> &lt;= <name>maxrow</name></expr>;</condition> <incr><expr><name>y</name> += <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>, <expr><name>row</name>++</expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
	<decl_stmt><decl><type><name>CellColor</name> *</type><name>fb</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ColorOf</name>(col) (CellColor) (fb ? fb[col] : 0)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>wideness</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>BLANK_CEL</name>(cell) (chars[cell] == ' ')</cpp:define>
	<decl_stmt><decl><type><name>IChar</name> *</type><name>chars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Char</name> *</type><name>attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr><name>leftcol</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>maxcol</name> =<init> <expr><name>leftcol</name> + <name>ncols</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hi_col</name> =<init> <expr><name>maxcol</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lastind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>test</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CellColor</name></type> <name>fg_bg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>fg</name> =<init> <expr>0</expr>, <expr><name>bg</name> = 0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GC</name></type> <name>gc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bool</name></type> <name>hilite</name></decl>;</decl_stmt>

	<expr_stmt><expr>(<name>void</name>) <name>fg</name></expr>;</expr_stmt>
	<expr_stmt><expr>(<name>void</name>) <name>bg</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_ISO_COLORS</name></expr></cpp:if>
	<expr_stmt><expr><name>fg_bg</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr><name>row</name> &lt; <name>screen</name>-&gt;<name>top_marg</name> || <name>row</name> &gt; <name>screen</name>-&gt;<name>bot_marg</name></expr>)</condition><then>
	    <expr_stmt><expr><name>lastind</name> = <name>row</name></expr>;</expr_stmt></then>
	<else>else
	    <expr_stmt><expr><name>lastind</name> = <name>row</name> - <name>scrollamt</name></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><name>lastind</name> &lt; 0 || <name>lastind</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	    <continue>continue;</continue></then></if>

	<expr_stmt><expr><call><name>TRACE2</name><argument_list>(<argument><expr>("ScrnRefresh row=%d lastind=%d -&gt;%d\n",
		<name>row</name>, <name>lastind</name>, <call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>lastind</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>(<name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><call><name>ROW2INX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>lastind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == 0
	    || <name>ld</name>-&gt;<name>charData</name> == 0
	    || <name>ld</name>-&gt;<name>attribs</name> == 0</expr>)</condition><then> <block>{
	    <break>break;</break>
	}</block></then></if>
	<if>if <condition>(<expr><name>maxcol</name> &gt;= (<name>int</name>) <name>ld</name>-&gt;<name>lineSize</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>maxcol</name> = <name>ld</name>-&gt;<name>lineSize</name> - 1</expr>;</expr_stmt>
	    <expr_stmt><expr><name>hi_col</name> = <name>maxcol</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>chars</name> = <name>ld</name>-&gt;<name>charData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrs</name> = <name>ld</name>-&gt;<name>attribs</name></expr>;</expr_stmt>

	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    <comment type="block">/* This fixes an infinite recursion bug, that leads
	       to display anomalies. It seems to be related to
	       problems with the selection. */</comment>
	    if (recurse &lt; 3) {
		<comment type="block">/* adjust to redraw all of a widechar if we just wanted
		   to draw the right hand half */</comment>
		if (leftcol &gt; 0 &amp;&amp;
		    chars[leftcol] == HIDDEN_CHAR &amp;&amp;
		    isWide((int) chars[leftcol - 1])) {
		    leftcol--;
		    ncols++;
		    col = leftcol;
		}
	    } else {
		fprintf(stderr, "This should not happen. Why is it so?\n");
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<if>if <condition>(<expr><name>row</name> &lt; <name>screen</name>-&gt;<name>startH</name>.<name>row</name> || <name>row</name> &gt; <name>screen</name>-&gt;<name>endH</name>.<name>row</name> ||
	    (<name>row</name> == <name>screen</name>-&gt;<name>startH</name>.<name>row</name> &amp;&amp; <name>maxcol</name> &lt; <name>screen</name>-&gt;<name>startH</name>.<name>col</name>) ||
	    (<name>row</name> == <name>screen</name>-&gt;<name>endH</name>.<name>row</name> &amp;&amp; <name>col</name> &gt;= <name>screen</name>-&gt;<name>endH</name>.<name>col</name>)</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	    <comment type="block">/*
	     * Temporarily change dimensions to double-sized characters so
	     * we can reuse the recursion on this function.
	     */</comment>
	    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>col</name> /= 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>maxcol</name> /= 2</expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <comment type="block">/*
	     * If row does not intersect selection; don't hilite blanks.
	     */</comment>
	    <if>if <condition>(<expr>!<name>force</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr><name>col</name> &lt;= <name>maxcol</name> &amp;&amp; (<name><name>attrs</name><index>[<expr><name>col</name></expr>]</index></name> &amp; ~<name>BOLD</name>) == 0 &amp;&amp;
		       <call><name>BLANK_CEL</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>)</condition>
		    <expr_stmt><expr><name>col</name>++</expr>;</expr_stmt></while>

		<while>while <condition>(<expr><name>col</name> &lt;= <name>maxcol</name> &amp;&amp; (<name><name>attrs</name><index>[<expr><name>maxcol</name></expr>]</index></name> &amp; ~<name>BOLD</name>) == 0 &amp;&amp;
		       <call><name>BLANK_CEL</name><argument_list>(<argument><expr><name>maxcol</name></expr></argument>)</argument_list></call></expr>)</condition>
		    <expr_stmt><expr><name>maxcol</name>--</expr>;</expr_stmt></while>
	    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_CHRSET</name></expr></cpp:if>
	    <if>if <condition>(<expr><call><name>CSET_DOUBLE</name><argument_list>(<argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>col</name> *= 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>maxcol</name> *= 2</expr>;</expr_stmt>
	    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <expr_stmt><expr><name>hilite</name> = <name>False</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	    <comment type="block">/* row intersects selection; split into pieces of single type */</comment>
	    <if>if <condition>(<expr><name>row</name> == <name>screen</name>-&gt;<name>startH</name>.<name>row</name> &amp;&amp; <name>col</name> &lt; <name>screen</name>-&gt;<name>startH</name>.<name>col</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>recurse</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>startH</name>.<name>col</name> - <name>col</name></expr></argument>,
			    <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>col</name> = <name>screen</name>-&gt;<name>startH</name>.<name>col</name></expr>;</expr_stmt>
	    }</block></then></if>
	    <if>if <condition>(<expr><name>row</name> == <name>screen</name>-&gt;<name>endH</name>.<name>row</name> &amp;&amp; <name>maxcol</name> &gt;= <name>screen</name>-&gt;<name>endH</name>.<name>col</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>recurse</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>endH</name>.<name>col</name></expr></argument>, <argument><expr>1</expr></argument>,
			    <argument><expr><name>maxcol</name> - <name>screen</name>-&gt;<name>endH</name>.<name>col</name> + 1</expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxcol</name> = <name>screen</name>-&gt;<name>endH</name>.<name>col</name> - 1</expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/*
	     * If we're highlighting because the user is doing cut/paste,
	     * trim the trailing blanks from the highlighted region so we're
	     * showing the actual extent of the text that'll be cut.  If
	     * we're selecting a blank line, we'll highlight one column
	     * anyway.
	     *
	     * We don't do this if the mouse-hilite mode is set because that
	     * would be too confusing.
	     *
	     * The default if the highlightSelection resource isn't set will
	     * highlight the whole width of the terminal, which is easy to
	     * see, but harder to use (because trailing blanks aren't as
	     * apparent).
	     */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>highlight_selection</name>
		&amp;&amp; <name>screen</name>-&gt;<name>send_mouse_pos</name> != <name>VT200_HIGHLIGHT_MOUSE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hi_col</name> = <name>screen</name>-&gt;<name>max_col</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>hi_col</name> &gt; 0 &amp;&amp; !(<name><name>attrs</name><index>[<expr><name>hi_col</name></expr>]</index></name> &amp; <name>CHARDRAWN</name>)</expr>)</condition>
		    <expr_stmt><expr><name>hi_col</name>--</expr>;</expr_stmt></while>
	    }</block></then></if>

	    <comment type="block">/* remaining piece should be hilited */</comment>
	    <expr_stmt><expr><name>hilite</name> = <name>True</name></expr>;</expr_stmt>
	}</block></else></if>

	<if>if <condition>(<expr><name>col</name> &gt; <name>maxcol</name></expr>)</condition><then>
	    <continue>continue;</continue></then></if>

	<comment type="block">/*
	 * Go back to double-sized character dimensions if the line has
	 * double-width characters.  Note that 'hi_col' is already in the
	 * right units.
	 */</comment>
	<macro><name>if_OPT_DEC_CHRSET</name><argument_list>(<argument>{
	    if (CSET_DOUBLE(GetLineDblCS(ld))) {
		col /= 2;
		maxcol /= 2;
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><name>flags</name> = <name><name>attrs</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt>

	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    wideness = isWide((int) chars[col]);
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	    fb = ld-&gt;color;
	    fg_bg = ColorOf(col);
	    fg = extract_fg(xw, fg_bg, flags);
	    bg = extract_bg(xw, fg_bg, flags);
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><name>gc</name> = <call><name>updatedXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>hilite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>gc_changes</name> |= (<name>flags</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name>))</expr>;</expr_stmt>

	<expr_stmt><expr><name>x</name> = <call><name>LineCursorX</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastind</name> = <name>col</name></expr>;</expr_stmt>

	<for>for (<init>;</init> <condition><expr><name>col</name> &lt;= <name>maxcol</name></expr>;</condition> <incr><expr><name>col</name>++</expr></incr>) <block>{
	    <if>if <condition>(<expr>(<name><name>attrs</name><index>[<expr><name>col</name></expr>]</index></name> != <name>flags</name>)
		|| (<name>hilite</name> &amp;&amp; (<name>col</name> &gt; <name>hi_col</name>))
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
		|| ((<name>flags</name> &amp; <name>FG_COLOR</name>)
		    &amp;&amp; (<call><name>extract_fg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>ColorOf</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attrs</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call> != <name>fg</name>))
		|| ((<name>flags</name> &amp; <name>BG_COLOR</name>)
		    &amp;&amp; (<call><name>extract_bg</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><call><name>ColorOf</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attrs</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call> != <name>bg</name>))
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_WIDE_CHARS</name></expr></cpp:if>
		|| (<call><name>isWide</name><argument_list>(<argument><expr>(<name>int</name>) <name><name>chars</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call> != <name>wideness</name>
		    &amp;&amp; <name><name>chars</name><index>[<expr><name>col</name></expr>]</index></name> != <name>HIDDEN_CHAR</name>)</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>col</name> &gt;= <name>lastind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScrnRefresh looping drawXtermText %d..%d:%s\n",
		       <name>lastind</name>, <name>col</name>,
		       <call><name>visibleIChars</name><argument_list>(<argument><expr>(&amp;<name><name>chars</name><index>[<expr><name>lastind</name></expr>]</index></name>)</expr></argument>,
				     <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>col</name> - <name>lastind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>test</name> = <name>flags</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>checkVeryBoldColors</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>x</name> = <call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>test</name> &amp; <name>DRAWX_MASK</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
				  <argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr>&amp;<name><name>chars</name><index>[<expr><name>lastind</name></expr>]</index></name></expr></argument>,
				  <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>col</name> - <name>lastind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		    int i;
		    size_t off;

		    for_each_combData(off, ld) {
			IChar *com_off = ld-&gt;combData[off];

			for (i = lastind; i &lt; col; i++) {
			    int my_x = LineCursorX(screen, ld, i);
			    IChar base = chars[i];

			    if (isWide((int) base))
				my_x = LineCursorX(screen, ld, i - 1);

			    if (com_off[i] != 0)
				drawXtermText(xw,
					      (test &amp; DRAWX_MASK)
					      | NOBACKGROUND,
					      gc, my_x, y,
					      GetLineDblCS(ld),
					      com_off + i,
					      1, isWide((int) base));
			}
		    }
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<expr_stmt><expr><call><name>resetXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hilite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lastind</name> = <name>col</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>hilite</name> &amp;&amp; (<name>col</name> &gt; <name>hi_col</name>)</expr>)</condition><then>
		    <expr_stmt><expr><name>hilite</name> = <name>False</name></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>flags</name> = <name><name>attrs</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt>
		<macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
		    fg_bg = ColorOf(col);
		    fg = extract_fg(xw, fg_bg, flags);
		    bg = extract_bg(xw, fg_bg, flags);
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		    wideness = isWide((int) chars[col]);
		}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<expr_stmt><expr><name>gc</name> = <call><name>updatedXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fg_bg</name></expr></argument>, <argument><expr><name>hilite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gc_changes</name> |= (<name>flags</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name>))</expr>;</expr_stmt>
	    }</block></then></if>

	    <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>col</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>chars</name><index>[<expr><name>col</name></expr>]</index></name> = ' '</expr>;</expr_stmt>
	    }</block></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>col</name> &gt;= <name>lastind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScrnRefresh calling drawXtermText %d..%d:%s\n",
	       <name>lastind</name>, <name>col</name>,
	       <call><name>visibleIChars</name><argument_list>(<argument><expr>&amp;<name><name>chars</name><index>[<expr><name>lastind</name></expr>]</index></name></expr></argument>, <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>col</name> - <name>lastind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>test</name> = <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkVeryBoldColors</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>drawXtermText</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>test</name> &amp; <name>DRAWX_MASK</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
		      <argument><expr><call><name>GetLineDblCS</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr>&amp;<name><name>chars</name><index>[<expr><name>lastind</name></expr>]</index></name></expr></argument>,
		      <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>col</name> - <name>lastind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
	    int i;
	    size_t off;

	    for_each_combData(off, ld) {
		IChar *com_off = ld-&gt;combData[off];

		for (i = lastind; i &lt; col; i++) {
		    int my_x = LineCursorX(screen, ld, i);
		    int base = (int) chars[i];

		    if (isWide(base))
			my_x = LineCursorX(screen, ld, i - 1);

		    if (com_off[i] != 0)
			drawXtermText(xw,
				      (test &amp; DRAWX_MASK)
				      | NOBACKGROUND,
				      gc, my_x, y,
				      GetLineDblCS(ld),
				      com_off + i,
				      1, isWide(base));
		}
	    }
	}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><call><name>resetXtermGC</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hilite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/*
     * If we're in color mode, reset the various GC's to the current
     * screen foreground and background so that other functions (e.g.,
     * ClearRight) will get the correct colors.
     */</comment>
    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
	if (gc_changes &amp; FG_COLOR)
	    SGR_Foreground(xw, xw-&gt;cur_foreground);
	if (gc_changes &amp; BG_COLOR)
	    SGR_Background(xw, xw-&gt;cur_background);
    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>TIOCSWINSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr><name>first_time</name> == 1</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>TTYSIZE_STRUCT</name></type> <name>ts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>first_time</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TTYSIZE_ROWS</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call> = <name>nrows</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TTYSIZE_COLS</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call> = <name>ncols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ts</name>.<name>ws_xpixel</name> = <name>xw</name>-&gt;<name>core</name>.<name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ts</name>.<name>ws_ypixel</name> = <name>xw</name>-&gt;<name>core</name>.<name>height</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_TTYSIZE</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>recurse</name>--</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...}} ScrnRefresh\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<comment type="block">/*
 * Call this wrapper to ScrnRefresh() when the data has changed.  If the
 * refresh region overlaps the selection, we will release the primary selection.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnUpdate</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>toprow</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>leftcol</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>nrows</name></decl></param>,
	   <param><decl><type><name>int</name></type> <name>ncols</name></decl></param>,
	   <param><decl><type><name>Bool</name></type> <name>force</name></decl></param>)</parameter_list>		<comment type="block">/* ... leading/trailing spaces */</comment>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>ScrnHaveSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	&amp;&amp; (<name>toprow</name> &lt;= <name>screen</name>-&gt;<name>endH</name>.<name>row</name>)
	&amp;&amp; (<name>toprow</name> + <name>nrows</name> - 1 &gt;= <name>screen</name>-&gt;<name>startH</name>.<name>row</name>)</expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>ScrnDisownSelection</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>toprow</name></expr></argument>, <argument><expr><name>leftcol</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Sets the rows first though last of the buffer of screen to spaces.
 * Requires first &lt;= last; first, last are rows of screen-&gt;buf.
 */</comment>
<function><type><name>void</name></type>
<name>ClearBufRows</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	     <param><decl><type><name>int</name></type> <name>first</name></decl></param>,
	     <param><decl><type><name>int</name></type> <name>last</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> =<init> <expr>(<name>unsigned</name>) <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ClearBufRows %d..%d\n", <name>first</name>, <name>last</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>row</name> = <name>first</name></expr>;</init> <condition><expr><name>row</name> &lt;= <name>last</name></expr>;</condition> <incr><expr><name>row</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>ld</name> != 0</expr>)</condition><then> <block>{
	    <macro><name>if_OPT_DEC_CHRSET</name><argument_list>(<argument>{
		<comment type="block">/* clearing the whole row resets the doublesize characters */</comment>
		SetLineDblCS(ld, CSET_SWL);
	    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	    <expr_stmt><expr><call><name>LineClrWrapped</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ClearCells</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>
}</block></function>

<comment type="block">/*
  Resizes screen:
  1. If new window would have fractional characters, sets window size so as to
  discard fractional characters and returns -1.
  Minimum screen size is 1 X 1.
  Note that this causes another ExposeWindow event.
  2. Enlarges screen-&gt;buf if necessary.  New space is appended to the bottom
  and to the right
  3. Reduces  screen-&gt;buf if necessary.  Old space is removed from the bottom
  and from the right
  4. Cursor is positioned as closely to its former position as possible
  5. Sets screen-&gt;max_row and screen-&gt;max_col to reflect new size
  6. Maintains the inner border (and clears the border on the screen).
  7. Clears origin mode and sets scrolling region to be entire screen.
  8. Returns 0
  */</comment>
<function><type><name>int</name></type>
<name>ScreenResize</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
	     <param><decl><type><name>int</name></type> <name>width</name></decl></param>,
	     <param><decl><type><name>int</name></type> <name>height</name></decl></param>,
	     <param><decl><type><name>unsigned</name> *</type><name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name>, <name>rows</name>, <name>cols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>border</name> =<init> <expr>2 * <name>screen</name>-&gt;<name>border</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>move_down_by</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TTYSIZE_STRUCT</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TTYSIZE_STRUCT</name></type> <name>ts</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>Window</name></type> <name>tw</name> =<init> <expr><call><name>VWindow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScreenResize %dx%d border %d font %dx%d\n",
	   <name>height</name>, <name>width</name>, <name>border</name>,
	   <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>, <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>width</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>height</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>screen</name>-&gt;<name>is_running</name></expr>)</condition><then> <block>{
	<comment type="block">/* clear the right and bottom internal border because of NorthWest
	   gravity might have left junk on the right and bottom edges */</comment>
	<if>if <condition>(<expr><name>width</name> &gt;= (<name>int</name>) <call><name>FullWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XClearArea</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>tw</name></expr></argument>,
		       <argument><expr><call><name>FullWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>,	<comment type="block">/* right edge */</comment>
		       <argument><expr>0</expr></argument>, <argument><expr>(<name>unsigned</name>) <name>height</name></expr></argument>,	<comment type="block">/* from top to bottom */</comment>
		       <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>height</name> &gt;= (<name>int</name>) <call><name>FullHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>XClearArea</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>display</name></expr></argument>, <argument><expr><name>tw</name></expr></argument>,
		       <argument><expr>0</expr></argument>, <argument><expr><call><name>FullHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>,	<comment type="block">/* bottom */</comment>
		       <argument><expr>(<name>unsigned</name>) <name>width</name></expr></argument>, <argument><expr>0</expr></argument>,	<comment type="block">/* all across the bottom */</comment>
		       <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...computing rows/cols: %.2f %.2f\n",
	   <call>(<name>double</name>) <argument_list>(<argument><expr><name>height</name> - <name>border</name></expr></argument>)</argument_list></call> / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>,
	   <call>(<name>double</name>) <argument_list>(<argument><expr><name>width</name> - <name>border</name> - <call><name>ScrollbarWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rows</name> = (<name>height</name> - <name>border</name>) / <call><name>FontHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cols</name> = (<name>width</name> - <name>border</name> - <call><name>ScrollbarWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>) / <call><name>FontWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rows</name> &lt; 1</expr>)</condition><then>
	<expr_stmt><expr><name>rows</name> = 1</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>cols</name> &lt; 1</expr>)</condition><then>
	<expr_stmt><expr><name>cols</name> = 1</expr>;</expr_stmt></then></if>

    <comment type="block">/* update buffers if the screen has changed size */</comment>
    <if>if <condition>(<expr><call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> != <name>rows</name> || <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> != <name>cols</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>whichBuf</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>delta_rows</name> =<init> <expr><name>rows</name> - <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>delta_cols</name> =<init> <expr><name>cols</name> - <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...ScreenResize chars %dx%d delta %dx%d\n",
	       <name>rows</name>, <name>cols</name>, <name>delta_rows</name>, <name>delta_cols</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>is_running</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_FIFO_LINES</name></expr></cpp:if>
	    <decl_stmt><decl><type><name>int</name></type> <name>savelines</name> =<init> <expr>(<name>screen</name>-&gt;<name>scrollWidget</name>
			     ? <name>screen</name>-&gt;<name>savelines</name>
			     : 0)</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>cursor_state</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>HideCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SAVE_LINES</name></expr></cpp:if>
	    <comment type="block">/*
	     * The non-visible buffer is simple, since we will not copy data
	     * to/from the saved-lines.  Do that first.
	     */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>!<name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr>)</condition><then> <block>{
		<expr_stmt><expr>(<name>void</name>) <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>!<name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr>!<name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>rows</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>

	    <comment type="block">/*
	     * The save-lines buffer may change width, but will not change its
	     * height.  Deal with the cases where we copy data to/from the
	     * saved-lines buffer.
	     */</comment>
	    <if>if <condition>(<expr><call><name>GravityIsSouthWest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call>
		&amp;&amp; <name>delta_rows</name>
		&amp;&amp; <name>screen</name>-&gt;<name>saveBuf_index</name> != 0</expr>)</condition><then> <block>{

		<if>if <condition>(<expr><name>delta_rows</name> &lt; 0</expr>)</condition><then> <block>{
		    <decl_stmt><decl><type><name>unsigned</name></type> <name>move_up</name> =<init> <expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr>-<name>delta_rows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>dst</name> =<init> <expr><name>screen</name>-&gt;<name>saveBuf_index</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
		    <decl_stmt><decl><type><name>int</name></type> <name>amount</name> =<init> <expr>((<call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - (<name>int</name>) <name>move_up</name> - 1)
				  - <name>screen</name>-&gt;<name>cur_row</name>)</expr></init></decl>;</decl_stmt>

		    <if>if <condition>(<expr><name>amount</name> &lt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* move line-data from visible-buffer to save-buffer */</comment>
			<expr_stmt><expr><call><name>saveEditBufLines</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr>(<name>unsigned</name>) -<name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>move_down_by</name> = <name>amount</name></expr>;</expr_stmt>
		    }</block></then> <else>else <block>{
			<expr_stmt><expr><name>move_down_by</name> = 0</expr>;</expr_stmt>
		    }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !OPT_FIFO_LINES */</comment>
		    <decl_stmt><decl><type><name>int</name></type> <name>amount</name> =<init> <expr><name>screen</name>-&gt;<name>savelines</name> - (<name>int</name>) <name>move_up</name></expr></init></decl>;</decl_stmt>

		    <expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"before save"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>savelines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <comment type="block">/* shift lines in save-buffer to make room */</comment>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...%smoving pointers in saveBuf (compare %d %d)\n",
			   (<name>amount</name> &gt; 0
			    ? ""
			    : "SKIP "),
			   <name>screen</name>-&gt;<name>savelines</name>,
			   <name>move_up</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>amount</name> &gt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>SaveLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>move_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MoveLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,
				     <argument><expr>0</expr></argument>,
				     <argument><expr><name>move_up</name></expr></argument>,
				     <argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...reuse %d lines storage in saveBuf\n", <name>move_up</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RestoreLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,
					<argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>,
					<argument><expr><name>move_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"restoresave"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>savelines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>

		    <comment type="block">/* copy line-data from visible-buffer to save-buffer */</comment>
		    <expr_stmt><expr><call><name>saveEditBufLines</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>move_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <comment type="block">/* after data is copied, reallocate saved-lines */</comment>
		    <expr_stmt><expr>(<name>void</name>) <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>savelines</name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>savelines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"reallocSAVE"</expr></argument>,
				  <argument><expr><name>screen</name></expr></argument>,
				  <argument><expr><name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
				  <argument><expr><name>savelines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_FIFO_LINES */</comment>

		    <comment type="block">/* decrease size of visible-buffer */</comment>
		    <expr_stmt><expr>(<name>void</name>) <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>rows</name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"reallocEDIT"</expr></argument>,
				  <argument><expr><name>screen</name></expr></argument>,
				  <argument><expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				  <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
		    <decl_stmt><decl><type><name>unsigned</name></type> <name>move_down</name> =<init> <expr>(<name>unsigned</name>) <name>delta_rows</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
		    <decl_stmt><decl><type><name>long</name></type> <name>unsave_fifo</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>src</name> =<init> <expr><name>screen</name>-&gt;<name>saveBuf_index</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    <decl_stmt><decl><type><name>ScrnBuf</name></type> <name>dst</name></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>amount</name></decl>;</decl_stmt>

		    <if>if <condition>(<expr>(<name>int</name>) <name>move_down</name> &gt; <name>screen</name>-&gt;<name>savedlines</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>move_down</name> = (<name>unsigned</name>) <name>screen</name>-&gt;<name>savedlines</name></expr>;</expr_stmt>
		    }</block></then></if>
		    <expr_stmt><expr><name>move_down_by</name> = (<name>int</name>) <name>move_down</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>amount</name> = <name>rows</name> - (<name>int</name>) <name>move_down</name></expr>;</expr_stmt>

		    <comment type="block">/* increase size of visible-buffer */</comment>
		    <expr_stmt><expr>(<name>void</name>) <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>rows</name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <expr_stmt><expr><name>dst</name> = <name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"reallocEDIT"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...%smoving pointers in editBuf (compare %d %d)\n",
			   (<name>amount</name> &gt; 0
			    ? ""
			    : "SKIP "),
			   <name>rows</name>,
			   <name>move_down</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>amount</name> &gt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* shift lines in visible-buffer to make room */</comment>
			<expr_stmt><expr><call><name>SaveLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>move_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MoveLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,
				     <argument><expr><name>move_down</name></expr></argument>,
				     <argument><expr>0</expr></argument>,
				     <argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...reuse %d lines storage in editBuf\n", <name>move_down</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RestoreLineData</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,
					<argument><expr>0</expr></argument>,
					<argument><expr><name>move_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"shifted"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>

		    <comment type="block">/* copy line-data from save-buffer to visible-buffer */</comment>
		    <expr_stmt><expr><call><name>unsaveEditBufLines</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>move_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE_SCRNBUF</name><argument_list>(<argument><expr>"copied"</expr></argument>, <argument><expr><name>screen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_FIFO_LINES</name></expr></cpp:if>
		    <expr_stmt><expr><name>unsave_fifo</name> = (<name>long</name>) <name>move_down</name></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>screen</name>-&gt;<name>saved_fifo</name> &lt; (<name>int</name>) <name>unsave_fifo</name></expr>)</condition><then>
			<expr_stmt><expr><name>unsave_fifo</name> = <name>screen</name>-&gt;<name>saved_fifo</name></expr>;</expr_stmt></then></if>

		    <comment type="block">/* free up storage in fifo from the copied lines */</comment>
		    <while>while <condition>(<expr><name>unsave_fifo</name>-- &gt; 0</expr>)</condition> <block>{
			<expr_stmt><expr><call><name>deleteScrollback</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>screen</name>-&gt;<name>saved_fifo</name>--</expr>;</expr_stmt>
		    }</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		    <expr_stmt><expr><name>amount</name> = (<name>screen</name>-&gt;<name>savelines</name> - (<name>int</name>) <name>move_down</name>)</expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...%smoving pointers in saveBuf (compare %d %d)\n",
			   (<name>amount</name> &gt; 0
			    ? ""
			    : "SKIP "),
			   <name>rows</name>,
			   <name>move_down</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if>if <condition>(<expr><name>amount</name> &gt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* shift lines in save-buffer to account for copy */</comment>
			<expr_stmt><expr><name>src</name> = <name>screen</name>-&gt;<name>saveBuf_index</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SaveLineData</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>move_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MoveLineData</name><argument_list>(<argument><expr><name>src</name></expr></argument>,
				     <argument><expr><name>move_down</name></expr></argument>,
				     <argument><expr>0</expr></argument>,
				     <argument><expr>(<name>unsigned</name>) <name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("...reuse %d lines storage in saveBuf\n", <name>move_down</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RestoreLineData</name><argument_list>(<argument><expr><name>src</name></expr></argument>,
					<argument><expr>0</expr></argument>,
					<argument><expr><name>move_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		    <comment type="block">/* recover storage in save-buffer */</comment>
		}</block></else></if>
	    }</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OPT_FIFO_LINES</name></expr></cpp:if>
		<expr_stmt><expr>(<name>void</name>) <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>savelines</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>savelines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr>(<name>void</name>) <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr><name>screen</name>-&gt;<name>whichBuf</name></expr>]</index></name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>rows</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !OPT_SAVE_LINES */</comment>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name>whichBuf</name>
		&amp;&amp; <call><name>GravityIsSouthWest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* swap buffer pointers back to make this work */</comment>
		<expr_stmt><expr><name>whichBuf</name> = <name>screen</name>-&gt;<name>whichBuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SwitchBufPtrs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><name>whichBuf</name> = 0</expr>;</expr_stmt>
	    }</block></else></if>
	    <if>if <condition>(<expr><name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then>
		<expr_stmt><expr>(<name>void</name>) <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_index</name><index>[<expr>1</expr>]</index></name></expr></argument>,
				  <argument><expr>&amp;<name>screen</name>-&gt;<name><name>editBuf_data</name><index>[<expr>1</expr>]</index></name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>rows</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				  <argument><expr>(<name>unsigned</name>) <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	    <expr_stmt><expr><name>move_down_by</name> = <call><name>Reallocate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_index</name></expr></argument>,
				      <argument><expr>&amp;<name>screen</name>-&gt;<name>saveBuf_data</name></expr></argument>,
				      <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>rows</name> + <name>savelines</name></expr></argument>)</argument_list></call></expr></argument>,
				      <argument><expr>(<name>unsigned</name>) <name>cols</name></expr></argument>,
				      <argument><expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + <name>savelines</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_SAVE_LINES */</comment>
	    <expr_stmt><expr><name>screen</name>-&gt;<name>visbuf</name> = <call><name>VisBuf</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>AdjustSavedCursor</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>move_down_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_max_row</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name> + <name>delta_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_max_col</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cols</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>is_running</name></expr>)</condition><then> <block>{
	    <if>if <condition>(<expr><call><name>GravityIsSouthWest</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> -= <name>move_down_by</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>savedlines</name> &lt; 0</expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = 0</expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>savedlines</name> &gt; <name>screen</name>-&gt;<name>savelines</name></expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>savedlines</name> = <name>screen</name>-&gt;<name>savelines</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>screen</name>-&gt;<name>topline</name> &lt; -<name>screen</name>-&gt;<name>savedlines</name></expr>)</condition><then>
		    <expr_stmt><expr><name>screen</name>-&gt;<name>topline</name> = -<name>screen</name>-&gt;<name>savedlines</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>set_cur_row</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>cur_row</name> + <name>move_down_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>screen</name>-&gt;<name>cursorp</name>.<name>row</name> += <name>move_down_by</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScrollSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>move_down_by</name></expr></argument>, <argument><expr><name>True</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>whichBuf</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>SwitchBufPtrs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>whichBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>	<comment type="block">/* put the pointers back */</comment>
	    }</block></then></if>
	}</block></then></if>

	<comment type="block">/* adjust scrolling region */</comment>
	<expr_stmt><expr><call><name>set_tb_margins</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr>*<name>flags</name></expr></argument>, <argument><expr><name>ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cur_row</name> &gt; <name>screen</name>-&gt;<name>max_row</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>set_cur_row</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>screen</name>-&gt;<name>cur_col</name> &gt; <name>screen</name>-&gt;<name>max_col</name></expr>)</condition><then>
	    <expr_stmt><expr><call><name>set_cur_col</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>max_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name>screen</name>-&gt;<name>fullVwin</name>.<name>height</name> = <name>height</name> - <name>border</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>fullVwin</name>.<name>width</name> = <name>width</name> - <name>border</name> - <name>screen</name>-&gt;<name>fullVwin</name>.<name>sb_info</name>.<name>width</name></expr>;</expr_stmt>

    }</block></then> <else>else <if>if <condition>(<expr><call><name>FullHeight</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> == <name>height</name> &amp;&amp; <call><name>FullWidth</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> == <name>width</name></expr>)</condition><then>
	<return>return <expr>(0)</expr>;</return></then></if></else></if>		<comment type="block">/* nothing has changed at all */</comment>

    <expr_stmt><expr><name>screen</name>-&gt;<name>fullVwin</name>.<name>fullheight</name> = (<name>Dimension</name>) <name>height</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>screen</name>-&gt;<name>fullVwin</name>.<name>fullwidth</name> = (<name>Dimension</name>) <name>width</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ResizeScrollBar</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResizeSelection</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_ACTIVE_ICON</name></cpp:ifndef>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>window</name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XWindowChanges</name></type> <name>changes</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>width</name> =
	    <call><name>MaxCols</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> * <name>screen</name>-&gt;<name>iconVwin</name>.<name>f_width</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>height</name> =
	    <call><name>MaxRows</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> * <name>screen</name>-&gt;<name>iconVwin</name>.<name>f_height</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>changes</name>.<name>width</name> = <name>screen</name>-&gt;<name>iconVwin</name>.<name>fullwidth</name> =
	    <call>(<name>Dimension</name>) <argument_list>(<argument><expr>(<name>unsigned</name>) <name>screen</name>-&gt;<name>iconVwin</name>.<name>width</name>
			 + 2 * <name>xw</name>-&gt;<name>misc</name>.<name>icon_border_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>changes</name>.<name>height</name> = <name>screen</name>-&gt;<name>iconVwin</name>.<name>fullheight</name> =
	    <call>(<name>Dimension</name>) <argument_list>(<argument><expr>(<name>unsigned</name>) <name>screen</name>-&gt;<name>iconVwin</name>.<name>height</name>
			 + 2 * <name>xw</name>-&gt;<name>misc</name>.<name>icon_border_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>changes</name>.<name>border_width</name> = (<name>int</name>) <name>xw</name>-&gt;<name>misc</name>.<name>icon_border_width</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("resizing icon window %dx%d\n", <name>changes</name>.<name>height</name>, <name>changes</name>.<name>width</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XConfigureWindow</name><argument_list>(<argument><expr><call><name>XtDisplay</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>screen</name>-&gt;<name>iconVwin</name>.<name>window</name></expr></argument>,
			 <argument><expr><name>CWWidth</name> | <name>CWHeight</name> | <name>CWBorderWidth</name></expr></argument>, <argument><expr>&amp;<name>changes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_ACTIVE_ICON */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TTYSIZE_STRUCT</name></cpp:ifdef>
    <comment type="block">/* Set tty's idea of window size */</comment>
    <expr_stmt><expr><call><name>TTYSIZE_ROWS</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call> = (<name>ttySize_t</name>) <name>rows</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TTYSIZE_COLS</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call> = (<name>ttySize_t</name>) <name>cols</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_STRUCT_WINSIZE</name></cpp:ifdef>
    <expr_stmt><expr><name>ts</name>.<name>ws_xpixel</name> = (<name>ttySize_t</name>) <name>width</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ts</name>.<name>ws_ypixel</name> = (<name>ttySize_t</name>) <name>height</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>code</name> = <call><name>SET_TTYSIZE</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("return %d from SET_TTYSIZE %dx%d\n", <name>code</name>, <name>rows</name>, <name>cols</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <name>code</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>USE_STRUCT_TTYSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr><name>screen</name>-&gt;<name>pid</name> &gt; 1</expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>pgrp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("getting process-group\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name>screen</name>-&gt;<name>respond</name></expr></argument>, <argument><expr><name>TIOCGPGRP</name></expr></argument>, <argument><expr>&amp;<name>pgrp</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("sending SIGWINCH to process group %d\n", <name>pgrp</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>kill_process_group</name><argument_list>(<argument><expr><name>pgrp</name></expr></argument>, <argument><expr><name>SIGWINCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGWINCH */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ScreenResize cannot do anything to pty\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TTYSIZE_STRUCT */</comment>
    <return>return <expr>(0)</expr>;</return>
}</block></function>

<comment type="block">/*
 * Return true if any character cell starting at [row,col], for len-cells is
 * nonnull.
 */</comment>
<function><type><name>Bool</name></type>
<name>non_blank_line</name><parameter_list>(<param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>row</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>col</name></decl></param>,
	       <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>found</name> =<init> <expr><name>False</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name> =<init> <expr><call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ld</name> != 0</expr>)</condition><then> <block>{
	<for>for (<init><expr><name>i</name> = <name>col</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	    <if>if <condition>(<expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>found</name> = <name>True</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></then></if>
	}</block></for>
    }</block></then></if>
    <return>return <expr><name>found</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Rectangle parameters start from one.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>minRectRow</name>(screen) (getMinRow(screen) + 1)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>minRectCol</name>(screen) (getMinCol(screen) + 1)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>maxRectRow</name>(screen) (getMaxRow(screen) + 1)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>maxRectCol</name>(screen) (getMaxCol(screen) + 1)</cpp:define>

<function><type><name>static</name> <name>int</name></type>
<name>limitedParseRow</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>row</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>min_row</name> =<init> <expr><call><name>minRectRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_row</name> =<init> <expr><call><name>maxRectRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>row</name> &lt; <name>min_row</name></expr>)</condition><then>
	<expr_stmt><expr><name>row</name> = <name>min_row</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>row</name> &gt; <name>max_row</name></expr>)</condition><then>
	<expr_stmt><expr><name>row</name> = <name>max_row</name></expr>;</expr_stmt></then></if></else></if>
    <return>return <expr><name>row</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type>
<name>limitedParseCol</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>TScreen</name> *</type> <name>screen</name></decl></param>, <param><decl><type><name>int</name></type> <name>col</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>min_col</name> =<init> <expr><call><name>minRectCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_col</name> =<init> <expr><call><name>maxRectCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>) <name>xw</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>col</name> &lt; <name>min_col</name></expr>)</condition><then>
	<expr_stmt><expr><name>col</name> = <name>min_col</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>col</name> &gt; <name>max_col</name></expr>)</condition><then>
	<expr_stmt><expr><name>col</name> = <name>max_col</name></expr>;</expr_stmt></then></if></else></if>
    <return>return <expr><name>col</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>LimitedParse</name>(num, func, dft) \
	func(xw, screen, (nparams &gt; num) ? params[num] : dft)</cpp:define>

<comment type="block">/*
 * Copy the rectangle boundaries into a struct, providing default values as
 * needed.
 */</comment>
<function><type><name>void</name></type>
<name>xtermParseRect</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>int</name></type> <name>nparams</name></decl></param>, <param><decl><type><name>int</name> *</type><name>params</name></decl></param>, <param><decl><type><name>XTermRect</name> *</type> <name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>target</name>-&gt;<name>top</name> = <call><name>LimitedParse</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>limitedParseRow</name></expr></argument>, <argument><expr><call><name>minRectRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>target</name>-&gt;<name>left</name> = <call><name>LimitedParse</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>limitedParseCol</name></expr></argument>, <argument><expr><call><name>minRectCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>target</name>-&gt;<name>bottom</name> = <call><name>LimitedParse</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>limitedParseRow</name></expr></argument>, <argument><expr><call><name>maxRectRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>target</name>-&gt;<name>right</name> = <call><name>LimitedParse</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>limitedParseCol</name></expr></argument>, <argument><expr><call><name>maxRectCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("parsed rectangle %d,%d %d,%d\n",
	   <name>target</name>-&gt;<name>top</name>,
	   <name>target</name>-&gt;<name>left</name>,
	   <name>target</name>-&gt;<name>bottom</name>,
	   <name>target</name>-&gt;<name>right</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>Bool</name></type>
<name>validRect</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XTermRect</name> *</type> <name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("comparing against screensize %dx%d\n",
	   <call><name>maxRectRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>,
	   <call><name>maxRectCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>target</name> != 0
	    &amp;&amp; <name>target</name>-&gt;<name>top</name> &gt;= <call><name>minRectRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <name>target</name>-&gt;<name>left</name> &gt;= <call><name>minRectCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <name>target</name>-&gt;<name>top</name> &lt;= <name>target</name>-&gt;<name>bottom</name>
	    &amp;&amp; <name>target</name>-&gt;<name>left</name> &lt;= <name>target</name>-&gt;<name>right</name>
	    &amp;&amp; <name>target</name>-&gt;<name>top</name> &lt;= <call><name>maxRectRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
	    &amp;&amp; <name>target</name>-&gt;<name>right</name> &lt;= <call><name>maxRectCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<comment type="block">/*
 * Fills a rectangle with the given 8-bit character and video-attributes.
 * Colors and double-size attribute are unmodified.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnFillRectangle</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		  <param><decl><type><name>XTermRect</name> *</type> <name>target</name></decl></param>,
		  <param><decl><type><name>int</name></type> <name>value</name></decl></param>,
		  <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,
		  <param><decl><type><name>Bool</name></type> <name>keepColors</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("filling rectangle with '%c' flags %#x\n", <name>value</name>, <name>flags</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>validRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>left</name> =<init> <expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>target</name>-&gt;<name>left</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>size</name> =<init> <expr><call>(<name>unsigned</name>) <argument_list>(<argument><expr><name>target</name>-&gt;<name>right</name> - (<name>int</name>) <name>left</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>attrs</name> =<init> <expr><name>flags</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>row</name>, <name>col</name></decl>;</decl_stmt>

	<expr_stmt><expr>(<name>void</name>) <name>size</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>attrs</name> &amp;= <name>ATTRIBUTES</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrs</name> |= <name>CHARDRAWN</name></expr>;</expr_stmt>
	<for>for (<init><expr><name>row</name> = <name>target</name>-&gt;<name>bottom</name> - 1</expr>;</init> <condition><expr><name>row</name> &gt;= (<name>target</name>-&gt;<name>top</name> - 1)</expr>;</condition> <incr><expr><name>row</name>--</expr></incr>) <block>{
	    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("filling %d [%d..%d]\n", <name>row</name>, <name>left</name>, <name>left</name> + <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/*
	     * Fill attributes, preserving "protected" flag, as well as
	     * colors if asked.
	     */</comment>
	    <for>for (<init><expr><name>col</name> = (<name>int</name>) <name>left</name></expr>;</init> <condition><expr><name>col</name> &lt; <name>target</name>-&gt;<name>right</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>unsigned</name></type> <name>temp</name> =<init> <expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr>!<name>keepColors</name></expr>)</condition><then> <block>{
		    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr>(<name>FG_COLOR</name> | <name>BG_COLOR</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>temp</name> = <name>attrs</name> | (<name>temp</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name> | <name>PROTECTED</name>))</expr>;</expr_stmt>
		<expr_stmt><expr><name>temp</name> |= <name>CHARDRAWN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> = (<name>Char</name>) <name>temp</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_ISO_COLORS</name></expr></cpp:if>
		<if>if <condition>(<expr><name>attrs</name> &amp; (<name>FG_COLOR</name> | <name>BG_COLOR</name>)</expr>)</condition><then> <block>{
		    <macro><name>if_OPT_ISO_COLORS</name><argument_list>(<argument>screen</argument>, <argument>{
			ld-&gt;color[col] = xtermColorPair(xw);
		    }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	    }</block></for>

	    <for>for (<init><expr><name>col</name> = (<name>int</name>) <name>left</name></expr>;</init> <condition><expr><name>col</name> &lt; <name>target</name>-&gt;<name>right</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>)
		<expr_stmt><expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>col</name></expr>]</index></name> = (<name>CharData</name>) <name>value</name></expr>;</expr_stmt></for>

	    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
		size_t off;
		for_each_combData(off, ld) {
		    memset(ld-&gt;combData[off] + left, 0, size * sizeof(CharData));
		}
	    }</argument>)</argument_list></macro>
	}</block></for>
	<expr_stmt><expr><call><name>ScrnUpdate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
		   <argument><expr><name>target</name>-&gt;<name>top</name> - 1</expr></argument>,
		   <argument><expr><name>target</name>-&gt;<name>left</name> - 1</expr></argument>,
		   <argument><expr>(<name>target</name>-&gt;<name>bottom</name> - <name>target</name>-&gt;<name>top</name>) + 1</expr></argument>,
		   <argument><expr>(<name>target</name>-&gt;<name>right</name> - <name>target</name>-&gt;<name>left</name>) + 1</expr></argument>,
		   <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DEC_RECTOPS</name></expr></cpp:if>
<comment type="block">/*
 * Copies the source rectangle to the target location, including video
 * attributes.
 *
 * This implementation ignores page numbers.
 *
 * The reference manual does not indicate if it handles overlapping copy
 * properly - so we make a local copy of the source rectangle first, then apply
 * the target from that.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnCopyRectangle</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>, <param><decl><type><name>XTermRect</name> *</type> <name>source</name></decl></param>, <param><decl><type><name>int</name></type> <name>nparam</name></decl></param>, <param><decl><type><name>int</name> *</type><name>params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("copying rectangle\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>validRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>XTermRect</name></type> <name>target</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>xtermParseRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
		       <argument><expr>((<name>nparam</name> &gt; 3) ? 2 : (<name>nparam</name> - 1))</expr></argument>,
		       <argument><expr><name>params</name></expr></argument>,
		       <argument><expr>&amp;<name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>validRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr>&amp;<name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <decl_stmt><decl><type><name>Cardinal</name></type> <name>high</name> =<init> <expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>source</name>-&gt;<name>bottom</name> - <name>source</name>-&gt;<name>top</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Cardinal</name></type> <name>wide</name> =<init> <expr><call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>source</name>-&gt;<name>right</name> - <name>source</name>-&gt;<name>left</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Cardinal</name></type> <name>size</name> =<init> <expr>(<name>high</name> * <name>wide</name>)</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>row</name>, <name>col</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>Cardinal</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>

	    <decl_stmt><decl><type><name>CellData</name> *</type><name>cells</name> =<init> <expr><call><name>newCellData</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <if>if <condition>(<expr><name>cells</name> != 0</expr>)</condition><then> <block>{

		<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("OK - make copy %dx%d\n", <name>high</name>, <name>wide</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>target</name>.<name>bottom</name> = <name>target</name>.<name>top</name> + <call>(<name>int</name>) <argument_list>(<argument><expr><name>high</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>target</name>.<name>right</name> = <name>target</name>.<name>left</name> + <call>(<name>int</name>) <argument_list>(<argument><expr><name>wide</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for (<init><expr><name>row</name> = <name>source</name>-&gt;<name>top</name> - 1</expr>;</init> <condition><expr><name>row</name> &lt; <name>source</name>-&gt;<name>bottom</name></expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
		    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>j</name> = <call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>row</name> - (<name>source</name>-&gt;<name>top</name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <for>for (<init><expr><name>col</name> = <name>source</name>-&gt;<name>left</name> - 1</expr>;</init> <condition><expr><name>col</name> &lt; <name>source</name>-&gt;<name>right</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
			<expr_stmt><expr><name>k</name> = <call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>col</name> - (<name>source</name>-&gt;<name>left</name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>saveCellData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cells</name></expr></argument>,
				     <argument><expr>(<name>j</name> * <name>wide</name>) + <name>k</name></expr></argument>,
				     <argument><expr><name>ld</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    }</block></for>
		}</block></for>
		<for>for (<init><expr><name>row</name> = <name>target</name>.<name>top</name> - 1</expr>;</init> <condition><expr><name>row</name> &lt; <name>target</name>.<name>bottom</name></expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
		    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>j</name> = <call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>row</name> - (<name>target</name>.<name>top</name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <for>for (<init><expr><name>col</name> = <name>target</name>.<name>left</name> - 1</expr>;</init> <condition><expr><name>col</name> &lt; <name>target</name>.<name>right</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
			<expr_stmt><expr><name>k</name> = <call>(<name>Cardinal</name>) <argument_list>(<argument><expr><name>col</name> - (<name>target</name>.<name>left</name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>row</name> &gt;= <call><name>getMinRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
			    &amp;&amp; <name>row</name> &lt;= <call><name>getMaxRow</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
			    &amp;&amp; <name>col</name> &gt;= <call><name>getMinCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>
			    &amp;&amp; <name>col</name> &lt;= <call><name>getMaxCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			    <if>if <condition>(<expr><name>j</name> &lt; <name>high</name> &amp;&amp; <name>k</name> &lt; <name>wide</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>restoreCellData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>cells</name></expr></argument>,
						<argument><expr>(<name>j</name> * <name>wide</name>) + <name>k</name></expr></argument>,
						<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    }</block></then> <else>else <block>{
				<comment type="block">/* FIXME - clear the target cell? */</comment>
			    }</block></else></if>
			    <expr_stmt><expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> |= <name>CHARDRAWN</name></expr>;</expr_stmt>
			}</block></then></if>
		    }</block></for>
		}</block></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cells</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScrnUpdate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
			   <argument><expr>(<name>target</name>.<name>top</name> - 1)</expr></argument>,
			   <argument><expr>(<name>target</name>.<name>left</name> - 1)</expr></argument>,
			   <argument><expr>(<name>target</name>.<name>bottom</name> - <name>target</name>.<name>top</name>) + 1</expr></argument>,
			   <argument><expr>((<name>target</name>.<name>right</name> - <name>target</name>.<name>left</name>) + 1)</expr></argument>,
			   <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Modifies the video-attributes only - so selection (not a video attribute) is
 * unaffected.  Colors and double-size flags are unaffected as well.
 *
 * FIXME: our representation for "invisible" does not work with this operation,
 * since the attribute byte is fully-allocated for other flags.  The logic
 * is shown for INVISIBLE because it's harmless, and useful in case the
 * CHARDRAWN or PROTECTED flags are reassigned.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnMarkRectangle</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		  <param><decl><type><name>XTermRect</name> *</type> <name>target</name></decl></param>,
		  <param><decl><type><name>Bool</name></type> <name>reverse</name></decl></param>,
		  <param><decl><type><name>int</name></type> <name>nparam</name></decl></param>,
		  <param><decl><type><name>int</name> *</type><name>params</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bool</name></type> <name>exact</name> =<init> <expr>(<name>screen</name>-&gt;<name>cur_decsace</name> == 2)</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("%s %s\n",
	   <name>reverse</name> ? "reversing" : "marking",
	   (<name>exact</name>
	    ? "rectangle"
	    : "region"))</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>validRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>top</name> =<init> <expr><name>target</name>-&gt;<name>top</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bottom</name> =<init> <expr><name>target</name>-&gt;<name>bottom</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>row</name>, <name>col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>row</name> = <name>top</name></expr>;</init> <condition><expr><name>row</name> &lt;= <name>bottom</name></expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>left</name> =<init> <expr>((<name>exact</name> || (<name>row</name> == <name>top</name>))
			? (<name>target</name>-&gt;<name>left</name> - 1)
			: <call><name>getMinCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>right</name> =<init> <expr>((<name>exact</name> || (<name>row</name> == <name>bottom</name>))
			 ? (<name>target</name>-&gt;<name>right</name> - 1)
			 : <call><name>getMaxCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("marking %d [%d..%d]\n", <name>row</name>, <name>left</name>, <name>right</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>col</name> = <name>left</name></expr>;</init> <condition><expr><name>col</name> &lt;= <name>right</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> =<init> <expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>nparam</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
		    <if>if <condition>(<expr><name>row</name> == <name>top</name> &amp;&amp; <name>col</name> == <name>left</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("attr param[%d] %d\n", <name>n</name> + 1, <name><name>params</name><index>[<expr><name>n</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    <if>if <condition>(<expr><name>reverse</name></expr>)</condition><then> <block>{
			<switch>switch <condition>(<expr><name><name>params</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition> <block>{
			<case>case <expr>1</expr>:
			    <expr_stmt><expr><name>flags</name> ^= <name>BOLD</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>4</expr>:
			    <expr_stmt><expr><name>flags</name> ^= <name>UNDERLINE</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>5</expr>:
			    <expr_stmt><expr><name>flags</name> ^= <name>BLINK</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>7</expr>:
			    <expr_stmt><expr><name>flags</name> ^= <name>INVERSE</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>8</expr>:
			    <expr_stmt><expr><name>flags</name> ^= <name>INVISIBLE</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case>}</block></switch>
		    }</block></then> <else>else <block>{
			<switch>switch <condition>(<expr><name><name>params</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition> <block>{
			<case>case <expr>0</expr>:
			    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>SGR_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>1</expr>:
			    <expr_stmt><expr><name>flags</name> |= <name>BOLD</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>4</expr>:
			    <expr_stmt><expr><name>flags</name> |= <name>UNDERLINE</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>5</expr>:
			    <expr_stmt><expr><name>flags</name> |= <name>BLINK</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>7</expr>:
			    <expr_stmt><expr><name>flags</name> |= <name>INVERSE</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>8</expr>:
			    <expr_stmt><expr><name>flags</name> |= <name>INVISIBLE</name></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>22</expr>:
			    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>BOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>24</expr>:
			    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>UNDERLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>25</expr>:
			    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>BLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>27</expr>:
			    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>INVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <break>break;</break>
			</case><case>case <expr>28</expr>:
			    <expr_stmt><expr><call><name>UIntClr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>INVISIBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <break>break;</break>
			</case>}</block></switch>
		    }</block></else></if>
		}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TRACE</name></expr></cpp:if>
		<if>if <condition>(<expr><name>row</name> == <name>top</name> &amp;&amp; <name>col</name> == <name>left</name></expr>)</condition><then>
		    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("first mask-change is %#x\n",
			   <name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> ^ <name>flags</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> = (<name>Char</name>) <name>flags</name></expr>;</expr_stmt>
	    }</block></for>
	}</block></for>
	<expr_stmt><expr><call><name>ScrnRefresh</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
		    <argument><expr>(<name>target</name>-&gt;<name>top</name> - 1)</expr></argument>,
		    <argument><expr>(<name>exact</name> ? (<name>target</name>-&gt;<name>left</name> - 1) : <call><name>getMinCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call>)</expr></argument>,
		    <argument><expr>(<name>target</name>-&gt;<name>bottom</name> - <name>target</name>-&gt;<name>top</name>) + 1</expr></argument>,
		    <argument><expr>(<name>exact</name>
		     ? ((<name>target</name>-&gt;<name>right</name> - <name>target</name>-&gt;<name>left</name>) + 1)
		     : (<call><name>getMaxCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> - <call><name>getMinCol</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call> + 1))</expr></argument>,
		    <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Resets characters to space, except where prohibited by DECSCA.  Video
 * attributes (including color) are untouched.
 */</comment>
<function><type><name>void</name></type>
<name>ScrnWipeRectangle</name><parameter_list>(<param><decl><type><name>XtermWidget</name></type> <name>xw</name></decl></param>,
		  <param><decl><type><name>XTermRect</name> *</type> <name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TScreen</name> *</type><name>screen</name> =<init> <expr><call><name>TScreenOf</name><argument_list>(<argument><expr><name>xw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("wiping rectangle\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>validRect</name><argument_list>(<argument><expr><name>xw</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>LineData</name> *</type><name>ld</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>top</name> =<init> <expr><name>target</name>-&gt;<name>top</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bottom</name> =<init> <expr><name>target</name>-&gt;<name>bottom</name> - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>row</name>, <name>col</name></decl>;</decl_stmt>

	<for>for (<init><expr><name>row</name> = <name>top</name></expr>;</init> <condition><expr><name>row</name> &lt;= <name>bottom</name></expr>;</condition> <incr><expr>++<name>row</name></expr></incr>) <block>{
	    <decl_stmt><decl><type><name>int</name></type> <name>left</name> =<init> <expr>(<name>target</name>-&gt;<name>left</name> - 1)</expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>right</name> =<init> <expr>(<name>target</name>-&gt;<name>right</name> - 1)</expr></init></decl>;</decl_stmt>

	    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("wiping %d [%d..%d]\n", <name>row</name>, <name>left</name>, <name>right</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><name>ld</name> = <call><name>getLineData</name><argument_list>(<argument><expr><name>screen</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <for>for (<init><expr><name>col</name> = <name>left</name></expr>;</init> <condition><expr><name>col</name> &lt;= <name>right</name></expr>;</condition> <incr><expr>++<name>col</name></expr></incr>) <block>{
		<if>if <condition>(<expr>!((<name>screen</name>-&gt;<name>protected_mode</name> == <name>DEC_PROTECT</name>)
		      &amp;&amp; (<name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> &amp; <name>PROTECTED</name>))</expr>)</condition><then> <block>{
		    <expr_stmt><expr><name>ld</name>-&gt;<name><name>attribs</name><index>[<expr><name>col</name></expr>]</index></name> |= <name>CHARDRAWN</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>ld</name>-&gt;<name><name>charData</name><index>[<expr><name>col</name></expr>]</index></name> = ' '</expr>;</expr_stmt>
		    <macro><name>if_OPT_WIDE_CHARS</name><argument_list>(<argument>screen</argument>, <argument>{
			size_t off;
			for_each_combData(off, ld) {
			    ld-&gt;combData[off][col] = '\0';
			}
		    }</argument>)</argument_list></macro>
		}</block></then></if>
	    }</block></for>
	}</block></for>
	<expr_stmt><expr><call><name>ScrnUpdate</name><argument_list>(<argument><expr><name>xw</name></expr></argument>,
		   <argument><expr>(<name>target</name>-&gt;<name>top</name> - 1)</expr></argument>,
		   <argument><expr>(<name>target</name>-&gt;<name>left</name> - 1)</expr></argument>,
		   <argument><expr>(<name>target</name>-&gt;<name>bottom</name> - <name>target</name>-&gt;<name>top</name>) + 1</expr></argument>,
		   <argument><expr>((<name>target</name>-&gt;<name>right</name> - <name>target</name>-&gt;<name>left</name>) + 1)</expr></argument>,
		   <argument><expr><name>False</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OPT_DEC_RECTOPS */</comment>
</unit>
